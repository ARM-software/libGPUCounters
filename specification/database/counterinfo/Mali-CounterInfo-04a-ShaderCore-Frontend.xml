<?xml version="1.0" ?>
<!--
#
# Copyright (c) 2019-2025 Arm Limited.
#
# SPDX-License-Identifier: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
-->
<CounterInfoList>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliAnyActiveCy</MachineName>
    <SourceName>SHADER_CORE_ACTIVE</SourceName>
    <StableID>207</StableID>
    <HumanName>Any workload active cycles</HumanName>
    <GroupName>Shader Core Cycles</GroupName>
    <GroupHumanName>Any workload active</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of cycles when the shader core is processing either a
      non-fragment workload or a fragment workload.
    </ShortDescription>
    <LongDescription>
      This counter increments every clock cycle when the shader core is
      processing any type of workload, irrespective of which queue the workload
      came from.

      This counter is particularly useful in high-end GPU configurations where
      it can indicate the shader core clock rate. This rate can be lower than
      the GPU top-level clock rate.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliAnyUtil</MachineName>
    <StableID>65596</StableID>
    <HumanName>Shader core clock ratio</HumanName>
    <GroupName>Shader Clock Ratio</GroupName>
    <GroupHumanName>Shader core clock ratio</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      An estimate of shader core use relative to the GPU top-level clock.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage usage of the shader core, relative
      to the top-level GPU clock.

      To improve energy efficiency, some systems clock the shader cores at a
      lower frequency than the GPU top-level components. In these systems, the
      maximum achievable usage value is the clock ratio between the GPU
      top-level clock and the shader clock. For example, a GPU with an 800MHz
      top-level clock and a 400MHz shader clock can achieve a maximum usage of
      50%.
    </LongDescription>
    <Equation>
      (MaliAnyActiveCy / MaliConfigCoreCount / MaliGPUActiveCy) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliNonFragActiveCy</MachineName>
    <SourceName>COMPUTE_ACTIVE</SourceName>
    <StableID>226</StableID>
    <HumanName>Non-fragment active cycles</HumanName>
    <GroupName>Shader Core Cycles</GroupName>
    <GroupHumanName>Non-fragment active</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of cycles when the shader core is processing some non-fragment
      workload.
    </ShortDescription>
    <LongDescription>
      This counter increments every clock cycle when the shader core is
      processing some non-fragment workload. Active processing includes any
      cycle that non-fragment work is queued in the fixed-function front-end or
      programmable core.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliCompOrBinningActiveCy</MachineName>
    <SourceName>COMPUTE_ACTIVE</SourceName>
    <StableID>472</StableID>
    <HumanName>Compute or binning phase active cycles</HumanName>
    <GroupName>Shader Core Cycles</GroupName>
    <GroupHumanName>Compute or binning phase active</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of cycles when the shader core is processing some compute or
      binning phase workload.
    </ShortDescription>
    <LongDescription>
      This counter increments every clock cycle when the shader core is
      processing some compute or binning phase workload. Active processing
      includes any cycle that compute or binning work is queued in the
      fixed-function front-end or programmable core.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliNonFragUtil</MachineName>
    <StableID>65589</StableID>
    <HumanName>Non-fragment utilization</HumanName>
    <GroupName>Shader Core Utilization</GroupName>
    <GroupHumanName>Non-fragment utilization</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The utilization of the shader core non-fragment path.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage utilization of the shader core
      non-fragment path. This counter measures any cycle that a non-fragment
      workload is active in the fixed-function front-end or programmable core.
    </LongDescription>
    <Equation>
      (MaliNonFragActiveCy / MaliConfigCoreCount / MaliGPUActiveCy) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliNonFragUtil</MachineName>
    <StableID>65589</StableID>
    <HumanName>Non-fragment utilization</HumanName>
    <GroupName>Shader Core Utilization</GroupName>
    <GroupHumanName>Non-fragment utilization</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The utilization of the shader core non-fragment path.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage utilization of the shader core
      non-fragment path. This counter measures any cycle that a non-fragment
      workload is active in the fixed-function front-end or programmable core.
    </LongDescription>
    <Equation>
      (MaliNonFragActiveCy / MaliAnyActiveCy) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliCompOrBinningUtil</MachineName>
    <StableID>473</StableID>
    <HumanName>Compute or binning phase utilization</HumanName>
    <GroupName>Shader Core Utilization</GroupName>
    <GroupHumanName>Compute or binning phase utilization</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The utilization of the shader core compute or binning phase path.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage utilization of the shader core
      compute or binning phase path. This counter measures any cycle that a
      compute or binning phase workload is active in the fixed-function
      front-end or programmable core.
    </LongDescription>
    <Equation>
      (MaliCompOrBinningActiveCy / MaliAnyActiveCy) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliNonFragThroughputCy</MachineName>
    <StableID>65593</StableID>
    <HumanName>Average cycles per non-fragment thread</HumanName>
    <GroupName>Average Workload Cost</GroupName>
    <GroupHumanName>Shader cycles/non-fragment thread</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The average number of shader core cycles per non-fragment thread.
    </ShortDescription>
    <LongDescription>
      This expression defines the average number of shader core cycles per
      non-fragment thread.

      This measurement captures the overall shader core throughput, not the
      shader processing cost. It will be impacted by cycles lost to stalls that
      could not be hidden by other processing. In addition, it will be impacted
      by any fragment workloads that are running concurrently in the shader
      core.
    </LongDescription>
    <Equation>
      MaliNonFragActiveCy / MaliNonFragThread
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliNonFragThroughputCy</MachineName>
    <StableID>65593</StableID>
    <HumanName>Average cycles per non-fragment thread</HumanName>
    <GroupName>Average Workload Cost</GroupName>
    <GroupHumanName>Shader cycles/non-fragment thread</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The average number of shader core cycles per non-fragment thread.
    </ShortDescription>
    <LongDescription>
      This expression defines the average number of shader core cycles per
      non-fragment thread.

      This measurement captures the overall shader core throughput, not the
      shader processing cost. It will be impacted by cycles lost to stalls that
      could not be hidden by other processing. In addition, it will be impacted
      by any fragment workloads that are running concurrently in the shader
      core.
    </LongDescription>
    <Equation>
      MaliCompOrBinningActiveCy / MaliNonFragThread
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragActiveCy</MachineName>
    <SourceName>FRAG_ACTIVE</SourceName>
    <StableID>196</StableID>
    <HumanName>Fragment active cycles</HumanName>
    <GroupName>Shader Core Cycles</GroupName>
    <GroupHumanName>Fragment active</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of cycles when the shader core is processing a fragment
      workload.
    </ShortDescription>
    <LongDescription>
      This counter increments every clock cycle when the shader core is
      processing some fragment workload. Active processing includes any cycle
      that fragment work is running anywhere in the fixed-function front-end,
      fixed-function back-end, or programmable core.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliMainActiveCy</MachineName>
    <SourceName>FRAG_ACTIVE</SourceName>
    <StableID>469</StableID>
    <HumanName>Main phase active cycles</HumanName>
    <GroupName>Shader Core Cycles</GroupName>
    <GroupHumanName>Main phase active</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of cycles when the shader core is processing a main phase
      workload.
    </ShortDescription>
    <LongDescription>
      This counter increments every clock cycle when the shader core is
      processing some main phase workload. Active processing includes any cycle
      that fragment work is running anywhere in the fixed-function front-end,
      fixed-function back-end, or programmable core.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragUtil</MachineName>
    <StableID>65567</StableID>
    <HumanName>Fragment utilization</HumanName>
    <GroupName>Shader Core Utilization</GroupName>
    <GroupHumanName>Fragment utilization</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The utilization of the shader core fragment path.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage utilization of the shader core
      fragment path. This counter measures any cycle that a fragment workload
      is active in the fixed-function front-end, fixed-function back-end, or
      programmable core.
    </LongDescription>
    <Equation>
      (MaliFragActiveCy / MaliConfigCoreCount / MaliGPUActiveCy) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragUtil</MachineName>
    <StableID>65567</StableID>
    <HumanName>Fragment utilization</HumanName>
    <GroupName>Shader Core Utilization</GroupName>
    <GroupHumanName>Fragment utilization</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The utilization of the shader core fragment path.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage utilization of the shader core
      fragment path. This counter measures any cycle that a fragment workload
      is active in the fixed-function front-end, fixed-function back-end, or
      programmable core.
    </LongDescription>
    <Equation>
      (MaliFragActiveCy / MaliAnyActiveCy) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliMainUtil</MachineName>
    <StableID>470</StableID>
    <HumanName>Main phase utilization</HumanName>
    <GroupName>Shader Core Utilization</GroupName>
    <GroupHumanName>Main phase utilization</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The utilization of the shader core main phase path.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage utilization of the shader core
      main phase path. This counter measures any cycle that a main phase
      workload is active in the fixed-function front-end, fixed-function
      back-end, or programmable core.
    </LongDescription>
    <Equation>
      (MaliMainActiveCy / MaliAnyActiveCy) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragThroughputCy</MachineName>
    <StableID>65575</StableID>
    <HumanName>Average cycles per fragment thread</HumanName>
    <GroupName>Average Workload Cost</GroupName>
    <GroupHumanName>Shader cycles/fragment thread</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The average number of shader core cycles per fragment thread.
    </ShortDescription>
    <LongDescription>
      This expression defines the average number of shader core cycles per
      fragment thread.

      This measurement captures the overall shader core throughput, not the
      shader processing cost. It will be impacted by cycles lost to stalls that
      could not be hidden by other processing. In addition, it will be impacted
      by any fragment workloads that are running concurrently in the shader
      core.
    </LongDescription>
    <Equation>
      MaliFragActiveCy / MaliFragThread
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragThroughputCy</MachineName>
    <StableID>65575</StableID>
    <HumanName>Average cycles per fragment thread</HumanName>
    <GroupName>Average Workload Cost</GroupName>
    <GroupHumanName>Shader cycles/fragment thread</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The average number of shader core cycles per fragment thread.
    </ShortDescription>
    <LongDescription>
      This expression defines the average number of shader core cycles per
      fragment thread.

      This measurement captures the overall shader core throughput, not the
      shader processing cost. It will be impacted by cycles lost to stalls that
      could not be hidden by other processing. In addition, it will be impacted
      by any fragment workloads that are running concurrently in the shader
      core.
    </LongDescription>
    <Equation>
      MaliMainActiveCy / MaliFragThread
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragThroughputCy</MachineName>
    <StableID>65575</StableID>
    <HumanName>Average cycles per fragment thread</HumanName>
    <GroupName>Average Workload Cost</GroupName>
    <GroupHumanName>Shader cycles/fragment thread</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The average number of shader core cycles per fragment thread.
    </ShortDescription>
    <LongDescription>
      This expression defines the average number of shader core cycles per
      fragment thread.

      This measurement captures the overall shader core throughput, not the
      shader processing cost. It will be impacted by cycles lost to stalls that
      could not be hidden by other processing. In addition, it will be impacted
      by any fragment workloads that are running concurrently in the shader
      core.
    </LongDescription>
    <Equation>
      MaliMainActiveCy / MaliFragMainThread
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragFPKActiveCy</MachineName>
    <SourceName>FRAG_FPK_ACTIVE</SourceName>
    <StableID>212</StableID>
    <HumanName>Fragment pre-pipe buffer active cycles</HumanName>
    <GroupName>Shader Core Cycles</GroupName>
    <GroupHumanName>Fragment pre-pipe buffer active</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of cycles when at least one quad is present in the pre-pipe
      quad queue.
    </ShortDescription>
    <LongDescription>
      This counter increments every clock cycle when the pre-pipe quad queue
      contains at least one quad waiting to run. If this queue completely
      drains, a fragment warp cannot be spawned when space for new threads
      becomes available in the shader core. You can experience reduced
      performance when low thread occupancy starves the functional units of
      work to process.

      Possible causes for this include:

      * Tiles which contain no geometry, which are commonly encountered when
        creating shadow maps, where many tiles contain no shadow casters.
      * Tiles which contain a lot of geometry which are killed by early ZS or
        hidden surface removal.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragFPKBUtil</MachineName>
    <StableID>65569</StableID>
    <HumanName>Fragment pre-pipe buffer utilization</HumanName>
    <GroupName>Shader Core Utilization</GroupName>
    <GroupHumanName>Fragment pre-pipe buffer utilization</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of cycles when at least one quad is buffered for fragment
      shading.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of cycles when the pre-pipe quad
      buffer contains at least one fragment quad. This buffer is located after
      early ZS but before the programmable core.

      During fragment shading this counter must be close to 100%. This
      indicates that the fragment front-end is able to keep up with the shader
      core shading performance. This counter commonly drops below 100% for
      three reasons:

      * The running workload has many empty tiles with no geometry to render.
        Empty tiles are common in shadow maps, corresponding to a screen region
        with no shadow casters, so this might not be avoidable.
      * The application consists of simple shaders but a high percentage of
        microtriangles. This combination causes the shader core to shade
        fragments faster than they are rasterized, so the quad buffer drains.
      * The application consists of geometry which stalls at early ZS because
        of a dependency on an earlier fragment layer which is still in flight.
        Stalled layers prevent new fragments entering the quad buffer, so the
        quad buffer drains.
    </LongDescription>
    <Equation>
      (MaliFragFPKActiveCy / MaliFragActiveCy) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragFPKBUtil</MachineName>
    <StableID>65569</StableID>
    <HumanName>Fragment pre-pipe buffer utilization</HumanName>
    <GroupName>Shader Core Utilization</GroupName>
    <GroupHumanName>Fragment pre-pipe buffer utilization</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of cycles when at least one quad is buffered for fragment
      shading.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of cycles when the pre-pipe quad
      buffer contains at least one fragment quad. This buffer is located after
      early ZS but before the programmable core.

      During fragment shading this counter must be close to 100%. This
      indicates that the fragment front-end is able to keep up with the shader
      core shading rate. This counter commonly drops below 100% for three
      reasons:

      * The running workload has many empty tiles with no geometry to render.
        Empty tiles are common in shadow maps, for any screen region with no
        shadow casters.
      * The application consists of simple shaders but a high percentage of
        microtriangles. This combination causes the shader core to complete
        fragments faster than they are rasterized, so the quad buffer starts to
        drain.
      * The application consists of layers which stall at early ZS because of
        a dependency on an earlier fragment layer which is still in flight.
        Stalled layers prevent new fragments entering the quad buffer, so the
        quad buffer starts to drain.
    </LongDescription>
    <Equation>
      (MaliFragFPKActiveCy / MaliMainActiveCy) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragRastPrim</MachineName>
    <SourceName>FRAG_PRIM_RAST</SourceName>
    <StableID>211</StableID>
    <HumanName>Rasterized primitives</HumanName>
    <GroupName>Fragment Primitives</GroupName>
    <GroupHumanName>Rasterized primitives</GroupHumanName>
    <Units>primitives</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of primitives being rasterized.
    </ShortDescription>
    <LongDescription>
      This counter increments for every primitive entering the rasterization
      unit for each tile shaded. This increments per tile, which means that a
      single primitive that spans multiple tiles is counted multiple times. If
      you want to know the total number of primitives in the scene refer to the
      {{C::MaliGeomTotalPrim}} expression.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragRastPrim</MachineName>
    <SourceName>FRAG_PRIM_RAST</SourceName>
    <StableID>211</StableID>
    <HumanName>Rasterized primitives</HumanName>
    <GroupName>Fragment Primitives</GroupName>
    <GroupHumanName>Rasterized primitives</GroupHumanName>
    <Units>primitives</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of primitives being rasterized.
    </ShortDescription>
    <LongDescription>
      This counter increments for every primitive entering the rasterization
      unit for each tile shaded. This increments per tile, which means that a
      single primitive that spans multiple tiles is counted multiple times. If
      you want to know the total number of primitives in the scene refer to the
      {{C::MaliGeomTotalPrim}} expression.

      Input primitives might be rasterized up to two times per tile, depending
      on interaction with Fragment Prepass hidden surface removal.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragRastQd</MachineName>
    <SourceName>FRAG_QUADS_RAST</SourceName>
    <StableID>216</StableID>
    <HumanName>Rasterized fine quads</HumanName>
    <GroupName>Fragment Quads</GroupName>
    <GroupHumanName>Rasterized fine quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of fine quads generated by the rasterization phase.
    </ShortDescription>
    <LongDescription>
      This counter increments for every fine quad generated by the
      rasterization phase. A fine quad covers a 2x2 pixel screen region. The
      quads generated have at least some coverage based on the current sample
      pattern, but can subsequently be killed by early ZS testing or hidden
      surface removal before they are shaded.

      In this GPU, this counter has an erratum which causes an over count by 2x
      when using 8x MSAA, and by 4x when using 16x MSAA.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragRastQd</MachineName>
    <SourceName>FRAG_QUADS_RAST</SourceName>
    <StableID>216</StableID>
    <HumanName>Rasterized fine quads</HumanName>
    <GroupName>Fragment Quads</GroupName>
    <GroupHumanName>Rasterized fine quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of fine quads generated by the rasterization phase.
    </ShortDescription>
    <LongDescription>
      This counter increments for every fine quad generated by the
      rasterization phase. A fine quad covers a 2x2 pixel screen region. The
      quads generated have at least some coverage based on the current sample
      pattern, but can subsequently be killed by early ZS testing or hidden
      surface removal before they are shaded.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragRastQd</MachineName>
    <SourceName>FRAG_QUADS_RAST</SourceName>
    <StableID>216</StableID>
    <HumanName>Rasterized fine quads</HumanName>
    <GroupName>Fragment Quads</GroupName>
    <GroupHumanName>Rasterized fine quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of fine quads generated by the rasterization phase.
    </ShortDescription>
    <LongDescription>
      This counter increments for every fine quad generated by the
      rasterization phase. A fine quad covers a 2x2 pixel screen region. The
      quads generated have at least some coverage based on the current sample
      pattern, but can subsequently be killed by early ZS testing or hidden
      surface removal before they are shaded.

      Input quads might be rasterized up to two times, depending on interaction
      with Fragment Prepass hidden surface removal.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragRastCoarseQd</MachineName>
    <SourceName>FRAG_QUADS_COARSE</SourceName>
    <StableID>59</StableID>
    <HumanName>Rasterized coarse quads</HumanName>
    <GroupName>Fragment Quads</GroupName>
    <GroupHumanName>Rasterized coarse quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of coarse quads generated by the rasterization phase.
    </ShortDescription>
    <LongDescription>
      This counter increments for every coarse quad generated by the
      rasterization phase. A coarse quad covers a 2x2 block of fragment
      threads. The quads generated have at least some coverage based on the
      current sample pattern, but can subsequently be killed by early ZS
      testing or hidden surface removal before they are shaded.

      There are more coarse quads than fine quads if the application is using
      sample-rate shading when rendering to multi-sampled framebuffers.

      There are fewer coarse quads than fine quads if the application is using
      variable rate shading to reduce the fragment density and shade multiple
      pixels per fragment.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragRastCoarseQd</MachineName>
    <SourceName>FRAG_QUADS_COARSE</SourceName>
    <StableID>59</StableID>
    <HumanName>Rasterized coarse quads</HumanName>
    <GroupName>Fragment Quads</GroupName>
    <GroupHumanName>Rasterized coarse quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of coarse quads generated by the rasterization phase.
    </ShortDescription>
    <LongDescription>
      This counter increments for every coarse quad generated by the
      rasterization phase. A coarse quad covers a 2x2 block of fragment
      threads. The quads generated have at least some coverage based on the
      current sample pattern, but can subsequently be killed by early ZS
      testing or hidden surface removal before they are shaded.

      There are more coarse quads than fine quads if the application is using
      sample-rate shading when rendering to multi-sampled framebuffers.

      There are fewer coarse quads than fine quads if the application is using
      variable rate shading to reduce the fragment density and shade multiple
      pixels per fragment.

      Input quads might be rasterized up to two times, depending on interaction
      with Fragment Prepass hidden surface removal.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragShadRate</MachineName>
    <StableID>319</StableID>
    <HumanName>Fragment shading rate</HumanName>
    <GroupName>Fragment Shading Rate</GroupName>
    <GroupHumanName>Shading rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of coarse quads generated relative to fine quads
      rasterized.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of coarse quads generated relative
      to the number of fine quads that were rasterized. Coarse quads cover a
      2x2 fragment region. Fine quads cover a 2x2 pixel region.

      The fragment shading rate is lower than 100% if the application uses
      variable-rate shading to reduce shading rate.

      The fragment shading rate is higher than 100% if the application uses
      sample-rate shading to increase shading rate for a multi-sampled render.
    </LongDescription>
    <Equation>
      (MaliFragRastCoarseQd / MaliFragRastQd) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragRastPartQd</MachineName>
    <SourceName>FRAG_PARTIAL_QUADS_RAST</SourceName>
    <StableID>217</StableID>
    <HumanName>Partial rasterized fine quads</HumanName>
    <GroupName>Fragment Quads</GroupName>
    <GroupHumanName>Partial rasterized fine quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of rasterized fine quads created with partial coverage.
    </ShortDescription>
    <LongDescription>
      This counter increments for every rasterized fine quad containing pixels
      that have no active sample points. Partial coverage occurs when any of
      sample points span the edge of a triangle.

      Note that a non-partial fine quad can become partial before shading if
      some samples fail early ZS testing. This change is not visible in this
      counter.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragRastPartQd</MachineName>
    <SourceName>FRAG_PARTIAL_QUADS_RAST</SourceName>
    <StableID>217</StableID>
    <HumanName>Partial rasterized fine quads</HumanName>
    <GroupName>Fragment Quads</GroupName>
    <GroupHumanName>Partial rasterized fine quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of rasterized fine quads created with partial coverage.
    </ShortDescription>
    <LongDescription>
      This counter increments for every rasterized fine quad containing pixels
      that have no active sample points. Partial coverage occurs when any of
      sample points span the edge of a triangle.

      Note that a non-partial fine quad can become partial before shading if
      some samples fail early ZS testing. This change is not visible in this
      counter.

      Input quads might be rasterized up to two times, depending on interaction
      with Fragment Prepass hidden surface removal.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragRastPartQdRate</MachineName>
    <StableID>65577</StableID>
    <HumanName>Partial coverage percentage</HumanName>
    <GroupName>Fragment Workload Properties</GroupName>
    <GroupHumanName>Partial coverage rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of rasterized fine quads that contain samples with no
      coverage.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of fragment quads that contain
      samples with no coverage. A high percentage can indicate that the content
      has a high density of small triangles, which are expensive to process. To
      avoid this, use mesh level-of-detail algorithms to select simpler meshes
      as objects move further from the camera.
    </LongDescription>
    <Equation>
      (MaliFragRastPartQd / MaliFragRastQd) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragOpaqueQd</MachineName>
    <SourceName>QUAD_FPK_KILLER</SourceName>
    <StableID>225</StableID>
    <HumanName>Occluding quads</HumanName>
    <GroupName>Fragment FPK HSR Quads</GroupName>
    <GroupHumanName>Occluding quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of quads that are valid occluders for hidden surface removal.
    </ShortDescription>
    <LongDescription>
      This counter increments for every quad that is a valid occluder for
      hidden surface removal. To be a candidate occluder, a quad must be
      guaranteed to be opaque and have fulled resolved at early ZS.

      Draw calls that use blending, shader discard, alpha-to-coverage,
      programmable depth, or programmable tile buffer access can not be
      occluders.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragOpaqueQd</MachineName>
    <SourceName>QUAD_FPK_KILLER</SourceName>
    <StableID>225</StableID>
    <HumanName>Occluding quads</HumanName>
    <GroupName>Fragment FPK HSR Quads</GroupName>
    <GroupHumanName>Occluding quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of quads that are valid occluders for hidden surface removal.
    </ShortDescription>
    <LongDescription>
      This counter increments for every quad that is a valid occluder for
      hidden surface removal. To be a candidate occluder, a quad must be
      guaranteed to be opaque and have fulled resolved at early ZS.

      Draw calls that use blending, shader discard, alpha-to-coverage,
      programmable depth, or programmable tile buffer access can not be
      occluders.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragOpaqueQdRate</MachineName>
    <StableID>65665</StableID>
    <HumanName>Occluding quad percentage</HumanName>
    <GroupName>ZS Unit Test Rate</GroupName>
    <GroupHumanName>Occluding quad rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of quads that are valid occluders for hidden surface
      removal.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of rasterized quads that survive
      early depth and stencil testing that are valid hidden surface removal
      occluders.
    </LongDescription>
    <Equation>
      (MaliFragOpaqueQd / (MaliFragRastQd - MaliFragEZSKillQd)) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragTransparentQd</MachineName>
    <StableID>65588</StableID>
    <HumanName>Non-occluding quads</HumanName>
    <GroupName>Fragment FPK HSR Quads</GroupName>
    <GroupHumanName>Non-occluding quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of quads that are not eligible to be a hidden surface removal
      occluder.
    </ShortDescription>
    <LongDescription>
      This expression defines the number of quads that are not candidates for
      being hidden surface removal occluders. To be eligible, a quad must be
      guaranteed to be opaque and resolvable at early ZS.

      Draw calls that use blending, shader discard, alpha-to-coverage,
      programmable depth, or programmable tile buffer access can not be
      occluders. Aim to minimize the number of transparent quads by disabling
      blending when it is not required.
    </LongDescription>
    <Equation>
      MaliFragRastQd - MaliFragEZSKillQd - MaliFragOpaqueQd
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragShadedQd</MachineName>
    <StableID>65570</StableID>
    <HumanName>Shaded coarse quads</HumanName>
    <GroupName>Fragment Quads</GroupName>
    <GroupHumanName>Shaded coarse quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of 2x2 fragment quads that are fragment shaded.
    </ShortDescription>
    <LongDescription>
      This expression defines the number of 2x2 fragment quads that are spawned
      as executing threads in the shader core.
    </LongDescription>
    <Equation>
      MaliFragWarp
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragShadedQd</MachineName>
    <StableID>65570</StableID>
    <HumanName>Shaded coarse quads</HumanName>
    <GroupName>Fragment Quads</GroupName>
    <GroupHumanName>Shaded coarse quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of 2x2 fragment quads that are fragment shaded.
    </ShortDescription>
    <LongDescription>
      This expression defines the number of 2x2 fragment quads that are spawned
      as executing threads in the shader core.

      This expression is an approximation assuming that all spawned fragment
      warps contain a full set of quads. Comparing the total number of warps
      against the {{C::MaliCoreFullWarp}} counter can indicate how close this
      approximation is.
    </LongDescription>
    <Equation>
      (MaliFragWarp * MaliGPUWarpSize) / 4
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPartWarp</MachineName>
    <SourceName>FRAG_PARTIAL_WARPS</SourceName>
    <StableID>215</StableID>
    <HumanName>Partial fragment warps</HumanName>
    <GroupName>Shader Warps</GroupName>
    <GroupHumanName>Partial fragment warps</GroupHumanName>
    <Units>warps</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of fragment warps containing helper threads that do not
      correspond to a hit sample point.
    </ShortDescription>
    <LongDescription>
      This counter increments for every created fragment warp containing helper
      threads that do not correspond to a hit sample point. Partial coverage in
      a fragment quad occurs if any of its sample points span the edge of a
      triangle, or if one or more covered sample points fail an early ZS test.
      Partial coverage in a warp occurs if any quads it contains have partial
      coverage.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPartWarpRate</MachineName>
    <StableID>65576</StableID>
    <HumanName>Partial coverage percentage</HumanName>
    <GroupName>Fragment Workload Properties</GroupName>
    <GroupHumanName>Partial coverage rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of warps that contain samples with no coverage.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of warps quads that contain
      fragment samples with no coverage. A high percentage can indicate that
      the content has a high density of small triangles, which are expensive to
      process. To avoid this, use mesh level-of-detail algorithms to select
      simpler meshes as objects move further from the camera.
    </LongDescription>
    <Equation>
      (MaliFragPartWarp / MaliFragWarp) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragEZSTestQd</MachineName>
    <SourceName>FRAG_QUADS_EZS_TEST</SourceName>
    <StableID>218</StableID>
    <HumanName>Early ZS tested quads</HumanName>
    <GroupName>Fragment ZS Quads</GroupName>
    <GroupHumanName>Early ZS tested quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of quads that are undergoing early depth and stencil testing.
    </ShortDescription>
    <LongDescription>
      This counter increments for every quad undergoing early depth and stencil
      testing.

      For maximum performance, this number must be close to the total number of
      input quads. We want as many of the input quads as possible to be subject
      to early ZS testing because early ZS testing is significantly more
      efficient than late ZS testing, which only kills threads after they have
      been shaded.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragEZSTestRate</MachineName>
    <StableID>65578</StableID>
    <HumanName>Early ZS tested quad percentage</HumanName>
    <GroupName>ZS Unit Test Rate</GroupName>
    <GroupHumanName>Early ZS test rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of rasterized quads that were subjected to early depth and
      stencil testing.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of rasterized quads that were
      subjected to early depth and stencil testing.

      To achieve the best early test rates, enable depth testing, and avoid
      draw calls with modifiable coverage or draw calls with fragment shader
      programs that write to their depth value.
    </LongDescription>
    <Equation>
      (MaliFragEZSTestQd / MaliFragRastQd) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragEZSUpdateQd</MachineName>
    <SourceName>FRAG_QUADS_EZS_UPDATE</SourceName>
    <StableID>219</StableID>
    <HumanName>Early ZS updated quads</HumanName>
    <GroupName>Fragment ZS Quads</GroupName>
    <GroupHumanName>Early ZS updated quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of quads undergoing early depth and stencil testing, that are
      capable of updating the framebuffer.
    </ShortDescription>
    <LongDescription>
      This counter increments for every quad undergoing early depth and stencil
      testing that can update the framebuffer. Quads that have a depth value
      that depends on shader behavior, or those that have indeterminate
      coverage because of use of alpha-to-coverage or discard statements in the
      shader, might be early ZS tested but can not do an early ZS update.

      For maximum performance, this number must be close to the total number of
      input quads. Aim to maximize the number of quads that are capable of
      doing an early ZS update.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragEZSUpdateRate</MachineName>
    <StableID>65594</StableID>
    <HumanName>Early ZS updated quad percentage</HumanName>
    <GroupName>ZS Unit Test Rate</GroupName>
    <GroupHumanName>Early ZS update rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of rasterized quads that update the framebuffer during
      early depth and stencil testing.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of rasterized quads that update
      the framebuffer during early depth and stencil testing.

      To achieve the best early test rates, enable depth testing, and avoid
      draw calls with modifiable coverage or draw calls with fragment shader
      programs that write to their depth value.
    </LongDescription>
    <Equation>
      (MaliFragEZSUpdateQd / MaliFragRastQd) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragEZSKillQd</MachineName>
    <SourceName>FRAG_QUADS_EZS_KILL</SourceName>
    <StableID>220</StableID>
    <HumanName>Early ZS killed quads</HumanName>
    <GroupName>Fragment ZS Quads</GroupName>
    <GroupHumanName>Early ZS killed quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of quads killed by early depth and stencil testing.
    </ShortDescription>
    <LongDescription>
      This counter increments for every quad killed by early depth and stencil
      testing.

      Quads killed at this stage are killed before shading, so a high
      percentage here is not generally a performance problem. However, it can
      indicate an opportunity to use software culling techniques such as portal
      culling to avoid sending occluded geometry to the GPU.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPrepassEZSUpdateQd</MachineName>
    <SourceName>FRAG_QUADS_HSR_BUF_EZS_UPDATE</SourceName>
    <StableID>388</StableID>
    <HumanName>Fragment prepass early ZS updated quads</HumanName>
    <GroupName>Fragment ZS Quads</GroupName>
    <GroupHumanName>Prepass early ZS updated quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of quads that update the fragment prepass using early ZS.
    </ShortDescription>
    <LongDescription>
      This counter increments for every quad that updates the fragment prepass
      during early depth and stencil testing.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPrepassTestQd</MachineName>
    <SourceName>FRAG_QUADS_HSR_BUF_TEST</SourceName>
    <StableID>389</StableID>
    <HumanName>Fragment prepass tested quads</HumanName>
    <GroupName>Fragment ZS Quads</GroupName>
    <GroupHumanName>Prepass tested quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of quads that are tested by the fragment prepass.
    </ShortDescription>
    <LongDescription>
      This counter increments for every quad that is tested by the fragment
      prepass hidden surface removal.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPrepassKillQd</MachineName>
    <SourceName>FRAG_QUADS_HSR_BUF_KILLED</SourceName>
    <StableID>390</StableID>
    <HumanName>Fragment prepass killed quads</HumanName>
    <GroupName>Fragment ZS Quads</GroupName>
    <GroupHumanName>Prepass killed quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of quads that are killed by the fragment prepass.
    </ShortDescription>
    <LongDescription>
      This counter increments for every quad that is killed by the fragment
      prepass hidden surface removal.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPrepassKillRate</MachineName>
    <StableID>444</StableID>
    <HumanName>Fragment prepass killed quad percentage</HumanName>
    <GroupName>Fragment Prepass Properties</GroupName>
    <GroupHumanName>Culled quad rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of tested quads that are killed by the fragment prepass.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of rasterized quads that are
      killed by the fragment prepass hidden surface removal scheme.

      Quads killed at this stage are killed before shading, so a high
      percentage here is not generally a performance problem. However,
      performance could be improved if occluded objects were removed using
      software culling techniques.
    </LongDescription>
    <Equation>
      (MaliFragPrepassKillQd / MaliFragPrepassTestQd) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragEZSKillRate</MachineName>
    <StableID>65580</StableID>
    <HumanName>Early ZS killed quad percentage</HumanName>
    <GroupName>ZS Unit Test Rate</GroupName>
    <GroupHumanName>Early ZS kill rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of rasterized quads that are killed by early depth and
      stencil testing.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of rasterized quads that are
      killed by early depth and stencil testing.

      Quads killed at this stage are killed before shading, so a high
      percentage here is not generally a performance problem. However, it can
      indicate an opportunity to use software culling techniques such as portal
      culling to avoid sending occluded geometry to the GPU.
    </LongDescription>
    <Equation>
      (MaliFragEZSKillQd / MaliFragRastQd) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragFPKKillQd</MachineName>
    <StableID>65581</StableID>
    <HumanName>FPK HSR killed quads</HumanName>
    <GroupName>Fragment ZS Quads</GroupName>
    <GroupHumanName>FPK HSR killed quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of quads that are killed by hidden surface removal.
    </ShortDescription>
    <LongDescription>
      This expression defines the number of quads that are killed by the
      Forward Pixel Kill (FPK) hidden surface removal scheme.

      It is good practice to sort opaque geometry so that the geometry is
      rendered front-to-back with depth testing enabled. This enables more
      geometry to be killed by early ZS testing instead of FPK, which removes
      the work earlier in the pipeline.

      Quads killed at this stage are killed before shading, so a high
      percentage here is not generally a performance problem. However, it can
      indicate an opportunity to use software culling techniques such as portal
      culling to avoid sending occluded geometry to the GPU.
    </LongDescription>
    <Equation>
      MaliFragRastQd - MaliFragEZSKillQd - MaliFragShadedQd
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragFPKKillRate</MachineName>
    <StableID>65582</StableID>
    <HumanName>FPK HSR killed quad percentage</HumanName>
    <GroupName>ZS Unit Test Rate</GroupName>
    <GroupHumanName>FPK HSR kill rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of rasterized quads that are killed by hidden surface
      removal.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of rasterized quads that are
      killed by the Forward Pixel Kill (FPK) hidden surface removal scheme.

      Quads killed at this stage are killed before shading, so a high
      percentage here is not generally a performance problem. However, it can
      indicate an opportunity to use software culling techniques such as portal
      culling to avoid sending occluded geometry to the GPU.
    </LongDescription>
    <Equation>
      (MaliFragFPKKillQd / MaliFragRastQd) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragLZSTestQd</MachineName>
    <SourceName>FRAG_LZS_TEST</SourceName>
    <StableID>221</StableID>
    <HumanName>Late ZS tested quads</HumanName>
    <GroupName>Fragment ZS Quads</GroupName>
    <GroupHumanName>Late ZS tested quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of quads undergoing late depth and stencil testing.
    </ShortDescription>
    <LongDescription>
      This counter increments for every quad undergoing late depth and stencil
      testing.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragLZSTestRate</MachineName>
    <StableID>65583</StableID>
    <HumanName>Late ZS tested quad percentage</HumanName>
    <GroupName>ZS Unit Test Rate</GroupName>
    <GroupHumanName>Late ZS test rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of rasterized quads that are tested by late depth and
      stencil testing.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of rasterized quads that are
      tested by late depth and stencil testing.

      A high percentage of fragments performing a late ZS update can cause slow
      performance, even if fragments are not killed. Younger fragments cannot
      complete early ZS until all older fragments at the same coordinate have
      completed their late ZS operations, which can cause stalls.

      You achieve the lowest late test rates by avoiding draw calls with
      modifiable coverage,, or with shader programs that write to their depth
      value or that have memory-visible side-effects
    </LongDescription>
    <Equation>
      (MaliFragLZSTestQd / MaliFragRastQd) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragLZSTestRate</MachineName>
    <StableID>65583</StableID>
    <HumanName>Late ZS tested quad percentage</HumanName>
    <GroupName>ZS Unit Test Rate</GroupName>
    <GroupHumanName>Late ZS test rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of rasterized quads that are tested by late depth and
      stencil testing.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of rasterized quads that are
      tested by late depth and stencil testing.

      A high percentage of fragments performing a late ZS update can cause slow
      performance, even if fragments are not killed. Younger fragments cannot
      complete early ZS until all older fragments at the same coordinate have
      completed their late ZS operations, which can cause stalls.

      You achieve the lowest late test rates by avoiding draw calls with
      modifiable coverage, or with shader programs that write to their depth
      value or that have memory-visible side-effects
    </LongDescription>
    <Equation>
      (MaliFragLZSTestQd / (4 * MaliFragWarp)) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragLZSKillQd</MachineName>
    <SourceName>FRAG_LZS_KILL</SourceName>
    <StableID>222</StableID>
    <HumanName>Late ZS killed quads</HumanName>
    <GroupName>Fragment ZS Quads</GroupName>
    <GroupHumanName>Late ZS killed quads</GroupHumanName>
    <Units>quads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of quads killed by late depth and stencil testing.
    </ShortDescription>
    <LongDescription>
      This counter increments for every quad killed by late depth and stencil
      testing.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragLZSKillRate</MachineName>
    <StableID>65584</StableID>
    <HumanName>Late ZS killed quad percentage</HumanName>
    <GroupName>ZS Unit Test Rate</GroupName>
    <GroupHumanName>Late ZS kill rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of rasterized quads that are killed by late depth and
      stencil testing.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of rasterized quads that are
      killed by late depth and stencil testing. Quads killed by late ZS testing
      run at least some of their fragment program before being killed.

      A high percentage of fragments being killed by ZS can be a source of
      redundant processing. You achieve the lowest late test rates by avoiding
      draw calls with modifiable coverage, or with shader programs that write
      to their depth value or that have memory-visible side-effects.

      The driver uses a late ZS update and kill sequence to preload a depth or
      stencil attachment at the start of a render pass, which is needed if the
      render pass does not start from a cleared value. Always start from a
      cleared value whenever possible.
    </LongDescription>
    <Equation>
      (MaliFragLZSKillQd / MaliFragRastQd) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragLZSKillRate</MachineName>
    <StableID>65584</StableID>
    <HumanName>Late ZS killed quad percentage</HumanName>
    <GroupName>ZS Unit Test Rate</GroupName>
    <GroupHumanName>Late ZS kill rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of rasterized quads that are killed by late depth and
      stencil testing.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of rasterized quads that are
      killed by late depth and stencil testing. Quads killed by late ZS testing
      run at least some of their fragment program before being killed. A
      significant number of quads being killed at late ZS testing indicates a
      potential overhead. Aim to minimize the number of quads using and being
      killed by late ZS testing.

      Shaders with mutable coverage, mutable depth, or side-effects on shared
      resources in memory, use late ZS testing.

      The driver also generates late ZS updates to preload a depth or stencil
      attachment at the start of a render pass, which is needed if the render
      pass does not start from a cleared depth value. These fragments show as a
      late ZS kill, as no shader is needed after the depth or stencil value has
      been set.
    </LongDescription>
    <Equation>
      (MaliFragLZSKillQd / (4 * MaliFragWarp)) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragOverdraw</MachineName>
    <StableID>65585</StableID>
    <HumanName>Fragments per pixel</HumanName>
    <GroupName>Overdraw</GroupName>
    <GroupHumanName>Fragments/pixel</GroupHumanName>
    <Units>threads</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The number of fragments shaded per output pixel.
    </ShortDescription>
    <LongDescription>
      This expression computes the number of fragments shaded per output pixel.

      GPU processing cost per pixel accumulates with the layer count. High
      overdraw can build up to a significant processing cost, especially when
      rendering to a high-resolution framebuffer. Minimize overdraw by
      rendering opaque objects front-to-back and minimizing use of blended
      transparent layers.
    </LongDescription>
    <Equation>
      MaliFragThread / MaliGPUPix
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragTile</MachineName>
    <SourceName>FRAG_PTILES</SourceName>
    <StableID>223</StableID>
    <HumanName>Tiles</HumanName>
    <GroupName>Fragment Tiles</GroupName>
    <GroupHumanName>Tiles</GroupHumanName>
    <Units>tiles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of tiles processed by the shader core.
    </ShortDescription>
    <LongDescription>
      This counter increments for every tile processed by the shader core. Note
      that tiles are normally {{C::MaliGPUTileSize.equation}} x
      {{C::MaliGPUTileSize.equation}} pixels but can vary depending on
      per-pixel storage requirements and the tile buffer size of the current
      GPU.

      This GPU supports full size tiles when using up to and including
      {{C::MaliGPUMaxPixelStorage.equation}} bits per pixel of color storage.
      Pixel storage requirements depend on the number of color attachments,
      their data format, and the number of multi-sampling samples per pixel.

      The most accurate way to get the total pixel count rendered by the
      application is to use the {{C::MaliFragQueueTask}} counter, because it
      always counts {{C::MaliFragQueueTaskSize.equation}} x
      {{C::MaliFragQueueTaskSize.equation}} pixel regions.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragTile</MachineName>
    <SourceName>FRAG_PTILES</SourceName>
    <StableID>223</StableID>
    <HumanName>Tiles</HumanName>
    <GroupName>Fragment Tiles</GroupName>
    <GroupHumanName>Tiles</GroupHumanName>
    <Units>tiles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of tiles processed by the shader core.
    </ShortDescription>
    <LongDescription>
      This counter increments for every tile processed by the shader core. Note
      that tiles are normally {{C::MaliGPUTileSize.equation}} x
      {{C::MaliGPUTileSize.equation}} pixels but can vary depending on
      per-pixel storage requirements and the tile buffer size of the current
      GPU.

      This GPU supports full size tiles when using up to and including
      {{C::MaliGPUMaxPixelStorage.equation}} bits per pixel of color storage.
      Pixel storage requirements depend on the number of color attachments,
      their data format, and the number of multi-sampling samples per pixel.

      The most accurate way to get the total pixel count rendered by the
      application is to use the {{C::MaliFragQueueTask}} counter, because it
      always counts {{C::MaliFragQueueTaskSize.equation}} x
      {{C::MaliFragQueueTaskSize.equation}} pixel regions.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragTile</MachineName>
    <SourceName>FRAG_PTILES</SourceName>
    <StableID>223</StableID>
    <HumanName>Tiles</HumanName>
    <GroupName>Fragment Tiles</GroupName>
    <GroupHumanName>Tiles</GroupHumanName>
    <Units>tiles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of tiles processed by the shader core.
    </ShortDescription>
    <LongDescription>
      This counter increments for every tile processed by the shader core. Note
      that tiles are normally {{C::MaliGPUTileSize.equation}} x
      {{C::MaliGPUTileSize.equation}} pixels but can vary depending on
      per-pixel storage requirements and the tile buffer size of the current
      GPU.

      This GPU supports full size tiles when using up to and including
      {{C::MaliGPUMaxPixelStorage.equation}} bits per pixel of color storage.
      Pixel storage requirements depend on the number of color attachments,
      their data format, and the number of multi-sampling samples per pixel.

      The most accurate way to get the total pixel count rendered by the
      application is to use the {{C::MaliMainQueueTask}} counter, because it
      always counts {{C::MaliMainQueueTaskSize.equation}} x
      {{C::MaliMainQueueTaskSize.equation}} pixel regions.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragTileKill</MachineName>
    <SourceName>FRAG_TRANS_ELIM</SourceName>
    <StableID>224</StableID>
    <HumanName>Killed unchanged tiles</HumanName>
    <GroupName>Fragment Tiles</GroupName>
    <GroupHumanName>Killed unchanged tiles</GroupHumanName>
    <Units>tiles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of tiles killed by transaction elimination.
    </ShortDescription>
    <LongDescription>
      This counter increments for every 16x16 pixel tile or tile sub-region
      killed by a transaction elimination CRC check, where the data is the same
      as the content already stored in memory.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragTileKillRate</MachineName>
    <StableID>65586</StableID>
    <HumanName>Unchanged tile kill percentage</HumanName>
    <GroupName>Fragment Workload Properties</GroupName>
    <GroupHumanName>Unchanged tile kill rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of tiles that are killed by transaction elimination.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of tiles that are killed by the
      transaction elimination CRC check because the content of a tile matches
      the content already stored in memory.

      A high percentage of tile writes being killed indicates that a
      significant part of the framebuffer is static from frame to frame.
      Consider using scissor rectangles to reduce the area that is redrawn. To
      help manage the partial frame updates for window surfaces consider using
      the EGL extensions such as:

      * EGL_KHR_partial_update
      * EGL_EXT_swap_buffers_with_damage
    </LongDescription>
    <Equation>
      (MaliFragTileKill / MaliFragTile) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G31</GPU>
      <GPU>Mali-G51</GPU>
      <GPU>Mali-G52</GPU>
      <GPU>Mali-G71</GPU>
      <GPU>Mali-G72</GPU>
      <GPU>Mali-G76</GPU>
      <GPU>Mali-G77</GPU>
      <GPU>Mali-G78</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragTileKillRate</MachineName>
    <StableID>65586</StableID>
    <HumanName>Unchanged tile kill percentage</HumanName>
    <GroupName>Fragment Workload Properties</GroupName>
    <GroupHumanName>Unchanged tile kill rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of tiles that are killed by transaction elimination.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of tiles that are killed by the
      transaction elimination CRC check because the content of a tile matches
      the content already stored in memory.

      A high percentage of tile writes being killed indicates that a
      significant part of the framebuffer is static from frame to frame.
      Consider using scissor rectangles to reduce the area that is redrawn. To
      help manage the partial frame updates for window surfaces consider using
      the EGL extensions such as:

      * EGL_KHR_partial_update
      * EGL_EXT_swap_buffers_with_damage
    </LongDescription>
    <Equation>
      (MaliFragTileKill / (4 * MaliFragTile)) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G710</GPU>
      <GPU>Mali-G715</GPU>
      <GPU>Mali-G720</GPU>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragMainPassStallCy</MachineName>
    <SourceName>FRAG_MAIN_PASS_STALLED_BY_PRE_PASS</SourceName>
    <StableID>383</StableID>
    <HumanName>Fragment main pass stall cycles</HumanName>
    <GroupName>Shader Core Stall Cycles</GroupName>
    <GroupHumanName>Fragment main pass stalls</GroupHumanName>
    <Units>cycles</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of cycles when the fragment main pass is stalled waiting for
      prepass results.
    </ShortDescription>
    <LongDescription>
      This counter increments for every clock cycle when a fragment main pass
      cannot start because the fragment main pass is waiting for a prepass
      result.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragMainPassStallRate</MachineName>
    <StableID>463</StableID>
    <HumanName>Fragment main pass stall percentage</HumanName>
    <GroupName>Fragment Prepass Properties</GroupName>
    <GroupHumanName>Main pass stall rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of cycles when the fragment main pass is stalled by the
      fragment prepass.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of cycles when the fragment main
      pass is stalled waiting for the fragment prepass to complete.

      A high percentage here indicates that the fragment prepass is a
      bottleneck. This can be caused by a high amount of geometry or a high
      number of primitives needing prepass shading.
    </LongDescription>
    <Equation>
      (MaliFragMainPassStallCy / MaliMainActiveCy) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragInputPrim</MachineName>
    <StableID>464</StableID>
    <HumanName>Input fragment primitives</HumanName>
    <GroupName>Fragment Primitives</GroupName>
    <GroupHumanName>Input primitives</GroupHumanName>
    <Units>primitives</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of unique primitives loaded by the fragment front-end.
    </ShortDescription>
    <LongDescription>
      This expression defines the number of unique primitives loaded by the
      fragment front-end for each tile.
    </LongDescription>
    <Equation>
      (MaliFragPrim + MaliFragPrepassCullPrim) - MaliFragPrepassPrim
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPrim</MachineName>
    <SourceName>FRAG_PRIMITIVES_OUT</SourceName>
    <StableID>384</StableID>
    <HumanName>Loaded fragment primitives</HumanName>
    <GroupName>Fragment Primitives</GroupName>
    <GroupHumanName>Loaded primitives</GroupHumanName>
    <Units>primitives</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of primitives loaded by the fragment front-end.
    </ShortDescription>
    <LongDescription>
      This counter increments for every primitive loaded by the fragment
      front-end.

      Primitives might be loaded up to two times per tile, depending on
      interaction with Fragment Prepass hidden surface removal.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPrepassPrim</MachineName>
    <SourceName>FRAG_PRIMITIVES_OUT_PRE_PASS</SourceName>
    <StableID>385</StableID>
    <HumanName>Loaded fragment prepass primitives</HumanName>
    <GroupName>Fragment Primitives</GroupName>
    <GroupHumanName>Loaded prepass primitives</GroupHumanName>
    <Units>primitives</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of primitives loaded by the fragment front-end for the
      fragment prepass.
    </ShortDescription>
    <LongDescription>
      This counter increments for every primitive loaded by the fragment
      front-end that are used in the fragment prepass.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPrepassPrimRate</MachineName>
    <StableID>465</StableID>
    <HumanName>Fragment prepass primitive percentage</HumanName>
    <GroupName>Fragment Prepass Properties</GroupName>
    <GroupHumanName>Prepass primitive rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Higher better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of primitives processed by fragment prepass hidden surface
      removal.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of primitives that are processed
      by fragment prepass hidden surface removal.

      A low percentage indicates that many primitives are using a render state
      that is ineligible for the prepass, or a primitive used a render state
      that caused the prepass to terminate early. Review application draw call
      settings to ensure compatibility with the fragment prepass requirements.
    </LongDescription>
    <Equation>
      (MaliFragPrepassPrim / MaliFragInputPrim) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPrepassCullPrim</MachineName>
    <SourceName>FRAG_PRIMITIVES_HSR_CULLED</SourceName>
    <StableID>386</StableID>
    <HumanName>Fragment prepass culled primitives</HumanName>
    <GroupName>Fragment Primitives</GroupName>
    <GroupHumanName>Prepass culled primitives</GroupHumanName>
    <Units>primitives</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of primitives culled by the fragment prepass.
    </ShortDescription>
    <LongDescription>
      This counter increments for every primitive loaded by the fragment
      front-end that is optimized out by the fragment prepass hidden surface
      removal.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPrepassCullPrimRate</MachineName>
    <StableID>466</StableID>
    <HumanName>Fragment prepass primitive culling percentage</HumanName>
    <GroupName>Fragment Prepass Properties</GroupName>
    <GroupHumanName>Culled primitive rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of primitives culled by the fragment prepass.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of primitives in the main pass
      that are culled by the fragment prepass.

      A high percentage indicates that a lot of geometry is being occluded by
      opaque primitives. If objects are completely occluded by geometry closer
      to the camera, consider applying higher level culling algorithms that can
      completely optimize away the occluded geometry.
    </LongDescription>
    <Equation>
      (MaliFragPrepassCullPrim / MaliFragInputPrim) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPrepassSkippedPrim</MachineName>
    <SourceName>FRAG_PRIMITIVES_HSR_DISABLED</SourceName>
    <StableID>387</StableID>
    <HumanName>Fragment prepass skipped primitives</HumanName>
    <GroupName>Fragment Primitives</GroupName>
    <GroupHumanName>Prepass skipped primitives</GroupHumanName>
    <Units>primitives</Units>
    <Trend>Lower better</Trend>
    <Visibility>Advanced application</Visibility>
    <ShortDescription>
      The number of primitives that are skipped by the fragment prepass.
    </ShortDescription>
    <LongDescription>
      This counter increments for every primitive that is not tested by
      fragment prepass hidden surface removal because an earlier primitive was
      incompatible and terminated the prepass.
    </LongDescription>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
  <!-- ==================================================================== -->
  <CounterInfo>
    <MachineName>MaliFragPrepassSkipPrimRate</MachineName>
    <StableID>467</StableID>
    <HumanName>Fragment prepass skipped primitive percentage</HumanName>
    <GroupName>Fragment Prepass Properties</GroupName>
    <GroupHumanName>Skipped primitive rate</GroupHumanName>
    <Units>percent</Units>
    <Trend>Lower better</Trend>
    <Visibility>Novice</Visibility>
    <ShortDescription>
      The percentage of primitives that are skipped by the fragment prepass.
    </ShortDescription>
    <LongDescription>
      This expression defines the percentage of primitives that are not be
      tested by fragment prepass hidden surface removal.

      A high percentage indicates that many primitives are submitted after a
      primitive that used a render state that caused the prepass to terminate.
      Review application draw call settings to ensure compatibility with the
      fragment prepass requirements. If an incompatible render state must be
      used, move all draw calls using that state after all prepass compatible
      draw calls.
    </LongDescription>
    <Equation>
      (MaliFragPrepassSkippedPrim / MaliFragInputPrim) * 100
    </Equation>
    <SupportedGPUs>
      <GPU>Mali-G725</GPU>
      <GPU>Mali G1</GPU>
    </SupportedGPUs>
  </CounterInfo>
</CounterInfoList>
