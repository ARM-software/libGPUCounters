#
# Copyright (c) 2025 Arm Limited.
#
# SPDX-License-Identifier: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
'''
This module contains a data structure hierarchy that represents the hardware
counter memory layout for a single Arm GPU.

Major classes
=============

A HardwareLayout contains the overall definition for a single GPU. The memory
layout is specified as a set of typed counter blocks, each containing a sparse
array of performance counters. Each block type is generated by a different
hardware source in the GPU.

A HardwareBlockLayout defines the memory layout of a single GPU counter block
for the GPU. Counter blocks contain either 64 or 128 counter slots, depending
on product and block type, with counters sparsely laid out inside each block.
Hardware blocks have banked counter selection, allowing different sets of
counters to be selected at runtime by selecting a different bank. Only bank
zero, the primary bank, is accessible and documented for production devices.

A HardwareCounterLayout defines the name and location of a single GPU counter
in a block. It also contains any supplemental encoding information sourced from
the GPU architecture, such as scaling shifts needed to reconstruct the
counter value.

Source data
===========

XML database source files are ./database/hardwarelayout/*.xml.

The XML database describing each GPU is compiled automatically from the GPU
architecture specification, but may be manually edited before publication.
'''

from __future__ import annotations

import enum
import pathlib
from typing import Iterator, NamedTuple, Optional
import xml.dom.minidom as md
import xml.etree.ElementTree as et

from .. import xmlutils as xu


class HardwareLookup(NamedTuple):
    '''
    Utility class used to store compact lookups.
    '''
    block: HardwareBlockLayout
    counter: HardwareCounterLayout


class HardwareBlockType(enum.Enum):
    '''
    Hardware counter block types that can be emitted.
    '''
    GPU_FRONTEND = 1
    SHADER_CORE = 2
    MEMORY_SYSTEM = 3
    TILER = 4

    @classmethod
    def from_xml(cls, value: str) -> HardwareBlockType:
        '''
        Convert an XML string into an enum value.

        Args:
            value: The XML string value.

        Returns:
            The enum value.
        '''
        if value == 'GPU Front-end':
            return cls.GPU_FRONTEND

        if value == 'Shader Core':
            return cls.SHADER_CORE

        if value == 'Memory System':
            return cls.MEMORY_SYSTEM

        if value == 'Tiler':
            return cls.TILER

        assert False, f'Unknown enumeration string {value}'

    def to_xml(self) -> str:
        '''
        Serialize to XML.

        Returns:
            The XML string value.
        '''
        if self == self.GPU_FRONTEND:
            return 'GPU Front-end'

        if self == self.SHADER_CORE:
            return 'Shader Core'

        if self == self.MEMORY_SYSTEM:
            return 'Memory System'

        if self == self.TILER:
            return 'Tiler'

        assert False, f'Unknown enumeration value {self.value}'

    def __str__(self) -> str:
        return self.to_xml()


class HardwareCounterLayout():
    '''
    Configuration of a single hardware counter for a single GPU.

    Attributes:
        index: Counter index in the block.
        name: Counter hardware name in the specification.
        shift: Shift-left modifier to apply to value on reconstruction.
    '''

    def __init__(self, index: int, name: str, shift: int):
        '''
        Construct a new counter.

        Args:
            index: The counter index in the block.
            name: The counter hardware name in the specification.
            shift: The shift left scale applied when reconstructing.
        '''
        self.index = index
        self.name = name
        self.shift = shift

    def to_xml(self, parent: et.Element[str]) -> None:
        '''
        Serialize to XML.

        Args:
            parent: Parent XML element to add this node to.
        '''
        node = et.SubElement(parent, 'Counter')

        node.set('name', self.name)

        node.set('index', f'{self.index}')

        if self.shift:
            node.set('shift', f'{self.shift}')

    def __eq__(self, other) -> bool:
        if not isinstance(other, self.__class__):
            return False

        self_same = True
        self_same &= self.index == other.index
        self_same &= self.name == other.name
        self_same &= self.shift == other.shift

        return self_same

    def __ne__(self, other) -> bool:
        return not self.__eq__(other)

    @classmethod
    def from_xml(cls, node: et.Element[str]) -> HardwareCounterLayout:
        '''
        Factory method to create a new instance from an XML database.

        Args:
            node: Database XML entry.

        Returns:
            Constructed counter layout.
        '''
        # Check this is the correct type of XML node
        assert node.tag == 'Counter'

        index = int(node.attrib['index'])
        name = node.attrib['name']
        shift = int(node.get('shift', 0))

        return cls(index, name, shift)


class HardwareBlockLayout(list[HardwareCounterLayout]):
    '''
    Configuration of a single hardware counter block for a single GPU.

    Attributes:
        btype: Hardware counter block type.
        bank: Counter bank index.
        size: Maximum number of counters in the block.
    '''

    def __init__(self, btype: HardwareBlockType, bank: int, size: int):
        '''
        Create a new counter block.

        Args:
            btype: Hardware counter block type.
            bank: Counter bank index.
            size: Maximum number of counters in the block.
        '''
        super().__init__()
        self.btype = btype
        self.bank = bank
        self.size = size

    def add_counter(self, counter: HardwareCounterLayout) -> None:
        '''
        Add a new counter to the block.

        Args:
            counter: New counter to add.
        '''
        assert counter.index < self.size
        self.append(counter)

    def to_xml(self, parent: et.Element[str]) -> None:
        '''
        Serialize to XML.

        Args:
            parent: Parent XML element to add this node to.
        '''
        node = et.SubElement(parent, 'CounterBlock')
        node.set('type', self.btype.to_xml())
        node.set('bank', f'{self.bank}')
        node.set('size', f'{self.size}')

        for counter in self:
            counter.to_xml(node)

    @classmethod
    def from_xml(cls, node: et.Element[str]) -> HardwareBlockLayout:
        '''
        Factory method to create a new instance from an XML database.

        Args:
            node: Database XML entry.

        Returns:
            Constructed block object.
        '''
        # Check this is the correct type of XML node
        assert node.tag == 'CounterBlock'

        btype = HardwareBlockType.from_xml(node.attrib['type'])
        bank = int(node.attrib['bank'])
        size = int(node.attrib['size'])

        block_layout = cls(btype, bank, size)

        for child in node:
            counter = HardwareCounterLayout.from_xml(child)
            block_layout.add_counter(counter)

        return block_layout

    def __eq__(self, other) -> bool:
        if not isinstance(other, self.__class__):
            return False

        self_same = True
        self_same &= self.btype == other.btype
        self_same &= self.bank == other.bank
        self_same &= self.size == other.size
        self_same &= len(self) == len(other)

        if not self_same:
            return False

        child_same = all(x == y for x, y in zip(self, other))
        return child_same

    def __ne__(self, other) -> bool:
        return not self.__eq__(other)


class HardwareLayout(list[HardwareBlockLayout]):
    '''
    Configuration of hardware counter memory layout for a single GPU.

    Attributes:
        source_file: The source file the data was loaded from.
        name: The name of the GPU, which will be the public name if the product
            is announced, or the codename if not.
        source: The specification tag used when creating the database.
        generated: True if auto-generated, False if manually edited.
        copyright: Copyright message we will emit when writing to file.
        lookup: Dictionary for fast lookup by hardware name.
    '''

    def __init__(self, source_file: str, name: str, source: str,
                 copyright_msg: str, generated: bool = False):
        '''
        Create a hardware counter memory layout for a single GPU.

        Args:
            source_file: The source file the data was loaded from.
            name: The name of the GPU.
            source: The source of the data.
            copyright_msg: Copyright message we will emit when writing to file.
            generated: True if auto-generated, False otherwise.
        '''
        super().__init__()
        self.source_file = source_file
        self.name = name
        self.source = source
        self.generated = generated
        self.copyright = copyright_msg

        self.lookup: dict[str, HardwareLookup] = {}

    def get_counter_by_name(self, name: str) -> Optional[HardwareLookup]:
        '''
        Get the block and counter layout of a specific counter.

        Args:
            name: The architecture name to lookup.

        Returns:
            Block and counter layouts if found, None otherwise.
        '''
        return self.lookup.get(name, None)

    def iter_counters(self, primary=True) -> Iterator[HardwareCounterLayout]:
        '''
        Iterate all counters in the view.

        Args:
            primary: Only iterate primary block counters if True.

        Yields:
            Counters in block-order and block-index order.
        '''
        for block in self:
            if primary and block.bank != 0:
                continue

            yield from block

    def _add_block(self, block: HardwareBlockLayout) -> None:
        '''
        Add a new counter block to the set.

        Args:
            block: The new counter block to add.
        '''
        self.append(block)

    def to_xml_str(self, pretty_print: bool = False) -> str:
        '''
        Serialize to XML.

        Args:
            pretty_print: True to pretty print, False otherwise.

        Returns:
           The XML encoded data string.
        '''
        node = et.Element('HardwareLayout')
        node.set('gpu', self.name)
        node.set('generated', f'{int(self.generated)}')
        node.set('source', self.source)

        for block in self:
            block.to_xml(node)

        document = et.tostring(node, encoding='unicode')

        if pretty_print:
            xml_md = md.parseString(document)
            document = xml_md.toprettyxml(indent='  ')

            document = xu.add_copyright_to_xml_str(document, self.copyright)

        return document

    def __eq__(self, other) -> bool:
        if not isinstance(other, self.__class__):
            return False

        self_same = True
        self_same &= self.name == other.name
        self_same &= self.source == other.source
        self_same &= self.generated == other.generated
        self_same &= len(self) == len(other)

        if not self_same:
            return False

        child_same = all(x == y for x, y in zip(self, other))
        return child_same

    def __ne__(self, other) -> bool:
        return not self.__eq__(other)

    @classmethod
    def from_xml_str(cls, document: str, source_file: str) -> HardwareLayout:
        '''
        Factory method to create a new instance from an XML database.

        Args:
            document: The XML document to parse.
            source_file: Path of the source file on disk.

        Returns:
            The data structure after parsing from XML.
        '''
        node = et.fromstring(document)

        # Check this is the correct type of XML node
        assert node.tag == 'HardwareLayout'

        # Get copyright message so we can emit it on file write
        copyright_msg = xu.get_copyright_from_xml_str(document)

        name = node.attrib['gpu']
        source = node.attrib['source']
        generated = bool(int(node.attrib['generated']))

        layout = cls(source_file, name, source, copyright_msg, generated)

        for child in node:
            block_layout = HardwareBlockLayout.from_xml(child)
            layout._add_block(block_layout)

        for block in layout:
            for counter in block:
                layout.lookup[counter.name] = HardwareLookup(block, counter)

        return layout


class HardwareLayouts:
    '''
    Set of all hardware layouts from disk.

    Attributes:
        layouts: Map of layouts found on disk.
    '''

    def __init__(self):
        '''
        Create a hardware counter memory layout for a single GPU.
        '''
        self.layouts: dict[str, HardwareLayout] = {}

    def get_gpu(self, key: str) -> HardwareLayout:
        '''
        Return a specific product's hardware layout.

        Args:
            key: The canonical database GPU name.

        Returns:
            The hardware layout.

        Raises:
            KeyError if GPU not found.
        '''
        layout = self.layouts.get(key, None)
        if not layout:
            raise KeyError(f'Unknown GPU {key}')

        return layout

    def to_xml_str(self, pretty_print: bool = False) -> dict[str, str]:
        '''
        Serialize to XML.

        Args:
            pretty_print: True to pretty print, False otherwise.

        Returns:
            Returns a mapping of source file to XML string.
        '''
        xml_by_file = {}

        for layout in self.layouts.values():
            xml_by_file[layout.source_file] = layout.to_xml_str(pretty_print)

        return xml_by_file

    def to_files(self) -> None:
        '''
        Serialize to disk.
        '''
        new_files = self.to_xml_str(pretty_print=True)
        for file_path, data in new_files.items():
            with open(file_path, 'w', encoding='utf-8') as handle:
                handle.write(data)

    def _load_file(self, source_file: str, data: Optional[str] = None) -> None:
        '''
        Load database entries from a single file.

        Args:
            source_file: File path of the data on disk.
            data: Data payload it has been preloaded.

        Returns:
            A new CounterInfos instance.
        '''
        if not data:
            with open(source_file, 'r', encoding='utf-8') as handle:
                data = handle.read()

        # GPU name
        source_path = pathlib.Path(source_file).name
        gpu = source_path.replace('.xml', '')

        # Load and append counters to the local store
        info = HardwareLayout.from_xml_str(data, source_file)
        self.layouts[gpu] = info
        assert info.name == gpu, f'{info.name} != {gpu}'

    def __iter__(self) -> Iterator[HardwareLayout]:
        '''
        Iterate all layouts in an unstructured way.

        Yields:
            Hardware layouts in arbitrary order.
        '''
        yield from self.layouts.values()

    @classmethod
    def from_xml_str(cls, file_map: dict[str, str]) -> HardwareLayouts:
        '''
        Factory method to load the entire database from in-memory XML.

        Args:
            file_map: Data to load, key is file name, value is file payload.

        Returns:
            A new HardwareInfos instance.
        '''
        hardware_layouts = cls()

        for source_file, xml_data in file_map.items():
            hardware_layouts._load_file(source_file, xml_data)

        return hardware_layouts

    @classmethod
    def from_files(cls) -> HardwareLayouts:
        '''
        Factory method to load all hardware layouts from XML files.

        Returns:
            A new HardwareLayouts instance.
        '''
        # Fetch the data using a script-relative path
        root = pathlib.Path(__file__).parent.parent.parent
        dir_path = root / 'database' / 'hardwarelayout'
        assert dir_path.exists() and dir_path.is_dir()

        # Ensure we load from XML files in alphabetical order for stability
        database_files = list(dir_path.glob('Mali*.xml'))
        database_files.sort()

        hardware_layouts = cls()
        for file_path in database_files:
            hardware_layouts._load_file(str(file_path))

        return hardware_layouts
