<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arm Mali-G610 Performance Counter Reference Guide</title>
  <link href="./css/lato-font.css" rel="stylesheet">
  <link href="./css/bootstrap-5.3.8.min.css" rel="stylesheet">
  <link href="./css/fontawesome-7.1.0.all.min.css" rel="stylesheet">
  <link href="./css/document.css" rel="stylesheet">
</head>
<body>
  <!-- Side menu -->
  <input id="lgc-navtoggle" type="checkbox" class="vh" />
  <input id="lgc-navpin" type="checkbox" class="vh" />
  <aside class="lgc-menupanel lgc-no-print">
    <label class="lgc-toggle" for="lgc-navtoggle" data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Toggle menu"><i class="fa-solid fa-angles-right"></i></label>
    <label class="lgc-pin" for="lgc-navpin" data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Pin menu"><i class="fa-solid fa-thumbtack"></i></label>
    <div class="lgc-menuoptions">
      <div class="lgc-filter form-group">
        <i class="lgc-filter-icon fa-solid fa-filter"></i>
        <input type="search" class="lgc-filter-input rounded-pill form-control form-control-placeholdericon" placeholder="Filter" id="lgc-filterInput" />
      </div>
      <div class="lgc-filter form-group">
        <button class="lgc-menu-controls rounded-pill btn btn-primary" type="button" data-bs-toggle="collapse" data-bs-target="#collapseExample" aria-expanded="true" aria-controls="collapseExample">
          Toggle controls
        </button>
      </div>
      <div class="collapse show" id="collapseExample">
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="checkbox" role="switch" id="lgc-enableAdvancedApp" />
          <label class="form-check-label" for="enableAdvancedApp">Show advanced for applications</label>
          <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Show advanced counters for application developers"><i class="lgc-info-icon fa-solid fa-circle-info"></i></span>
        </div>
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="checkbox" role="switch" id="lgc-enableAdvancedSys" />
          <label class="form-check-label" for="enableAdvancedSys">Show advanced for systems</label>
          <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Show advanced counters for system developers"><i class="lgc-info-icon fa-solid fa-circle-info"></i></span>
        </div>
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="checkbox" role="switch" id="lgc-enableEquations" />
          <label class="form-check-label" for="enableEquations">Show equations</label>
          <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Show source equations for derived counters"><i class="lgc-info-icon fa-solid fa-circle-info"></i></span>
        </div>
        <p class="lgc-menuitem ">Select counter naming convention:</p>
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="radio" name="formatRadios" id="lgc-format-lgc" checked>
          <label class="form-check-label" for="lgc-format-lgc">libGPUCounters format</label>
        </div>
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="radio" name="formatRadios" id="lgc-format-sl">
          <label class="form-check-label" for="lgc-format-sl">Streamline format</label>
        </div>
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="radio" name="formatRadios" id="lgc-format-hw">
          <label class="form-check-label" for="lgc-format-hw">Hardware format</label>
        </div>
      </div>
      <hr class="lgc-menuitem">
    </div>
    <!-- Menu is built on the fly on page load -->
    <div class="lgc-menutree" id="lgc-toc">
    </div>
  </aside>

  <!-- Main page content -->
  <main>
    <div class="lgc-titlepanel">
      <h1>Arm Mali-G610</h1>
      <p><a href="./index.html">Home</a> / Arm® Mali™-G610 Performance Counter Reference <span class="lgc-filtered-pill badge rounded-pill">Filtered</span></p>
    </div>
    <div class="lgc-mainpanel">
      <div class="lgc-contentpanel">
        <div class="lgc-section">
<h2 id="s_introduction">Introduction</h2>
<p>Arm GPUs provide a wide range of performance counters. You can use them to
understand your application's performance characteristics, and to find
behavioral inefficiencies to optimize. This guide explains the performance
counters for the Mali-G610, which is a member of the Valhall second generation
architecture family.</p>
<p>This introduction section will explain the high level goals to consider when
profiling this GPU. Later sections will explain the available counters for each
part of the GPU design.</p>
<h3>Profiling GPU scheduling</h3>
<p>The GPU runs workloads that have been submitted by the graphics driver, using
scheduling barriers between workloads to ensure they run in the correct order.
Workloads are scheduled to run by adding them to the appropriate hardware
queue, which will run enqueued workloads in a pipelined FIFO processing order.</p>
<p><img alt="Valhall CSF top-level" src="./images/valhall-csf-top-level.svg" /></p>
<h4>Tile-based rendering</h4>
<p>Arm GPUs are tile-based GPUs, meaning that they process graphics render passes
in two distinct phases. The first phase processes geometry to determine which
primitives contribute to which screen-space tiles. The second phase renders the
output framebuffer tile-by-tile.</p>
<p>In this design, tiles are small enough to be kept in on-chip tile memory, which
makes fragment processing more efficient. However, in this generation of GPUs
vertex shaders are processed in their entirety in the first phase with their
outputs written back to main memory, and then re-read during the second phase.
This makes geometry processing less efficient.</p>
<h4>GPU queues</h4>
<p>The GPU front-end in this generation of hardware has three hardware queues:</p>
<ul>
<li>Compute queue</li>
<li>Vertex and tiling queue</li>
<li>Fragment queue</li>
</ul>
<p>The Compute queue is used for all compute-like workloads, including compute
shaders, buffer transfers, geometry shaders, and tessellation shaders. The
Vertex and tiling queue is used for vertex shading and binning. The Fragment
queue is used for all fragment-like workloads, including fragment shading and
most image transfers.</p>
<p>Monitoring your application's queue usage is the first stage of profiling an
Arm GPU, as the queue costs give the overall processing cost of each type of
workload. In addition you can see if your application is using barriers
efficiently, allowing the queues to run their workloads in parallel.</p>
<h3>Profiling GPU memory bandwidth</h3>
<p>GPUs are data-plane processors, so memory access efficiency is an important
factor for overall performance.</p>
<p><img alt="Valhall memory system" src="./images/bifrost-memory-system.svg" /></p>
<p>Memory system performance outside of the GPU cannot be directly observed via
GPU performance counters, but the counters can show the performance observed by
the GPU on its memory interface.</p>
<h4>Reducing bandwidth</h4>
<p>Accessing external DRAM is a very energy-intensive operation, which makes
reducing external bandwidth an important optimization goal for mobile devices.
Sustained high bandwidth can cause poor performance in main-stream devices, and
thermal issues in high-end devices.</p>
<p>Shader core performance counters can give you more breakdown about which
functional units are generating memory traffic, guiding your optimization
efforts.</p>
<h4>Reducing stalls</h4>
<p>The memory system outside of the GPU is implemented by the chip manufacturer,
and designs can vary and have different performance characteristics. Workloads
that generate a significant number of memory stall cycles, or that see a large
percentage of high latency reads, might be stressing the external memory system
beyond its capabilities. Reducing memory bandwidth often gives measurable
performance gains in these scenarios.</p>
<h3>Profiling shader core usage</h3>
<p>If the GPU queues are scheduling well, the next thing that you will need to
profile to determine the processing bottleneck of a workload is your
application's use of the shader core.</p>
<p>The Mali-G610 shader cores use a massively multi-threaded architecture,
supporting thousands of concurrently running threads. A large pool of available
threads allows the hardware to fill parallel functional units by switching to
any of the available threads if the current thread becomes blocked for any
reason.</p>
<p><img alt="Valhall shader core" src="./images/valhall-execution-core.svg" /></p>
<p>In this type of architecture, the utilization of the functional units reflects
the overall demand of the running shader programs. This is relatively
independent of localized hot-spots in shaders that stress a single functional
unit, because other threads will be running other parts of the program and will
load-balance the hardware. This is quite different to profiling a CPU, where
the serial instruction stream means that performance can be very sensitive to
both latency and localized hot-spots.</p>
<h3>Improve speed-of-light utilization</h3>
<p>For functional unit profiling, we therefore aim for at least 75% utilization of
the most heavily used functional unit, relative to its best case
'speed-of-light' performance. This shows that the application has done a good
job getting its workload running without problematic stalls.</p>
<p>In this situation, reducing demand on the most heavily used functional units,
either by improving efficiency or reducing size, should improve application
performance.</p>
<h4>Reduce shader core stalls</h4>
<p>If no functional unit is heavily utilized, the shader core is running out of
work to do. This can occur for multiple reasons, and should be avoided if
possible.</p>
<p>The first reason is that the shader is literally running out of threads to run,
and the shader core is running with low thread occupancy. GPUs rely on
workloads having a lot of threads to fill the capacity of the shader core. You
should avoid running small workloads with few threads on the GPU, preferring to
use the CPU if possible. Note that some workloads, such as depth shadow maps,
may not generate many fragment threads due to their algorithmic design. This is
usually unavoidable, but is something to remember when profiling.</p>
<p>The second reason is that the running shader programs are causing operations to
stall by missing in descriptor caches or data caches. GPUs use their thread
count to hide the impact and latency of cache misses, but there are limits to
the density of misses that can be hidden. In this situation, try to identify
which workload is causing stalls and try to minimize them. There are not
specific performance counters for every stall reason, so this can take some
investigation and experimentation to determine which resource is causing the
problem.</p>
<h3>Profiling workload</h3>
<p>In addition to profiling use of the hardware, measuring cycles and bytes, Arm
GPUs provide many performance counters that can help you to understand the size
and characteristics of your workload. These counters gives feedback in the
context of API constructs, such as vertices, triangles, and pixels making it
easier for developers to understand the feedback.</p>
<p><img alt="Valhall shader core" src="./images/valhall-shader-core.svg" /></p>
<p>Supplementing the workload size counters, Arm GPUs also provide counters that
indicate areas where content is not following best practice guidelines.
Improving these best practice metrics will nearly always improve your
application's performance or energy efficiency.</p>
</div>
<div class="lgc-section">
<h2 id="s_gpufrontend">GPU Front-end <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The GPU front-end is the interface between the GPU hardware and the driver. The
front-end schedules command streams submitted by the driver on to multiple
hardware work queues. Each work queue handles a specific type of workload and
is responsible for breaking a workload into smaller tasks that can be
dispatched to the shader cores. Work stays at the head of the queue while being
processed, so queue activity is a direct way of measuring that the GPU is busy
handling a workload.</p>
<p>In this generation of hardware there are three work queues:</p>
<ul>
<li>Compute queue for compute shaders and advanced geometry shaders.</li>
<li>Vertex queue for the first phase of a render pass, handling vertex shading,
  and primitive culling and binning.</li>
<li>Fragment queue for the second phase of a render pass, handling fragment
  shading.</li>
</ul>
<p>It is beneficial to schedule work on multiple queues in parallel, as this can
more evenly load balance the hardware. In this generation of hardware the
Compute and Vertex queues can run in parallel to the Fragment queue, but
serially with respect to each other. Parallel processing will increase the
latency of individual tasks, but usually significantly improves overall
throughput.</p>
<p>Performance counters in this section can show activity on each of the queues,
which indicates the complexity and scheduling patterns of submitted workloads.</p>
<div class="lgc-group">
<h3 id="g_gpucycles">GPU Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the workload processing activity level of the GPU,
showing the overall use and when work was running for each of the hardware
scheduling queues.</p>
<div class="lgc-series">
<h4 id="c_6">GPU active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the GPU has any pending workload
present in one of its processing queues. It shows the overall GPU processing
load requested by the application.</p>
<p>This counter increments when any workload is present in any processing queue,
even if the GPU is stalled waiting for external memory. These cycles are
counted as active time even though no progress is being made.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCyclesGPUActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>GPU_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_1">Any queue active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when any GPU command queue is active
with work for the tiler or shader cores.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUAnyQueueActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCyclesAnyQueueActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>GPU_ITER_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_26">Compute queue active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments every clock cycle when the command stream compute
queue has at least one task issued for processing.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueActiveCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliCompQueuedCy - MaliCompQueueAssignStallCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliGPUQueuedCyclesComputeQueued - $MaliGPUWaitCyclesComputeQueueEndpointStalls</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>ITER_COMP_ACTIVE - ITER_COMP_READY_BLOCKED</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_34">Vertex queue active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments every clock cycle when the command stream vertex
queue has at least one task issued for processing.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVertQueueActiveCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliVertQueuedCy - MaliVertQueueAssignStallCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliGPUQueuedCyclesVertexQueued - $MaliGPUWaitCyclesVertexQueueEndpointStalls</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>ITER_TILER_ACTIVE - ITER_TILER_READY_BLOCKED</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_60">Fragment queue active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments every clock cycle when the command stream fragment
queue has at least one task issued for processing.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragQueueActiveCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliFragQueuedCy - MaliFragQueueAssignStallCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliGPUQueuedCyclesFragmentQueued - $MaliGPUWaitCyclesFragmentQueueEndpointStalls</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>ITER_FRAG_ACTIVE - ITER_FRAG_READY_BLOCKED</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_139">Tiler active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle the tiler has a workload in its
processing queue. The tiler is responsible for coordinating geometry processing
and providing the fixed-function tiling needed for the Mali tile-based
rendering pipeline. It can run in parallel to vertex shading and fragment
shading.</p>
<p>A high cycle count here does not necessarily imply a bottleneck, unless the <a
href="#c_226">Non-fragment active cycles</a> counter in the shader core is
comparatively low.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCyclesTilerActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TILER_ACTIVE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_54">GPU interrupt active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the GPU has an interrupt pending
and is waiting for the CPU to process it.</p>
<p>Cycles with a pending interrupt do not necessarily indicate lost performance
because the GPU can process other queued work in parallel. However, if <a
href="#c_54">GPU interrupt pending cycles</a> are a high percentage of <a
href="#c_6">GPU active cycles</a>, an underlying problem might be preventing
the CPU from efficiently handling interrupts. This problem is normally a system
integration issue, which an application developer cannot work around.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUIRQActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCyclesGPUInterruptActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>GPU_IRQ_ACTIVE</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_gpuqueuedcycles">GPU Queued Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the workload scheduling behavior of the GPU queues,
showing when queues contained work, including cycles where a queue was stalled
and could not start an enqueued workload.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_349">Compute queued <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the command stream compute queue
has work queued. The count includes cycles when the queue is stalled because of
endpoint contention.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueuedCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUQueuedCyclesComputeQueued</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_COMP_ACTIVE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_348">Vertex queued <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the command stream vertex
shading queue has work queued. The count includes cycles when the queue is
stalled because of endpoint contention.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVertQueuedCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUQueuedCyclesVertexQueued</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_TILER_ACTIVE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_347">Fragment queued <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the command stream fragment
queue has work queued. The count includes cycles when the queue is stalled
because of endpoint contention.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragQueuedCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUQueuedCyclesFragmentQueued</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_FRAG_ACTIVE</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app lgc-advanced-sys">
<h3 id="g_gpuwaitcycles">GPU Wait Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the workload scheduling behavior of the GPU queues,
showing reasons for any scheduling stalls for each queue.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_32">Compute queue endpoint drain stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when compute work is queued but
cannot start because IDVS work is still active on the shared endpoints.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueDrainStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUWaitCyclesComputeQueueEndpointDrainStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_COMP_EP_DRAIN</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_33">Compute queue endpoint stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when compute work is queued but
cannot start because no endpoints have been assigned.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueAssignStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUWaitCyclesComputeQueueEndpointStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_COMP_READY_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_40">Vertex queue endpoint drain stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when vertex work is queued but cannot
start because compute work is still active on the shared endpoints.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerQueueDrainStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUWaitCyclesVertexQueueEndpointDrainStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_TILER_EP_DRAIN</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_41">Vertex queue endpoint stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when vertex work is queued but cannot
start because no endpoints have been assigned.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVertQueueAssignStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUWaitCyclesVertexQueueEndpointStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_TILER_READY_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_48">Fragment queue endpoint stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when fragment work is queued but
cannot start because no endpoints have been assigned.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragQueueAssignStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUWaitCyclesFragmentQueueEndpointStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_FRAG_READY_BLOCKED</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_gpujobs">GPU Jobs <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of workload jobs issued to the GPU
front-end for each queue. Most jobs will correspond to an API workload, for
example a compute dispatch generates a compute job. However, the driver can
also generate small house-keeping jobs for each queue, so job counts do not
directly correlate with API behavior.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_29">Compute jobs <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every job processed by the compute queue.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueJob</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUJobsComputeJobs</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_COMP_JOB_COMPLETED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_37">Vertex jobs <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every job processed by the vertex queue.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVertQueueJob</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUJobsVertexJobs</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_TILER_JOB_COMPLETED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_8">Fragment jobs <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every job processed by the fragment queue.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragQueueJob</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUJobsFragmentJobs</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_FRAG_JOB_COMPLETED</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app lgc-advanced-sys">
<h3 id="g_gputasks">GPU Tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of workload tasks issued by the GPU
front-end to the processing end-points inside the GPU.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_30">Compute tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every compute task processed by the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUTasksComputeTasks</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_COMP_TASK_COMPLETED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_38">Vertex tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every vertex task processed by the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVertQueueTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUTasksVertexTasks</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_TILER_IDVS_TASK_COMPLETED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_46">Fragment tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every <a href="#c_65537">32</a> x <a
href="#c_65537">32</a> pixel region of a render pass that is processed by the
GPU. The processed region of a render pass can be smaller than the full size of
the attached surfaces if the application's viewport and scissor settings
prevent the whole image being rendered.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragQueueTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUTasksFragmentTasks</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_FRAG_TASK_COMPLETED</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_gpuutilization">GPU Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the workload processing activity level of the GPU
queues, normalized as a percentage of overall GPU activity.</p>
<div class="lgc-series">
<h4 id="c_65543">Compute queue utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the compute queue utilization compared against the GPU
active cycles.</p>
<p>For GPU bound content, it is expected that the GPU queues process work in
parallel. The dominant queue must be close to 100% utilized to get the best
performance. If no queue is dominant, but the GPU is fully utilized, then a
serialization or dependency problem might be preventing queue overlap.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliCompQueuedCy - MaliCompQueueAssignStallCy) / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliGPUQueuedCyclesComputeQueued - $MaliGPUWaitCyclesComputeQueueEndpointStalls) / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((ITER_COMP_ACTIVE - ITER_COMP_READY_BLOCKED) / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65542">Vertex queue utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the vertex queue utilization compared against the GPU
active cycles.</p>
<p>For GPU bound content, it is expected that the GPU queues process work in
parallel. The dominant queue must be close to 100% utilized to get the best
performance. If no queue is dominant, but the GPU is fully utilized, then a
serialization or dependency problem might be preventing queue overlap.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVertQueueUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliVertQueuedCy - MaliVertQueueAssignStallCy) / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliGPUQueuedCyclesVertexQueued - $MaliGPUWaitCyclesVertexQueueEndpointStalls) / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((ITER_TILER_ACTIVE - ITER_TILER_READY_BLOCKED) / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65538">Fragment queue utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the fragment queue utilization compared against the GPU
active cycles. For GPU bound content, it is expected that the GPU queues
process work in parallel. The dominant queue must be close to 100% utilized to
get the best performance. If no queue is dominant, but the GPU is fully
utilized, then a serialization or dependency problem might be preventing
scheduling overlap.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragQueueUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliFragQueuedCy - MaliFragQueueAssignStallCy) / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliGPUQueuedCyclesFragmentQueued - $MaliGPUWaitCyclesFragmentQueueEndpointStalls) / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((ITER_FRAG_ACTIVE - ITER_FRAG_READY_BLOCKED) / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65545">Tiler utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the tiler utilization compared to the total GPU active
cycles.</p>
<p>Note that this metric measures the overall processing time for the tiler
geometry pipeline. The metric includes aspects of vertex shading, in addition
to the fixed-function tiling process.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliTilerActiveCy / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliGPUCyclesTilerActive / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((TILER_ACTIVE / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_65544">Interrupt utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the IRQ pending utilization compared against the GPU
active cycles. In a well-functioning system, this expression should be less
than 3% of the total cycles. If the value is much higher than this, a system
issue might be preventing the CPU from efficiently handling interrupts.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUIRQUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliGPUIRQActiveCy / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliGPUCyclesGPUInterruptActive / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((GPU_IRQ_ACTIVE / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_gpumessages">GPU Messages <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of control-plane messages issued by
the GPU front-end to the processing end-points inside the GPU.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_55">GPU interrupts <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every interrupt raised by the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUIRQ</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUMessagesGPUInterrupts</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>GPU_IRQ_COUNT</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_gpucacheflushes">GPU Cache Flushes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of L2 cache and MMU operations
performed by the GPU top-level.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_82">L2 cache flushes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L2 cache flush that is performed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheFlush</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCacheFlushesL2CacheFlushes</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CACHE_FLUSH</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_gpucacheflushcycles">GPU Cache Flush Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of cycles spent performing L2 cache
and MMU operations by GPU top-level.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_83">L2 cache flush <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the GPU is flushing the L2
cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheFlushCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCacheFlushCyclesL2CacheFlush</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CACHE_FLUSH_CYCLES</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_csfcycles">CSF Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of cycles that each of the sub-units
inside the command stream front-end was active.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_5">CEU active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the GPU command execution unit
is active.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCEUActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFCyclesCEUActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CEU_ACTIVE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_2">LSU active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the GPU command load/store unit
is active.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFLSUActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFCyclesLSUActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LSU_ACTIVE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_0">MCU active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the GPU command stream
management microcontroller is executing. Cycles waiting for interrupts or
events are not counted.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFMCUActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFCyclesMCUActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MCU_ACTIVE</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_csfutilization">CSF Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the use of each of the functional units inside the
command stream front-end, relative to their speed-of-light capability.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_317">CEU utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the front-end command execution unit utilization
compared against the GPU active cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCEUUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCSFCEUActiveCy / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliCSFCyclesCEUActive / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((CEU_ACTIVE / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_316">LSU utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the front-end load/store unit utilization compared
against the GPU active cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFLSUUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCSFLSUActiveCy / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliCSFCyclesLSUActive / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((LSU_ACTIVE / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_65541">MCU utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the microcontroller utilization compared against the
GPU active cycles.</p>
<p>High microcontroller load can be indicative of content using many emulated
commands, such as command stream scheduling and synchronization operations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFMCUUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCSFMCUActiveCy / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliCSFCyclesMCUActive / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((MCU_ACTIVE / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_csfstreamcycles">CSF Stream Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of cycles that each of the command
stream interfaces was active.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_10">CS0 active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 0
contained a command stream. This does not necessarily indicate that the command
stream was actively being processed by the main GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCS0ActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamCyclesCS0Active</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF0_ENABLED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_14">CS1 active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 1
contained a command stream. This does not necessarily indicate that the command
stream was actively being processed by the main GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCS1ActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamCyclesCS1Active</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF1_ENABLED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_18">CS2 active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 2
contained a command stream. This does not necessarily indicate that the command
stream was actively being processed by the main GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCS2ActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamCyclesCS2Active</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF2_ENABLED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_22">CS3 active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 3
contained a command stream. This does not necessarily indicate that the command
stream was actively being processed by the main GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCS3ActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamCyclesCS3Active</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF3_ENABLED</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_csfstreamstallcycles">CSF Stream Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of cycles that each of the command
stream interfaces stalled for any reason.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_13">CS0 wait stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 0 was
blocked due an outstanding scheduling dependency.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCS0WaitStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamStallCyclesCS0WaitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF0_WAIT_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_17">CS1 wait stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 1 was
blocked due an outstanding scheduling dependency.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCS1WaitStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamStallCyclesCS1WaitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF1_WAIT_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_21">CS2 wait stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 2 was
blocked due an outstanding scheduling dependency.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCS2WaitStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamStallCyclesCS2WaitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF2_WAIT_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_25">CS3 wait stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 3 was
blocked due an outstanding scheduling dependency.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCS3WaitStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamStallCyclesCS3WaitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF3_WAIT_BLOCKED</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_externalmemorysystem">External Memory System <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The GPU external memory interface connects the GPU to the system DRAM, via an
on-chip memory bus. The exact configuration of the memory system outside of the
GPU varies from device to device and might include additional levels of system
cache before reaching the off-chip memory.</p>
<p>GPUs are data-plane processors, with workloads that are too large to keep in
system cache and that therefore make heavy use of main memory. GPUs are
designed to be tolerant of high latency, when compared to a CPU, but poor
memory system performance can still reduce GPU efficiency.</p>
<p>Accessing external DRAM is one of the most energy-intensive operations that the
GPU can perform. Reducing memory bandwidth is a key optimization goal for
mobile applications, even if not bandwidth limited, ensuring users get long
battery life and thermally stable performance.</p>
<p>Performance counters in this section measure how much memory bandwidth your
application uses, as well as stall and latency counters to show how well the
memory system is coping with the generated traffic.</p>
<div class="lgc-group lgc-advanced-app lgc-advanced-sys">
<h3 id="g_externalbusaccesses">External Bus Accesses <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the absolute number of external memory transactions
generated by the GPU.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_111">Read transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external read transaction made on the memory
bus. These transactions typically result in an external DRAM access, but some
designs include a system cache which can provide some buffering.</p>
<p>The longest memory transaction possible is 64 bytes in length, but shorter
transactions are generated in some circumstances.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesReadTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_READ</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_124">Write transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external write transaction made on the memory
bus. These transactions typically result in an external DRAM access, but some
chips include a system cache which can provide some buffering.</p>
<p>The longest memory transaction possible is 64 bytes in length, but shorter
transactions are generated in some circumstances.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesWriteTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_112">ReadNoSnoop transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every non-coherent (ReadNoSnp) transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdNoSnoop</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesReadNoSnoopTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_READ_NOSNP</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_113">ReadUnique transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every coherent exclusive read (ReadUnique)
transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdUnique</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesReadUniqueTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_READ_UNIQUE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_134">Snoop transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every coherency snoop transaction received from an
external requester.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheIncSnp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesSnoopTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_SNOOP</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_125">WriteNoSnoopFull transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external non-coherent full write
(WriteNoSnpFull) transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrNoSnoopFull</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesWriteNoSnoopFullTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE_NOSNP_FULL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_126">WriteNoSnoopPartial transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external non-coherent partial write
(WriteNoSnpPtl) transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrNoSnoopPart</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesWriteNoSnoopPartialTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE_NOSNP_PTL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_127">WriteSnoopFull transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external coherent full write (WriteBackFull
or WriteUniqueFull) transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrSnoopFull</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesWriteSnoopFullTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE_SNP_FULL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_128">WriteSnoopPartial transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external coherent partial write (WriteBackPtl
or WriteUniquePtl) transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrSnoopPart</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesWriteSnoopPartialTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE_SNP_PTL</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_externalbusbeats">External Bus Beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the absolute amount of external memory data transfer
cycles used by the GPU.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_114">Read beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when a data beat was read from
the external memory bus.</p>
<p>Most implementations use a 128-bit (16-byte) data bus, enabling a single
64-byte read transaction to be read using 4 bus cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusBeatsReadBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_READ_BEATS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_129">Write beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when a data beat was written to
the external memory bus.</p>
<p>Most implementations use a 128-bit (16-byte) data bus, enabling a single
64-byte read transaction to be written using 4 bus cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusBeatsWriteBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE_BEATS</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_externalbusbytes">External Bus Bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the absolute amount of external memory traffic
generated by the GPU. Absolute measures are the most useful way to check actual
bandwidth against a per-frame bandwidth budget.</p>
<div class="lgc-series">
<h4 id="c_65548">Read bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total output read bandwidth for the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliExtBusRdBt * MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliExternalBusBeatsReadBeats * ($MaliConstantsBusWidthBits / 8)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>L2_EXT_READ_BEATS * MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65553">Write bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total output write bandwidth for the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliExtBusWrBt * MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliExternalBusBeatsWriteBeats * ($MaliConstantsBusWidthBits / 8)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>L2_EXT_WRITE_BEATS * MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_externalbusbandwidth">External Bus Bandwidth <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the external memory traffic generated by the GPU,
presented as a bytes/second rate. Rates are the most useful way to check actual
bandwidth against the design limits of a chip, which will usually be specified
in bytes/second.</p>
<div class="lgc-series">
<h4 id="c_554">Read bandwidth <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total output read bandwidth for the GPU, measured
in bytes per second.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdBPS</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliExtBusRdBt * MALI_CONFIG_EXT_BUS_BYTE_SIZE) / MALI_CONFIG_TIME_SPAN</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliExternalBusBeatsReadBeats * ($MaliConstantsBusWidthBits / 8)) / $ZOOM</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(L2_EXT_READ_BEATS * MALI_CONFIG_EXT_BUS_BYTE_SIZE) / MALI_CONFIG_TIME_SPAN</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_555">Write bandwidth <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total output write bandwidth for the GPU, measured
in bytes per second.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrBPS</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliExtBusWrBt * MALI_CONFIG_EXT_BUS_BYTE_SIZE) / MALI_CONFIG_TIME_SPAN</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliExternalBusBeatsWriteBeats * ($MaliConstantsBusWidthBits / 8)) / $ZOOM</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(L2_EXT_WRITE_BEATS * MALI_CONFIG_EXT_BUS_BYTE_SIZE) / MALI_CONFIG_TIME_SPAN</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app lgc-advanced-sys">
<h3 id="g_externalbusstallcycles">External Bus Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the absolute number of external memory interface
stalls, which is the number of cycles that the GPU was trying to send data but
the external bus could not accept it.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_115">Read stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every stall cycle on the AXI bus where the GPU has
a valid read transaction to send, but is awaiting a ready signal from the bus.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusStallCyclesReadStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AR_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_130">Write stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every stall cycle on the external bus where the GPU
has a valid write transaction to send, but is awaiting a ready signal from the
external bus.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusStallCyclesWriteStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_W_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_135">Snoop stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when a coherency snoop
transaction received from an external requester is stalled by the L2 cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheIncSnpStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusStallCyclesSnoopStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_SNOOP_STALL</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_externalbusstallrate">External Bus Stall Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the percentage of cycles that the GPU was trying to
send data, but by the external bus could not accept it.</p>
<p>A small number of stalls is expected, but sustained periods of with stall rates
above 10% might indicate that the GPU is generating more traffic than the
downstream memory system can handle efficiently.</p>
<div class="lgc-series">
<h4 id="c_65549">Read stall rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of GPU cycles with a memory stall on an
external read transaction.</p>
<p>Stall rates can be reduced by reducing the size of data resources, such as
buffers or textures.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdStallRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliExtBusRdStallCy / MALI_CONFIG_L2_CACHE_COUNT / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliExternalBusStallCyclesReadStalls / $MaliConstantsL2SliceCount / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((L2_EXT_AR_STALL / MALI_CONFIG_L2_CACHE_COUNT / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65554">Write stall rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of GPU cycles with a memory stall on an
external write transaction.</p>
<p>Stall rates can be reduced by reducing geometry complexity, or the size of
framebuffers in memory.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrStallRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliExtBusWrStallCy / MALI_CONFIG_L2_CACHE_COUNT / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliExternalBusStallCyclesWriteStalls / $MaliConstantsL2SliceCount / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((L2_EXT_W_STALL / MALI_CONFIG_L2_CACHE_COUNT / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_externalbusreadlatency">External Bus Read Latency <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the histogram distribution of memory latency for GPU
reads.</p>
<p>GPUs are more tolerant to latency than a CPU, but sustained periods of high
latency might indicate that the GPU is generating more traffic than the
downstream memory system can handle efficiently.</p>
<div class="lgc-series">
<h4 id="c_119">0-127 cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data beat that is returned between 0 and 127
cycles after the read transaction started. This latency is considered a fast
access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat0</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusReadLatency0127Cycles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_RRESP_0_127</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_120">128-191 cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data beat that is returned between 128 and
191 cycles after the read transaction started. This latency is considered a
normal access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat128</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusReadLatency128191Cycles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_RRESP_128_191</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_121">192-255 cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data beat that is returned between 192 and
255 cycles after the read transaction started. This latency is considered a
normal access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat192</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusReadLatency192255Cycles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_RRESP_192_255</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_122">256-319 cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data beat that is returned between 256 and
319 cycles after the read transaction started. This latency is considered a
slow access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat256</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusReadLatency256319Cycles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_RRESP_256_319</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_123">320-383 cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data beat that is returned between 320 and
383 cycles after the read transaction started. This latency is considered a
slow access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat320</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusReadLatency320383Cycles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_RRESP_320_383</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_65551">384+ cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments for every read beat that is returned at least 384
cycles after the transaction started. This latency is considered a very slow
access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat384</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliExtBusRdBt - MaliExtBusRdLat0 - MaliExtBusRdLat128 - MaliExtBusRdLat192 - MaliExtBusRdLat256 - MaliExtBusRdLat320</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliExternalBusBeatsReadBeats - $MaliExternalBusReadLatency0127Cycles - $MaliExternalBusReadLatency128191Cycles - $MaliExternalBusReadLatency192255Cycles - $MaliExternalBusReadLatency256319Cycles - $MaliExternalBusReadLatency320383Cycles</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>L2_EXT_READ_BEATS - L2_EXT_RRESP_0_127 - L2_EXT_RRESP_128_191 - L2_EXT_RRESP_192_255 - L2_EXT_RRESP_256_319 - L2_EXT_RRESP_320_383</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_externalbusoutstandingreads">External Bus Outstanding Reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the histogram distribution of the use of the available
pool of outstanding memory read transactions.</p>
<p>Sustained periods with most read transactions outstanding may indicate that the
GPU hardware configuration is running out of outstanding read capacity.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_116">0-25% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read transaction initiated when 0-25% of the
available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdOTQ1</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingReads025Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AR_CNT_Q1</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_117">25-50% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read transaction initiated when 25-50% of the
available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdOTQ2</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingReads2550Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AR_CNT_Q2</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_118">50-75% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read transaction initiated when 50-75% of the
available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdOTQ3</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingReads5075Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AR_CNT_Q3</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_65550">75-100% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments for every read transaction initiated when 75-100% of
transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdOTQ4</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliExtBusRd - MaliExtBusRdOTQ1 - MaliExtBusRdOTQ2 - MaliExtBusRdOTQ3</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliExternalBusAccessesReadTransactions - $MaliExternalBusOutstandingReads025Outstanding - $MaliExternalBusOutstandingReads2550Outstanding - $MaliExternalBusOutstandingReads5075Outstanding</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>L2_EXT_READ - L2_EXT_AR_CNT_Q1 - L2_EXT_AR_CNT_Q2 - L2_EXT_AR_CNT_Q3</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_externalbusoutstandingwrites">External Bus Outstanding Writes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the histogram distribution of the use of the available
pool of outstanding memory write transactions.</p>
<p>Sustained periods with most write transactions outstanding may indicate that
the GPU hardware configuration is running out of outstanding write capacity.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_131">0-25% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write transaction initiated when 0-25% of the
available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrOTQ1</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingWrites025Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AW_CNT_Q1</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_132">25-50% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write transaction initiated when 25-50% of
the available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrOTQ2</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingWrites2550Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AW_CNT_Q2</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_133">50-75% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write transaction initiated when 50-75% of
the available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrOTQ3</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingWrites5075Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AW_CNT_Q3</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_65555">75-100% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments for every write transaction initiated when 75-100%
of transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrOTQ4</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliExtBusWr - MaliExtBusWrOTQ1 - MaliExtBusWrOTQ2 - MaliExtBusWrOTQ3</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliExternalBusAccessesWriteTransactions - $MaliExternalBusOutstandingWrites025Outstanding - $MaliExternalBusOutstandingWrites2550Outstanding - $MaliExternalBusOutstandingWrites5075Outstanding</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>L2_EXT_WRITE - L2_EXT_AW_CNT_Q1 - L2_EXT_AW_CNT_Q2 - L2_EXT_AW_CNT_Q3</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_graphicsgeometryworkload">Graphics Geometry Workload <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>Graphics workloads using the rasterization pipeline pass inputs to the GPU as a
geometry stream. Vertices in this stream are position shaded, assembled into
primitives, and then passed through a culling pipeline before being passed to
the Arm GPU binning unit.</p>
<p>Performance counters in this section show how the input geometry is processed,
indicating the overall complexity of the geometry workload and how it is
processed by the primitive culling stages.</p>
<div class="lgc-group">
<h3 id="g_inputprimitives">Input Primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of input primitives to the GPU, before any
culling is applied.</p>
<div class="lgc-series">
<h4 id="c_65556">Input primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of input primitives to the rendering
process.</p>
<p>High complexity geometry is one of the most expensive inputs to the GPU,
because vertices are much larger than compressed texels. Optimize your geometry
to minimize mesh complexity, using dynamic level-of-detail and normal maps to
reduce the number of primitives required.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomTotalPrim</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliGeomFaceXYPlaneCullPrim + MaliGeomZPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomVisiblePrim</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliPrimitiveCullingFacingOrXYPlaneTestCulledPrimitives + $MaliPrimitiveCullingZPlaneTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>PRIM_CULLED + PRIM_CLIPPED + PRIM_SAT_CULLED + PRIM_VISIBLE</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_143">Triangle primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every input triangle primitive. The count is made
before any culling or clipping.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomTrianglePrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliInputPrimitivesTrianglePrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TRIANGLES</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_144">Line primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every input line primitive. The count is made
before any culling or clipping.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomLinePrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliInputPrimitivesLinePrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LINES</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_145">Point primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every input point primitive. The count is made
before any culling or clipping.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomPointPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliInputPrimitivesPointPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>POINTS</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_visibleprimitives">Visible Primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the properties of any visible primitives, after any
culling is applied.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_146">Front-facing primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every visible front-facing triangle that survives
culling.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomFrontFacePrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliVisiblePrimitivesFrontFacingPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRONT_FACING</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_147">Back-facing primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every visible back-facing triangle that survives
culling.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomBackFacePrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliVisiblePrimitivesBackFacingPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BACK_FACING</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_primitiveculling">Primitive Culling <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the absolute number of primitives that are culled by
each of the culling stages in the geometry pipeline, and the number of visible
primitives that are not culled by any stage.</p>
<div class="lgc-series">
<h4 id="c_148">Visible primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every visible primitive that survives all culling
stages.</p>
<p>All fragments of the primitive might be occluded by other primitives closer to
the camera, and so produce no visible output.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomVisiblePrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliPrimitiveCullingVisiblePrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>PRIM_VISIBLE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_65562">Culled primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of primitives that were culled during the
rendering process, for any reason.</p>
<p>For efficient 3D content, it is expected that only 50% of primitives are
visible because back-face culling is used to remove half of each model.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomTotalCullPrim</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliGeomFaceXYPlaneCullPrim + MaliGeomZPlaneCullPrim + MaliGeomSampleCullPrim</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliPrimitiveCullingFacingOrXYPlaneTestCulledPrimitives + $MaliPrimitiveCullingZPlaneTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>PRIM_CULLED + PRIM_CLIPPED + PRIM_SAT_CULLED</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_149">Facing or XY plane test culled primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive culled by the facing test, or
culled by testing against the view frustum X and Y clip planes.</p>
<p>For an arbitrary 3D scene we would expect approximately half of the triangles
to be back-facing. If you see a significantly lower percentage than this, check
that the facing test is properly enabled.</p>
<p>It is expected that a small number of primitives are outside of the frustum
extents, as application culling is never perfect and some models might
intersect a frustum clip plane. If this counter is significantly higher than
half of the triangles, use draw call bounding box checks to cull draws that are
completely out-of-frustum.</p>
<p>If batched draw calls are complex and have a large bounding volume, consider
using smaller batches to reduce the bounding volume to enable better culling.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomFaceXYPlaneCullPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliPrimitiveCullingFacingOrXYPlaneTestCulledPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>PRIM_CULLED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_150">Z plane test culled primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive culled by testing against the view
frustum near and far clip planes.</p>
<p>It is expected that a small number of primitives are outside of the frustum
extents, as application culling is never perfect and some models might
intersect a frustum clip plane.</p>
<p>Use draw call bounding box checks to cull draws that are completely
out-of-frustum. If batched draw calls are complex and have a large bounding
volume consider using smaller batches to reduce the bounding volume to enable
better culling.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomZPlaneCullPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliPrimitiveCullingZPlaneTestCulledPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>PRIM_CLIPPED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_151">Sample test culled primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive culled by the sample coverage test.
It is expected that a few primitives are small and fail the sample coverage
test, as application mesh level-of-detail selection can never be perfect. If
the number of primitives counted is more than than 5-10% of the total number,
this might indicate that the application has a large number of very small
triangles, which are very expensive for a GPU to process.</p>
<p>Aim to keep triangle screen area above 10 pixels. Use schemes such as mesh
level-of-detail to select simplified meshes as objects move further away from
the camera.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomSampleCullPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliPrimitiveCullingSampleTestCulledPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>PRIM_SAT_CULLED</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_primitivecullingrate">Primitive Culling Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the percentage of the primitives that use each culling
stage that are culled by it, and the percentage of primitives that are visible
and not culled by any stage.</p>
<div class="lgc-series">
<h4 id="c_65557">Visible primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives that are visible after
culling.</p>
<p>For efficient 3D content, it is expected that only 50% of primitives are
visible because back-face culling is used to remove half of each model.</p>
<ul>
<li>A significantly higher visibility rate indicates that the facing test might
  not be enabled.</li>
<li>A significantly lower visibility rate indicates that geometry is being
  culled for other reasons, which is often possible to optimize. Use the
  individual culling counters for a more detailed breakdown.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomVisibleRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliGeomVisiblePrim / (MaliGeomFaceXYPlaneCullPrim + MaliGeomZPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomVisiblePrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliPrimitiveCullingVisiblePrimitives / ($MaliPrimitiveCullingFacingOrXYPlaneTestCulledPrimitives + $MaliPrimitiveCullingZPlaneTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((PRIM_VISIBLE / (PRIM_CULLED + PRIM_CLIPPED + PRIM_SAT_CULLED + PRIM_VISIBLE)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65558">Facing or XY plane culled primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives entering the facing and XY
plane test that are culled by it. Primitives that are outside of the view
frustum in the XY axis, or that are back-facing inside the frustum, are culled
by this stage.</p>
<p>For efficient 3D content, it is expected that 50% of primitives are culled by
the facing test. If more than 50% of primitives are culled it might be because
they are out-of-frustum, which can often be optimized with better software
culling or batching granularity.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomFaceXYPlaneCullRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliGeomFaceXYPlaneCullPrim / (MaliGeomFaceXYPlaneCullPrim + MaliGeomZPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomVisiblePrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliPrimitiveCullingFacingOrXYPlaneTestCulledPrimitives / ($MaliPrimitiveCullingFacingOrXYPlaneTestCulledPrimitives + $MaliPrimitiveCullingZPlaneTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((PRIM_CULLED / (PRIM_CULLED + PRIM_CLIPPED + PRIM_SAT_CULLED + PRIM_VISIBLE)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65559">Z plane culled primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives entering the Z plane
culling test that are culled by it. Primitives that are closer than the frustum
near clip plane, or further away than the frustum far clip plane, are culled by
this stage.</p>
<p>Seeing a significant proportion of triangles culled at this stage can be
indicative of insufficient application software culling.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomZPlaneCullRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliGeomZPlaneCullPrim / ((MaliGeomFaceXYPlaneCullPrim + MaliGeomZPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomVisiblePrim) - MaliGeomFaceXYPlaneCullPrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliPrimitiveCullingZPlaneTestCulledPrimitives / (($MaliPrimitiveCullingFacingOrXYPlaneTestCulledPrimitives + $MaliPrimitiveCullingZPlaneTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives) - $MaliPrimitiveCullingFacingOrXYPlaneTestCulledPrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((PRIM_CLIPPED / ((PRIM_CULLED + PRIM_CLIPPED + PRIM_SAT_CULLED + PRIM_VISIBLE) - PRIM_CULLED)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65560">Sample culled primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives entering the sample
coverage test that are culled by it. This stage culls primitives that are so
small that they hit no rasterizer sample points.</p>
<p>If a significant number of triangles are culled at this stage, the application
is using geometry meshes that are too complex for their screen coverage. Use
schemes such as mesh level-of-detail to select simplified meshes as objects
move further away from the camera.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomSampleCullRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliGeomSampleCullPrim / ((MaliGeomFaceXYPlaneCullPrim + MaliGeomZPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomVisiblePrim) - MaliGeomFaceXYPlaneCullPrim - MaliGeomZPlaneCullPrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliPrimitiveCullingSampleTestCulledPrimitives / (($MaliPrimitiveCullingFacingOrXYPlaneTestCulledPrimitives + $MaliPrimitiveCullingZPlaneTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives) - $MaliPrimitiveCullingFacingOrXYPlaneTestCulledPrimitives - $MaliPrimitiveCullingZPlaneTestCulledPrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((PRIM_SAT_CULLED / ((PRIM_CULLED + PRIM_CLIPPED + PRIM_SAT_CULLED + PRIM_VISIBLE) - PRIM_CULLED - PRIM_CLIPPED)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_geometrythreads">Geometry Threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of vertex shader threads of each type that
are generated during vertex processing.</p>
<p>All vertices must be position shaded, but only visible vertices will be varying
shaded.</p>
<div class="lgc-series">
<h4 id="c_65565">Position shading threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of position shader thread invocations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomPosShadThread</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliGeomPosShadTask * 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliTilerShadingRequestsPositionShadingRequests * 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>IDVS_POS_SHAD_REQ * 4</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65566">Varying shading threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of varying shader thread invocations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomVarShadThread</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliGeomVarShadTask * 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliTilerShadingRequestsVaryingShadingRequests * 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>IDVS_VAR_SHAD_REQ * 4</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_geometryefficiency">Geometry Efficiency <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of vertex shader threads of each type that
are generated per primitive during vertex processing. Efficient geometry aims
to keep these metrics as low as possible.</p>
<div class="lgc-series">
<h4 id="c_65666">Position threads/input primitive <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of position shader threads per input
primitive.</p>
<p>Efficient meshes with a good vertex reuse have average less than 1.5 vertices
shaded per triangle, as vertex computation is shared by multiple primitives.
Minimize this number by reusing vertices for nearby primitives, improving
temporal locality of index reuse, and avoiding unused values in the active
index range.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomPosShadThreadPerPrim</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliGeomPosShadTask * 4) / (MaliGeomFaceXYPlaneCullPrim + MaliGeomZPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomVisiblePrim)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliTilerShadingRequestsPositionShadingRequests * 4) / ($MaliPrimitiveCullingFacingOrXYPlaneTestCulledPrimitives + $MaliPrimitiveCullingZPlaneTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(IDVS_POS_SHAD_REQ * 4) / (PRIM_CULLED + PRIM_CLIPPED + PRIM_SAT_CULLED + PRIM_VISIBLE)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65667">Varying threads/visible primitive <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of varying shader invocations per visible
primitive.</p>
<p>Efficient meshes with a good vertex reuse have average less than 1.5 vertices
shaded per triangle, as vertex computation is shared by multiple primitives.
Minimize this number by reusing vertices for nearby primitives, improving
temporal locality of index reuse, and avoiding unused values in the active
index range.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomVarShadThreadPerPrim</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliGeomVarShadTask * 4) / MaliGeomVisiblePrim</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliTilerShadingRequestsVaryingShadingRequests * 4) / $MaliPrimitiveCullingVisiblePrimitives</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(IDVS_VAR_SHAD_REQ * 4) / PRIM_VISIBLE</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_graphicsfragmentworkload">Graphics Fragment Workload <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>Graphics workloads using the rasterization pipeline are rendered into the
framebuffer to create output images.</p>
<p>Performance counters in this section show the workload complexity of your
fragment rendering.</p>
<div class="lgc-group">
<h3 id="g_outputpixels">Output pixels <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of output pixels rendered.</p>
<div class="lgc-series">
<h4 id="c_65546">Pixels <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of pixels that are shaded by the GPU,
including on-screen and off-screen render passes.</p>
<p>This measure can be a slight overestimate because it assumes all pixels in each
active <a href="#c_65537">32</a> x <a href="#c_65537">32</a> pixel region are
shaded. If the rendered region does not align with <a href="#c_65537">32</a>
pixel aligned boundaries, then this metric includes pixels that are not
actually shaded.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUPix</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliFragQueueTask * 1024</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliGPUTasksFragmentTasks * 1024</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>ITER_FRAG_TASK_COMPLETED * 1024</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_overdraw">Overdraw <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of fragments rendered per pixel.</p>
<div class="lgc-series">
<h4 id="c_65585">Fragments/pixel <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression computes the number of fragments shaded per output pixel.</p>
<p>GPU processing cost per pixel accumulates with the layer count. High overdraw
can build up to a significant processing cost, especially when rendering to a
high-resolution framebuffer. Minimize overdraw by rendering opaque objects
front-to-back and minimizing use of blended transparent layers.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragOverdraw</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliFragWarp * 16) / (MaliFragQueueTask * 1024)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderWarpsFragmentWarps * 16) / ($MaliGPUTasksFragmentTasks * 1024)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(FRAG_WARPS * 16) / (ITER_FRAG_TASK_COMPLETED * 1024)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_workloadcost">Workload Cost <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>Workload cost metrics give an average throughput per item of work processed by
the GPU.</p>
<p>Performance counters in this section can be used to track average performance
against budget, and to monitor the impact of application changes over time.</p>
<div class="lgc-group">
<h3 id="g_averageworkloadcost">Average Workload Cost <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group gives the average cycle throughput for the different kinds
of workloads the GPU is running.</p>
<p>When running workloads in parallel the shader core is shared, and these
throughput metrics will be impacted by cross-talk across the queues. However,
they still a useful tool for managing performance budgets.</p>
<div class="lgc-series">
<h4 id="c_65673">GPU cycles/pixel <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of GPU cycles being spent per pixel
rendered. This includes the cost of all shader stages.</p>
<p>It is a useful exercise to set a cycle budget for each render pass in your
application, based on your target resolution and frame rate. Rendering 1080p60
is possible with an entry-level device, but you have a small number of cycles
per pixel to work so must use them efficiently.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUCyPerPix</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliGPUActiveCy / (MaliFragQueueTask * 1024)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliGPUCyclesGPUActive / ($MaliGPUTasksFragmentTasks * 1024)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>GPU_ACTIVE / (ITER_FRAG_TASK_COMPLETED * 1024)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65593">Shader cycles/non-fragment thread <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of shader core cycles per
non-fragment thread.</p>
<p>This measurement captures the overall shader core throughput, not the shader
processing cost. It will be impacted by cycles lost to stalls that could not be
hidden by other processing. In addition, it will be impacted by any fragment
workloads that are running concurrently in the shader core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliNonFragThroughputCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliNonFragActiveCy / (MaliNonFragWarp * 16)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreCyclesNonFragmentActive / ($MaliShaderWarpsNonFragmentWarps * 16)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>COMPUTE_ACTIVE / (COMPUTE_WARPS * 16)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65575">Shader cycles/fragment thread <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of shader core cycles per fragment
thread.</p>
<p>This measurement captures the overall shader core throughput, not the shader
processing cost. It will be impacted by cycles lost to stalls that could not be
hidden by other processing. In addition, it will be impacted by any fragment
workloads that are running concurrently in the shader core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragThroughputCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliFragActiveCy / (MaliFragWarp * 16)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreCyclesFragmentActive / ($MaliShaderWarpsFragmentWarps * 16)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>FRAG_ACTIVE / (FRAG_WARPS * 16)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercorefrontend">Shader Core Front-end <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The shader core front-ends are the internal interfaces inside the GPU that
accept tasks from other parts of the GPU and turn them into shader threads
running in the programmable core.</p>
<p>Each shader core has two front-ends:</p>
<ul>
<li>Non-fragment front-end for all non-fragment tasks, including compute,
  vertex shading, and advanced geometry.</li>
<li>Fragment front-end for all fragment tasks.</li>
</ul>
<p>The front-ends show as active until task processing is complete, so front-end
activity is a direct way of measuring that the shader core is busy handling a
workload.</p>
<p>The Execution core is the programmable core at the heart of the shader core
hardware. The Execution core shows as active if there is at least on thread
running, and monitoring its activity is an indirect way of checking that the
front-ends are managing to keep the GPU busy.</p>
<p>Performance counters in this section measure the overall workload scheduling
for the shader core, showing how busy the shader core is. Note that front-end
counters can tell you that a task was scheduled but cannot tell you how heavily
the programmable core is being used.</p>
<div class="lgc-group">
<h3 id="g_shadercorecycles">Shader Core Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the scheduling load on the shader core, indicating
which of the shader core front-ends have work scheduled and whether they are
running threads on the programmable core.</p>
<div class="lgc-series">
<h4 id="c_207">Any workload active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the shader core is processing
any type of workload, irrespective of which queue the workload came from.</p>
<p>This counter is particularly useful in high-end GPU configurations where it can
indicate the shader core clock rate. This rate can be lower than the GPU
top-level clock rate.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliAnyActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreCyclesAnyWorkloadActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>SHADER_CORE_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_226">Non-fragment active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the shader core is processing
some non-fragment workload. Active processing includes any cycle that
non-fragment work is queued in the fixed-function front-end or programmable
core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliNonFragActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreCyclesNonFragmentActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>COMPUTE_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_196">Fragment active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the shader core is processing
some fragment workload. Active processing includes any cycle that fragment work
is running anywhere in the fixed-function front-end, fixed-function back-end,
or programmable core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreCyclesFragmentActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_212">Fragment pre-pipe buffer active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the pre-pipe quad queue contains
at least one quad waiting to run. If this queue completely drains, a fragment
warp cannot be spawned when space for new threads becomes available in the
shader core. You can experience reduced performance when low thread occupancy
starves the functional units of work to process.</p>
<p>Possible causes for this include:</p>
<ul>
<li>Tiles which contain no geometry, which are commonly encountered when
  creating shadow maps, where many tiles contain no shadow casters.</li>
<li>Tiles which contain a lot of geometry which are killed by early ZS or
  hidden surface removal.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragFPKActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreCyclesFragmentPrePipeBufferActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_FPK_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_230">Execution core active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the shader core is processing at
least one warp. Note that this counter does not provide detailed information
about how the functional units are utilized inside the shader core, but simply
gives an indication that something was running.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreCyclesExecutionCoreActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_CORE_ACTIVE</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shadercoreutilization">Shader Core Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the scheduling load on the shader core, normalized
against the overall shader core activity.</p>
<div class="lgc-series">
<h4 id="c_65589">Non-fragment utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the shader core
non-fragment path. This counter measures any cycle that a non-fragment workload
is active in the fixed-function front-end or programmable core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliNonFragUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliNonFragActiveCy / MaliAnyActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreCyclesNonFragmentActive / $MaliShaderCoreCyclesAnyWorkloadActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((COMPUTE_ACTIVE / SHADER_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65567">Fragment utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the shader core fragment
path. This counter measures any cycle that a fragment workload is active in the
fixed-function front-end, fixed-function back-end, or programmable core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragActiveCy / MaliAnyActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreCyclesFragmentActive / $MaliShaderCoreCyclesAnyWorkloadActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_ACTIVE / SHADER_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65569">Fragment pre-pipe buffer utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of cycles when the pre-pipe quad buffer
contains at least one fragment quad. This buffer is located after early ZS but
before the programmable core.</p>
<p>During fragment shading this counter must be close to 100%. This indicates that
the fragment front-end is able to keep up with the shader core shading
performance. This counter commonly drops below 100% for three reasons:</p>
<ul>
<li>The running workload has many empty tiles with no geometry to render. Empty
  tiles are common in shadow maps, corresponding to a screen region with no
  shadow casters, so this might not be avoidable.</li>
<li>The application consists of simple shaders but a high percentage of
  microtriangles. This combination causes the shader core to shade fragments
  faster than they are rasterized, so the quad buffer drains.</li>
<li>The application consists of geometry which stalls at early ZS because of a
  dependency on an earlier fragment layer which is still in flight. Stalled
  layers prevent new fragments entering the quad buffer, so the quad buffer
  drains.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragFPKBUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragFPKActiveCy / MaliFragActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreCyclesFragmentPrePipeBufferActive / $MaliShaderCoreCyclesFragmentActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_FPK_ACTIVE / FRAG_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65579">Execution core utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the programmable core,
measuring cycles when the shader core contains at least one warp. A low
utilization here indicates lost performance, because there are spare shader
core cycles that are unused.</p>
<p>In some use cases an idle core is unavoidable. For example, a clear color tile
that contains no shaded geometry, or a shadow map that is resolved entirely
using early ZS depth updates.</p>
<p>Improve programmable core utilization by parallel processing of the GPU work
queues, running overlapping workloads from multiple render passes. Also aim to
keep the FPK buffer utilization as high as possible, ensuring constant
forward-pressure on fragment shading.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCoreActiveCy / MaliAnyActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreCyclesExecutionCoreActive / $MaliShaderCoreCyclesAnyWorkloadActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_CORE_ACTIVE / SHADER_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shaderclockratio">Shader Clock Ratio <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group gives an estimate of the clock ratio between the shader core
and the GPU top-level. In large systems the shader cores will typically be
clocked more slowly than the top-level to improve energy efficiency.</p>
<div class="lgc-series">
<h4 id="c_65596">Shader core clock ratio <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage usage of the shader core, relative to
the top-level GPU clock.</p>
<p>To improve energy efficiency, some systems clock the shader cores at a lower
frequency than the GPU top-level components. In these systems, the maximum
achievable usage value is the clock ratio between the GPU top-level clock and
the shader clock. For example, a GPU with an 800MHz top-level clock and a
400MHz shader clock can achieve a maximum usage of 50%.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliAnyUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliAnyActiveCy / MALI_CONFIG_SHADER_CORE_COUNT / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreCyclesAnyWorkloadActive / $MaliConstantsShaderCoreCount / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((SHADER_CORE_ACTIVE / MALI_CONFIG_SHADER_CORE_COUNT / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_shadercoretasks">Shader Core Tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of tasks processed by the shader cores.
Task sizes for compute tasks are variable, so this is not expected to be a
useful measure of workload.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_227">Non-fragment tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every non-fragment task issued to the shader core.
The size of these tasks is variable.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliNonFragTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreTasksNonFragmentTasks</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>COMPUTE_TASKS</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercorefragmentfrontend">Shader Core Fragment Front-end <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The shader core fragment front-end is a complex multi-stage pipeline that
converts an incoming primitive stream for a screen-space tile into fragment
threads that need to be shaded. The fragment front-end handles rasterization,
early depth (Z) and stencil (S) testing, and hidden surface removal (HSR).</p>
<p>Performance counters in this section measure how the incoming stream was turned
into quads, and how efficiently those quads interacted with ZS testing and HSR.</p>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_fragmenttiles">Fragment Tiles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of fragment tiles processed by the shader
cores.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_223">Tiles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every tile processed by the shader core. Note that
tiles are normally <a href="#c_65647">32</a> x <a href="#c_65647">32</a> pixels
but can vary depending on per-pixel storage requirements and the tile buffer
size of the current GPU.</p>
<p>This GPU supports full size tiles when using up to and including <a
href="#c_65656">256</a> bits per pixel of color storage. Pixel storage
requirements depend on the number of color attachments, their data format, and
the number of multi-sampling samples per pixel.</p>
<p>The most accurate way to get the total pixel count rendered by the application
is to use the <a href="#c_46">Fragment tasks</a> counter, because it always
counts <a href="#c_65537">32</a> x <a href="#c_65537">32</a> pixel regions.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragTile</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentTilesTiles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_PTILES</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_224">Killed unchanged tiles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every 16x16 pixel tile or tile sub-region killed by
a transaction elimination CRC check, where the data is the same as the content
already stored in memory.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragTileKill</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentTilesKilledUnchangedTiles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_TRANS_ELIM</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_fragmentprimitives">Fragment Primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows how the fragment front-end handles the incoming
primitive stream from the tile list built during the binning phase.</p>
<p>Large primitives will be read in multiple tiles and will therefore cause
multiple increments to these counter values. These counters will not match the
input primitive counts passed in by the application.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_209">Loaded primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive loaded from the tile list by the
fragment front-end that is sent to rasterization. This increments per tile,
which means that a single primitive that spans multiple tiles is counted
multiple times.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragRdPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentPrimitivesLoadedPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_PRIMITIVES_OUT</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_211">Rasterized primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive entering the rasterization unit for
each tile shaded. This increments per tile, which means that a single primitive
that spans multiple tiles is counted multiple times. If you want to know the
total number of primitives in the scene refer to the <a href="#c_65556">Total
input primitives</a> expression.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragRastPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentPrimitivesRasterizedPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_PRIM_RAST</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_fragmentquads">Fragment Quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows how the rasterizer turns the incoming primitive stream
in to 2x2 sample quads for shading.</p>
<div class="lgc-series">
<h4 id="c_216">Rasterized fine quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every fine quad generated by the rasterization
phase. A fine quad covers a 2x2 pixel screen region. The quads generated have
at least some coverage based on the current sample pattern, but can
subsequently be killed by early ZS testing or hidden surface removal before
they are shaded.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragRastQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentQuadsRasterizedFineQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_RAST</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_217">Partial rasterized fine quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every rasterized fine quad containing pixels that
have no active sample points. Partial coverage occurs when any of sample points
span the edge of a triangle.</p>
<p>Note that a non-partial fine quad can become partial before shading if some
samples fail early ZS testing. This change is not visible in this counter.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragRastPartQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentQuadsPartialRasterizedFineQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_PARTIAL_QUADS_RAST</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_65570">Shaded coarse quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of 2x2 fragment quads that are spawned as
executing threads in the shader core.</p>
<p>This expression is an approximation assuming that all spawned fragment warps
contain a full set of quads. Comparing the total number of warps against the <a
href="#c_232">Full warps</a> counter can indicate how close this approximation
is.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragShadedQd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliFragWarp * 16) / 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderWarpsFragmentWarps * 16) / 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(FRAG_WARPS * 16) / 4</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_fragmentzsquads">Fragment ZS Quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows how the depth (Z) and stencil (Z) test unit handles
quads for early and late ZS test and update.</p>
<div class="lgc-series">
<h4 id="c_218">Early ZS tested quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad undergoing early depth and stencil
testing.</p>
<p>For maximum performance, this number must be close to the total number of input
quads. We want as many of the input quads as possible to be subject to early ZS
testing because early ZS testing is significantly more efficient than late ZS
testing, which only kills threads after they have been shaded.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragEZSTestQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsEarlyZSTestedQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_EZS_TEST</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_220">Early ZS killed quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad killed by early depth and stencil
testing.</p>
<p>Quads killed at this stage are killed before shading, so a high percentage here
is not generally a performance problem. However, it can indicate an opportunity
to use software culling techniques such as portal culling to avoid sending
occluded geometry to the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragEZSKillQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsEarlyZSKilledQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_EZS_KILL</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_219">Early ZS updated quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad undergoing early depth and stencil
testing that can update the framebuffer. Quads that have a depth value that
depends on shader behavior, or those that have indeterminate coverage because
of use of alpha-to-coverage or discard statements in the shader, might be early
ZS tested but can not do an early ZS update.</p>
<p>For maximum performance, this number must be close to the total number of input
quads. Aim to maximize the number of quads that are capable of doing an early
ZS update.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragEZSUpdateQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsEarlyZSUpdatedQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_EZS_UPDATE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_65581">FPK HSR killed quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of quads that are killed by the Forward
Pixel Kill (FPK) hidden surface removal scheme.</p>
<p>It is good practice to sort opaque geometry so that the geometry is rendered
front-to-back with depth testing enabled. This enables more geometry to be
killed by early ZS testing instead of FPK, which removes the work earlier in
the pipeline.</p>
<p>Quads killed at this stage are killed before shading, so a high percentage here
is not generally a performance problem. However, it can indicate an opportunity
to use software culling techniques such as portal culling to avoid sending
occluded geometry to the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragFPKKillQd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliFragRastQd - MaliFragEZSKillQd - ((MaliFragWarp * 16) / 4)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliFragmentQuadsRasterizedFineQuads - $MaliFragmentZSQuadsEarlyZSKilledQuads - (($MaliShaderWarpsFragmentWarps * 16) / 4)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>FRAG_QUADS_RAST - FRAG_QUADS_EZS_KILL - ((FRAG_WARPS * 16) / 4)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_222">Late ZS killed quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad killed by late depth and stencil
testing.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragLZSKillQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsLateZSKilledQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_LZS_KILL</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_221">Late ZS tested quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad undergoing late depth and stencil
testing.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragLZSTestQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsLateZSTestedQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_LZS_TEST</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_zsunittestrate">ZS Unit Test Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the relative numbers of quads doing early and late
depth (Z) and stencil (Z) testing.</p>
<div class="lgc-series">
<h4 id="c_65580">Early ZS kill rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of rasterized quads that are killed by
early depth and stencil testing.</p>
<p>Quads killed at this stage are killed before shading, so a high percentage here
is not generally a performance problem. However, it can indicate an opportunity
to use software culling techniques such as portal culling to avoid sending
occluded geometry to the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragEZSKillRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragEZSKillQd / MaliFragRastQd) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentZSQuadsEarlyZSKilledQuads / $MaliFragmentQuadsRasterizedFineQuads) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_QUADS_EZS_KILL / FRAG_QUADS_RAST) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65578">Early ZS test rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of rasterized quads that were subjected
to early depth and stencil testing.</p>
<p>To achieve the best early test rates, enable depth testing, and avoid draw
calls with modifiable coverage or draw calls with fragment shader programs that
write to their depth value.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragEZSTestRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragEZSTestQd / MaliFragRastQd) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentZSQuadsEarlyZSTestedQuads / $MaliFragmentQuadsRasterizedFineQuads) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_QUADS_EZS_TEST / FRAG_QUADS_RAST) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65594">Early ZS update rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of rasterized quads that update the
framebuffer during early depth and stencil testing.</p>
<p>To achieve the best early test rates, enable depth testing, and avoid draw
calls with modifiable coverage or draw calls with fragment shader programs that
write to their depth value.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragEZSUpdateRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragEZSUpdateQd / MaliFragRastQd) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentZSQuadsEarlyZSUpdatedQuads / $MaliFragmentQuadsRasterizedFineQuads) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_QUADS_EZS_UPDATE / FRAG_QUADS_RAST) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65665">Occluding quad rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of rasterized quads that survive early
depth and stencil testing that are valid hidden surface removal occluders.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragOpaqueQdRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragOpaqueQd / (MaliFragRastQd - MaliFragEZSKillQd)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentFPKHSRQuadsOccludingQuads / ($MaliFragmentQuadsRasterizedFineQuads - $MaliFragmentZSQuadsEarlyZSKilledQuads)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((QUAD_FPK_KILLER / (FRAG_QUADS_RAST - FRAG_QUADS_EZS_KILL)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65582">FPK HSR kill rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of rasterized quads that are killed by
the Forward Pixel Kill (FPK) hidden surface removal scheme.</p>
<p>Quads killed at this stage are killed before shading, so a high percentage here
is not generally a performance problem. However, it can indicate an opportunity
to use software culling techniques such as portal culling to avoid sending
occluded geometry to the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragFPKKillRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliFragRastQd - MaliFragEZSKillQd - ((MaliFragWarp * 16) / 4)) / MaliFragRastQd) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliFragmentQuadsRasterizedFineQuads - $MaliFragmentZSQuadsEarlyZSKilledQuads - (($MaliShaderWarpsFragmentWarps * 16) / 4)) / $MaliFragmentQuadsRasterizedFineQuads) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((FRAG_QUADS_RAST - FRAG_QUADS_EZS_KILL - ((FRAG_WARPS * 16) / 4)) / FRAG_QUADS_RAST) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65584">Late ZS kill rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of rasterized quads that are killed by
late depth and stencil testing. Quads killed by late ZS testing run at least
some of their fragment program before being killed.</p>
<p>A high percentage of fragments being killed by ZS can be a source of redundant
processing. You achieve the lowest late test rates by avoiding draw calls with
modifiable coverage, or with shader programs that write to their depth value or
that have memory-visible side-effects.</p>
<p>The driver uses a late ZS update and kill sequence to preload a depth or
stencil attachment at the start of a render pass, which is needed if the render
pass does not start from a cleared value. Always start from a cleared value
whenever possible.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragLZSKillRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragLZSKillQd / MaliFragRastQd) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentZSQuadsLateZSKilledQuads / $MaliFragmentQuadsRasterizedFineQuads) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_LZS_KILL / FRAG_QUADS_RAST) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65583">Late ZS test rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of rasterized quads that are tested by
late depth and stencil testing.</p>
<p>A high percentage of fragments performing a late ZS update can cause slow
performance, even if fragments are not killed. Younger fragments cannot
complete early ZS until all older fragments at the same coordinate have
completed their late ZS operations, which can cause stalls.</p>
<p>You achieve the lowest late test rates by avoiding draw calls with modifiable
coverage,, or with shader programs that write to their depth value or that have
memory-visible side-effects</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragLZSTestRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragLZSTestQd / MaliFragRastQd) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentZSQuadsLateZSTestedQuads / $MaliFragmentQuadsRasterizedFineQuads) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_LZS_TEST / FRAG_QUADS_RAST) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_fragmentfpkhsrquads">Fragment FPK HSR Quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows how many of the generated quads are eligible to be
occluders for the Forward Pixel Kill (FPK) hidden surface removal scheme.</p>
<div class="lgc-series">
<h4 id="c_65588">Non-occluding quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of quads that are not candidates for being
hidden surface removal occluders. To be eligible, a quad must be guaranteed to
be opaque and resolvable at early ZS.</p>
<p>Draw calls that use blending, shader discard, alpha-to-coverage, programmable
depth, or programmable tile buffer access can not be occluders. Aim to minimize
the number of transparent quads by disabling blending when it is not required.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragTransparentQd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliFragRastQd - MaliFragEZSKillQd - MaliFragOpaqueQd</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliFragmentQuadsRasterizedFineQuads - $MaliFragmentZSQuadsEarlyZSKilledQuads - $MaliFragmentFPKHSRQuadsOccludingQuads</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>FRAG_QUADS_RAST - FRAG_QUADS_EZS_KILL - QUAD_FPK_KILLER</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_225">Occluding quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad that is a valid occluder for hidden
surface removal. To be a candidate occluder, a quad must be guaranteed to be
opaque and have fulled resolved at early ZS.</p>
<p>Draw calls that use blending, shader discard, alpha-to-coverage, programmable
depth, or programmable tile buffer access can not be occluders.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragOpaqueQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentFPKHSRQuadsOccludingQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>QUAD_FPK_KILLER</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_fragmentworkloadproperties">Fragment Workload Properties <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows properties of the fragment front-end workload that can
identify specific application optimization opportunities.</p>
<div class="lgc-series">
<h4 id="c_65577">Partial coverage rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of fragment quads that contain samples
with no coverage. A high percentage can indicate that the content has a high
density of small triangles, which are expensive to process. To avoid this, use
mesh level-of-detail algorithms to select simpler meshes as objects move
further from the camera.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragRastPartQdRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragRastPartQd / MaliFragRastQd) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentQuadsPartialRasterizedFineQuads / $MaliFragmentQuadsRasterizedFineQuads) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_PARTIAL_QUADS_RAST / FRAG_QUADS_RAST) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65586">Unchanged tile kill rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of tiles that are killed by the
transaction elimination CRC check because the content of a tile matches the
content already stored in memory.</p>
<p>A high percentage of tile writes being killed indicates that a significant part
of the framebuffer is static from frame to frame. Consider using scissor
rectangles to reduce the area that is redrawn. To help manage the partial frame
updates for window surfaces consider using the EGL extensions such as:</p>
<ul>
<li>EGL_KHR_partial_update</li>
<li>EGL_EXT_swap_buffers_with_damage</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragTileKillRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragTileKill / (4 * MaliFragTile)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentTilesKilledUnchangedTiles / (4 * $MaliFragmentTilesTiles)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_TRANS_ELIM / (4 * FRAG_PTILES)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercoreprogrammablecore">Shader Core Programmable Core <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The programmable core is responsible for executing shader programs. This
generation of Arm GPUs are warp-based, scheduling multiple threads from the
same program in lockstep to improve energy efficiency.</p>
<p>The programmable core is a massively multi-threaded core, allowing many
concurrently resident warps, which provides a level of tolerance to cache
misses and data fetch latency. For most applications having more threads
resident improves performance, as it increases the number of threads available
for latency hiding, but it might decrease performance if the additional threads
cause cache thrashing.</p>
<p>The core is built from a multiple independent hardware units, which can be
simultaneously processing workloads from any of the resident threads. The most
heavily loaded unit will set the upper bound on performance, with the other
units running in parallel to it.</p>
<p>Performance counters in this section show the overall utilization of the
different hardware units, making it easier to identify the units that are
likely to be on the critical path.</p>
<div class="lgc-group">
<h3 id="g_shadercoreunitutilization">Shader Core Unit Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the use of each of the functional units inside the
shader core, relative to their speed-of-light capability.</p>
<p>These units can run in parallel, and well performing content can expect peak
load to be above 80% utilization on the most heavily used units. In this
scenario reducing use of those units is likely to improve application
performance.</p>
<p>If no unit is heavily loaded, it implies that the shader core is starving for
work. This can be because not enough threads are getting spawned by the
front-end, or because threads in the core are blocked on memory access. Other
counters can help determine which of these situations is occurring.</p>
<div class="lgc-series">
<h4 id="c_65643">Arithmetic unit utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the arithmetic unit in
the programmable core.</p>
<p>The most effective technique for reducing arithmetic load is reducing the
complexity of your shader programs. Using narrower 8 and 16-bit data types can
also help, as it allows multiple operations to be processed in parallel.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliALUUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((max(MaliEngFMAInstr + MaliEngCVTInstr + MaliEngSFUInstr, MaliEngSFUInstr * 4) / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((max($MaliALUInstructionsFMAPipeInstructions + $MaliALUInstructionsCVTPipeInstructions + $MaliALUInstructionsSFUPipeInstructions, $MaliALUInstructionsSFUPipeInstructions * 4) / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((max(EXEC_INSTR_FMA + EXEC_INSTR_CVT + EXEC_INSTR_SFU, EXEC_INSTR_SFU * 4) / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65646">Load/store unit utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the load/store unit. The
load/store unit is used for general-purpose memory accesses, including vertex
attribute access, buffer access, work group shared memory access, and stack
access. This unit also implements imageLoad/Store and atomic access
functionality.</p>
<p>For traditional graphics content the most significant contributor to load/store
usage is vertex data. Arm recommends simplifying mesh complexity, using fewer
triangles, fewer vertices, and fewer bytes per vertex.</p>
<p>Shaders that spill to stack are also expensive, as any spilling is multiplied
by the large number of parallel threads that are running. You can use the Mali
Offline Compiler to check your shaders for spilling.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliLSFullRd + MaliLSPartRd + MaliLSFullWr + MaliLSPartWr + MaliLSAtomic) / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliLoadStoreUnitCyclesFullReads + $MaliLoadStoreUnitCyclesPartialReads + $MaliLoadStoreUnitCyclesFullWrites + $MaliLoadStoreUnitCyclesPartialWrites + $MaliLoadStoreUnitCyclesAtomicAccesses) / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((LS_MEM_READ_FULL + LS_MEM_READ_SHORT + LS_MEM_WRITE_FULL + LS_MEM_WRITE_SHORT + LS_MEM_ATOMIC) / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65645">Varying unit utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the varying unit.</p>
<p>The most effective technique for reducing varying load is reducing the number
of interpolated values read by the fragment shading. Increasing shader usage of
16-bit input variables also helps, as they can be interpolated as twice the
speed of 32-bit variables.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVarUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((((MaliVar32IssueSlot / 2) + (MaliVar16IssueSlot / 2)) / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(((($MaliVaryingUnitRequests32BitInterpolationSlots / 2) + ($MaliVaryingUnitRequests16BitInterpolationSlots / 2)) / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((((VARY_SLOT_32 / 2) + (VARY_SLOT_16 / 2)) / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65644">Texture unit utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the texturing unit.</p>
<p>The most effective technique for reducing texturing unit load is reducing the
number of texture samples read by your shaders. Using 32bpp color formats, and
the ASTC decode mode extensions to select a 32bpp intermediate precision, can
reduce cache access cost. Using simpler texture filters can reduce filtering
cost. Using a 16bit per component sampler result can reduce data return cost.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliTexFiltIssueCy / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliTextureUnitCyclesFilteringActive / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((TEX_FILT_NUM_OPERATIONS / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_shadercorestallcycles">Shader Core Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles that the shader core is able to
accept new warps, but the front-end has no new warp ready to run. This might be
because the front-end is a bottleneck, or because the workload requires no
warps to be spawned.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_236">Execution engine starvation <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the processing unit is starved
of work because all warps are blocked on message dependencies or instruction
cache misses.</p>
<p>This counter increments per fetch unit, and so can increase by up to 4 in a
clock cycle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngStarveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreStallCyclesExecutionEngineStarvation</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_STARVE_ARITH</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercoreworkload">Shader Core Workload <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The programmable core runs the shader program threads that generate the desired
application output.</p>
<p>Performance counters in this section show how the programmable core converts
incoming work into the threads and warps running in the shader core, as well as
other important properties of the running workload such as warp divergence.</p>
<div class="lgc-group">
<h3 id="g_shaderwarps">Shader Warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of warps created, split by type. This can
help you to understand the running workload mix.</p>
<div class="lgc-series">
<h4 id="c_228">Non-fragment warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every created non-fragment warp. For this GPU, a
warp contains <a href="#c_65649">16</a> threads.</p>
<p>For compute shaders, to ensure full utilization of the warp capacity, work
groups must be a multiple of warp size.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliNonFragWarp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderWarpsNonFragmentWarps</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>COMPUTE_WARPS</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_214">Fragment warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every created fragment warp. For this GPU, a warp
contains <a href="#c_65649">16</a> threads.</p>
<p>Fragment warps are populated with fragment quads, where each quad corresponds
to a 2x2 fragment region from a single triangle. Threads in a quad which
correspond to a sample point outside of the triangle still consume shader
resource, which makes small triangles disproportionately expensive.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragWarp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderWarpsFragmentWarps</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_WARPS</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_232">Full warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every warp that has a full thread slot allocation.
Note that allocated thread slots might not contain a running thread if the
workload cannot fill the whole allocation.</p>
<p>If many warps are not fully allocated then performance is reduced. Fully
allocated warps are more likely if:</p>
<ul>
<li>Draw calls avoid late ZS dependency hazards.</li>
<li>Draw calls use meshes with a low percentage of tiny primitives.</li>
<li>Compute dispatches use work groups that are a multiple of warp size.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreFullWarp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderWarpsFullWarps</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FULL_QUAD_WARPS</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_231">All register warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every warp that requires more than 32 registers.
Threads which require more than 32 registers consume two thread slots in the
register file, halving the number of threads that can be concurrently active in
the shader core.</p>
<p>Reduction in thread count can impact the ability of the shader core to keep
functional units busy, and means that performance is more likely to be impacted
by stalls caused by cache misses.</p>
<p>Aim to minimize the number of threads requiring more than 32 registers, by
using simpler shader programs and lower precision data types.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreAllRegsWarp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderWarpsAllRegisterWarps</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>WARP_REG_SIZE_64</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shaderthreads">Shader Threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of threads created, split by type. This can
help you to understand the running workload mix.</p>
<p>Counters in this group are derived by scaling quad or warp counters, and their
counts will include unused thread slots in the coarser granule.</p>
<div class="lgc-series">
<h4 id="c_65591">Non-fragment threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of non-fragment threads started.</p>
<p>The expression is an approximation, based on the assumption that all warps are
fully populated with threads. The <a href="#c_232">Full warps</a> counter can
give some indication of warp occupancy.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliNonFragThread</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliNonFragWarp * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderWarpsNonFragmentWarps * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>COMPUTE_WARPS * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65572">Fragment threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of fragment threads started. This
expressions an approximation, based on the assumption that all warps are fully
populated with threads. The <a href="#c_217">Partial rasterized fine quads</a>
and <a href="#c_232">Full warps</a> counters can give some indication of how
close this approximation is.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragThread</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliFragWarp * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderWarpsFragmentWarps * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>FRAG_WARPS * 16</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shaderworkloadproperties">Shader Workload Properties <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows interesting properties of the running shader code,
most of which highlight an interesting optimization opportunity.</p>
<div class="lgc-series">
<h4 id="c_65598">Full warp rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of warps that have a full thread slot
allocation. Note that allocated thread slots might not contain a running thread
if the workload cannot fill the whole allocation.</p>
<p>If a high percentage of warps are not fully allocated then performance is
reduced. Fully allocated warps are more likely if:</p>
<ul>
<li>Draw calls avoid late ZS dependency hazards.</li>
<li>Draw calls use meshes with a low percentage of tiny primitives.</li>
<li>Compute dispatches use work groups that are a multiple of warp size.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreFullWarpRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCoreFullWarp / (MaliNonFragWarp + MaliFragWarp)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderWarpsFullWarps / ($MaliShaderWarpsNonFragmentWarps + $MaliShaderWarpsFragmentWarps)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FULL_QUAD_WARPS / (COMPUTE_WARPS + FRAG_WARPS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65597">All registers warp rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of warps that use more than 32
registers, requiring the full register allocation of 64 registers. Warps that
require more than 32 registers halve the peak thread occupancy of the shader
core, and can make shader performance more sensitive to cache misses and memory
stalls.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreAllRegsWarpRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCoreAllRegsWarp / (MaliNonFragWarp + MaliFragWarp)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderWarpsAllRegisterWarps / ($MaliShaderWarpsNonFragmentWarps + $MaliShaderWarpsFragmentWarps)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((WARP_REG_SIZE_64 / (COMPUTE_WARPS + FRAG_WARPS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65599">Warp divergence rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of instructions that have control flow
divergence across the warp.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngDivergedInstrRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngDivergedInstr / (MaliEngFMAInstr + MaliEngCVTInstr + MaliEngSFUInstr)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliALUInstructionsDivergedInstructions / ($MaliALUInstructionsFMAPipeInstructions + $MaliALUInstructionsCVTPipeInstructions + $MaliALUInstructionsSFUPipeInstructions)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_INSTR_DIVERGED / (EXEC_INSTR_FMA + EXEC_INSTR_CVT + EXEC_INSTR_SFU)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65658">Shader blend rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of fragments that use shader-based
blending, rather than the fixed-function blend path. These fragments are caused
by the application using color formats, or advanced blend equations, which the
fixed-function blend path does not support.</p>
<p>Vulkan shaders that use software blending do not show up in this data, because
the blend is inlined in to the main body of the shader program.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngSWBlendRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliEngSWBlendInstr * 4) / MaliFragWarp) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliALUInstructionsBlendShaderInstructions * 4) / $MaliShaderWarpsFragmentWarps) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((CALL_BLEND_SHADER * 4) / FRAG_WARPS) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercorearithmeticunit">Shader Core Arithmetic Unit <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The arithmetic unit in the shader core processes all the arithmetic and logic
operations in the running shader programs.</p>
<p>Performance counters in this section show how the running programs used the
arithmetic units, which may indicate the type of operations that are consuming
the most performance.</p>
<div class="lgc-group">
<h3 id="g_alucycles">ALU Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles when work was issued to the
arithmetic and logic unit.</p>
<div class="lgc-series">
<h4 id="c_556">Arithmetic unit issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of cycles that the arithmetic unit was busy
processing work.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliALUIssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(MaliEngFMAInstr + MaliEngCVTInstr + MaliEngSFUInstr, MaliEngSFUInstr * 4)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max($MaliALUInstructionsFMAPipeInstructions + $MaliALUInstructionsCVTPipeInstructions + $MaliALUInstructionsSFUPipeInstructions, $MaliALUInstructionsSFUPipeInstructions * 4)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(EXEC_INSTR_FMA + EXEC_INSTR_CVT + EXEC_INSTR_SFU, EXEC_INSTR_SFU * 4)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_instructioncache">Instruction Cache <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group monitors the behavior of the instruction cache.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_245">I-cache misses <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction cache miss.</p>
<p>Note that the instruction cache is shared across both processing units. Unlike
most processing unit counters this counter increments for cache misses from
both units.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngICacheMiss</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliInstructionCacheICacheMisses</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_ICACHE_MISS</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_aluinstructions">ALU Instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group gives a breakdown of the types of arithmetic instructions
being used by the shader program.</p>
<div class="lgc-series">
<h4 id="c_65668">Executed instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of total instructions issued to any of the
arithmetic pipe types.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngArithInstr</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliEngFMAInstr + MaliEngCVTInstr + MaliEngSFUInstr</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliALUInstructionsFMAPipeInstructions + $MaliALUInstructionsCVTPipeInstructions + $MaliALUInstructionsSFUPipeInstructions</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>EXEC_INSTR_FMA + EXEC_INSTR_CVT + EXEC_INSTR_SFU</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_241">FMA pipe instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction issued to the fused
multiply-accumulate pipe.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngFMAInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUInstructionsFMAPipeInstructions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_INSTR_FMA</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_242">CVT pipe instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction issued to the convert pipe.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngCVTInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUInstructionsCVTPipeInstructions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_INSTR_CVT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_243">SFU pipe instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction issued to the special functions
unit pipe.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngSFUInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUInstructionsSFUPipeInstructions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_INSTR_SFU</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_235">Diverged instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction the programmable core processes
per warp where there is control flow divergence across the warp. Control flow
divergence erodes arithmetic processing efficiency because it implies some
threads in the warp are idle because they did not take the current control path
through the code. Aim to minimize control flow divergence when designing shader
effects.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngDivergedInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUInstructionsDivergedInstructions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_INSTR_DIVERGED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_247">Blend shader instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every blend shader invocation run.</p>
<p>This counter increments per fetch unit, and so can increase by up to 4 in a
clock cycle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngSWBlendInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUInstructionsBlendShaderInstructions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CALL_BLEND_SHADER</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_aluutilization">ALU Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group gives a breakdown of the usage of the different arithmetic
sub-units, relative to their speed-of-light performance.</p>
<p>Due to shared issue data paths, it might not be possible for individual ALU
units to reach their speed-of-light if the other ALU hardware units are also in
use.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65601">FMA pipe utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the fused multiply-accumulate pipeline utilization.</p>
<p>This pipeline shares instruction issue slots with CVT and SFU instructions, so
it is not possible to achieve 100% utilization unless the other pipelines are
idle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngFMAPipeUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngFMAInstr / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliALUInstructionsFMAPipeInstructions / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_INSTR_FMA / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65602">CVT pipe utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the convert pipeline utilization.</p>
<p>This pipeline shares instruction issue slots with FMA and SFU instructions, so
it is not possible to achieve 100% utilization unless the other pipelines are
idle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngCVTPipeUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngCVTInstr / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliALUInstructionsCVTPipeInstructions / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_INSTR_CVT / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65603">SFU pipe utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the special functions unit pipeline utilization.</p>
<p>This pipeline shares instruction issue slots with CVT and SFU instructions, so
it is not possible to achieve 100% utilization unless the other pipelines are
idle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngSFUPipeUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliEngSFUInstr * 4) / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliALUInstructionsSFUPipeInstructions * 4) / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((EXEC_INSTR_SFU * 4) / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercoreloadstoreunit">Shader Core Load/store Unit <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The load/store unit in the shader core handles all generic read/write data
access, including access to vertex attributes, buffers, images, workgroup local
storage, and program stack.</p>
<p>Performance counters in this section show the breakdown of performed load/store
cache accesses, showing whether accesses are using an entire cache line or just
using part of one.</p>
<div class="lgc-group">
<h3 id="g_loadstoreunitcycles">Load/Store Unit Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles when work was issued to the
load/store unit.</p>
<div class="lgc-series">
<h4 id="c_65629">Load/store unit issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of load/store cache access cycles.
This counter ignores secondary effects such as cache misses, so provides the
minimum possible cycle usage.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSIssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliLSFullRd + MaliLSPartRd + MaliLSFullWr + MaliLSPartWr + MaliLSAtomic</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliLoadStoreUnitCyclesFullReads + $MaliLoadStoreUnitCyclesPartialReads + $MaliLoadStoreUnitCyclesFullWrites + $MaliLoadStoreUnitCyclesPartialWrites + $MaliLoadStoreUnitCyclesAtomicAccesses</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>LS_MEM_READ_FULL + LS_MEM_READ_SHORT + LS_MEM_WRITE_FULL + LS_MEM_WRITE_SHORT + LS_MEM_ATOMIC</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65627">Reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of load/store read cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSRdCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliLSFullRd + MaliLSPartRd</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliLoadStoreUnitCyclesFullReads + $MaliLoadStoreUnitCyclesPartialReads</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>LS_MEM_READ_FULL + LS_MEM_READ_SHORT</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_275">Full reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every full-width load/store cache read.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSFullRd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliLoadStoreUnitCyclesFullReads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LS_MEM_READ_FULL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_276">Partial reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every partial-width load/store cache read. Partial
data accesses do not make full use of the load/store cache capability. Merging
short accesses together to make fewer larger requests improves efficiency. To
do this in shader code:</p>
<ul>
<li>Use vector data loads.</li>
<li>Avoid padding in strided data accesses.</li>
<li>Write compute shaders so that adjacent threads in a warp access adjacent
  addresses in memory.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSPartRd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliLoadStoreUnitCyclesPartialReads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LS_MEM_READ_SHORT</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_65628">Writes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of load/store write cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSWrCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliLSFullWr + MaliLSPartWr</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliLoadStoreUnitCyclesFullWrites + $MaliLoadStoreUnitCyclesPartialWrites</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>LS_MEM_WRITE_FULL + LS_MEM_WRITE_SHORT</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_277">Full writes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every full-width load/store cache write.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSFullWr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliLoadStoreUnitCyclesFullWrites</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LS_MEM_WRITE_FULL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_278">Partial writes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every partial-width load/store cache write. Partial
data accesses do not make full use of the load/store cache capability. Merging
short accesses together to make fewer larger requests improves efficiency. To
do this in shader code:</p>
<ul>
<li>Use vector data loads.</li>
<li>Avoid padding in strided data accesses.</li>
<li>Write compute shaders so that adjacent threads in a warp access adjacent
  addresses in memory.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSPartWr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliLoadStoreUnitCyclesPartialWrites</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LS_MEM_WRITE_SHORT</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_279">Atomic accesses <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every atomic access.</p>
<p>Atomic memory accesses are typically multicycle operations per thread in the
warp, so they are exceptionally expensive. Minimize the use of atomics in
performance critical code. For some types of atomic operation, it can be
beneficial to perform a warp-wide reduction using subgroup operations and then
use a single thread to update the atomic value.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSAtomic</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliLoadStoreUnitCyclesAtomicAccesses</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LS_MEM_ATOMIC</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercorevaryingunit">Shader Core Varying Unit <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The varying unit in the shader core handles all vertex data interpolation in
fragment shaders.</p>
<p>Performance counters in this section show the breakdown of performed
interpolation operations.</p>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_varyingunitrequests">Varying Unit Requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of requests made to the varying
interpolation unit.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_280">Interpolation requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every warp-width interpolation operation processed
by the varying unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVarInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliVaryingUnitRequestsInterpolationRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VARY_INSTR</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_324">16-bit interpolation slots <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every 16-bit interpolation slot processed by the
varying unit.</p>
<p>The width of each slot and the number of slots is GPU dependent.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVar16IssueSlot</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliVaryingUnitRequests16BitInterpolationSlots</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VARY_SLOT_16</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_323">32-bit interpolation slots <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every 32-bit interpolation slot processed by the
varying unit. 32-bit interpolation is half the performance of 16-bit
interpolation, so if content is varying bound consider reducing precision of
varying inputs to fragment shaders.</p>
<p>The width of each slot and the number of slots is GPU dependent.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVar32IssueSlot</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliVaryingUnitRequests32BitInterpolationSlots</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VARY_SLOT_32</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_varyingunitcycles">Varying Unit Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles when work was issued to the
varying interpolation unit.</p>
<div class="lgc-series">
<h4 id="c_65630">Varying unit issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of cycles when the varying
interpolator is issuing operations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVarIssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliVar32IssueSlot / 2) + (MaliVar16IssueSlot / 2)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliVaryingUnitRequests32BitInterpolationSlots / 2) + ($MaliVaryingUnitRequests16BitInterpolationSlots / 2)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(VARY_SLOT_32 / 2) + (VARY_SLOT_16 / 2)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_282">16-bit interpolation issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every 16-bit interpolation cycle processed by the
varying unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVar16IssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliVar16IssueSlot / 2</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliVaryingUnitRequests16BitInterpolationSlots / 2</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>VARY_SLOT_16 / 2</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_281">32-bit interpolation issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every 32-bit interpolation cycle processed by the
varying unit. 32-bit interpolation is half the performance of 16-bit
interpolation, so if content is varying bound consider reducing precision of
varying inputs to fragment shaders.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVar32IssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliVar32IssueSlot / 2</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliVaryingUnitRequests32BitInterpolationSlots / 2</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>VARY_SLOT_32 / 2</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercoretextureunit">Shader Core Texture Unit <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The texture unit in the shader core handles all read-only texture access and
filtering.</p>
<p>Performance counters in this section show the breakdown of performed texturing
operations, and use of sub-units inside the texturing hardware.</p>
<div class="lgc-group">
<h3 id="g_textureunitrequests">Texture Unit Requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of requests made to the texture unit.</p>
<div class="lgc-series">
<h4 id="c_65609">Texture samples <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of texture samples made.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexSample</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliTexOutMsg * 8</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliTextureUnitQuadsTextureMessages * 8</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>TEX_MSGO_NUM_MSG * 8</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitquads">Texture Unit Quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of fragment quads submitted to the texture
unit for sampling.</p>
<div class="lgc-series">
<h4 id="c_257">Texture requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad-width texture operation processed by the
texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexQuads</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliTexOutMsg * 2</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliTextureUnitQuadsTextureMessages * 2</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>TEX_MSGO_NUM_MSG * 2</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_315">Texture messages <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every texture message emitted by the texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexOutMsg</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitQuadsTextureMessages</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_MSGO_NUM_MSG</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitcycles">Texture Unit Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles when work was issued to the
sub-units inside the texture unit.</p>
<div class="lgc-series">
<h4 id="c_457">Texture unit issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression measures the number of cycles the texture unit was busy
processing work.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexIssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliTexFiltIssueCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliTextureUnitCyclesFilteringActive</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>TEX_FILT_NUM_OPERATIONS</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_253">Filtering active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every texture filtering issue cycle. This GPU can
do <a href="#c_65610">8</a>x 2D bilinear texture samples per clock. More
complex filtering operations are composed of multiple 2D bilinear samples, and
take proportionally more filtering time to complete. The scaling factors for
more expensive operations are:</p>
<ul>
<li>2D trilinear filtering runs at half speed.</li>
<li>3D bilinear filtering runs at half speed.</li>
<li>3D trilinear filtering runs at quarter speed.</li>
</ul>
<p>Anisotropic filtering makes up to MAX_ANISOTROPY filtered subsamples of the
current base filter type. For example, using trilinear filtering with a
MAX_ANISOTROPY of 3 will require up to 6 bilinear filters.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexFiltIssueCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCyclesFilteringActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_FILT_NUM_OPERATIONS</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_273">Full bilinear filtering active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the filtering unit data path
is running full speed bilinear filtering.</p>
<p>Filtering will run at half rate for formats that are stored in the cache at
more than 32-bits per decompressed texel.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexFullBiFiltCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCyclesFullBilinearFilteringActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_FILT_NUM_FXR_OPERATIONS</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_274">Full trilinear filtering active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the filtering unit data path
is running full speed trilinear filtering.</p>
<p>Filtering will run at half rate for formats that are stored in the cache at
more than 32-bits per decompressed texel.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexFullTriFiltCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCyclesFullTrilinearFilteringActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_FILT_NUM_FST_OPERATIONS</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitstallcycles">Texture Unit Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of stall cycles when work could not be
issued to the sub-units inside the texture unit.</p>
<div class="lgc-series">
<h4 id="c_270">Descriptor stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle a quad is stalled on texture
descriptor fetch. This might not correspond to a stall cycle in the filtering
unit if there is enough work already buffered after the descriptor fetcher to
hide the stall.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexDescStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitStallCyclesDescriptorStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_DFCH_CLK_STALLED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_271">Fetch queue stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle a quad is stalled on entering
texture fetch because the fetch queue is full. This might not correspond to a
stall cycle in the filtering unit if there is enough work already buffered to
hide the stall.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexDataFetchStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitStallCyclesFetchQueueStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_TFCH_CLK_STALLED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_272">Filtering unit stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle the filtering unit is idle and
there is at least one quad present in the texture data fetch queue. A high
stall rate here can be indicative of content which is failing to make good use
of the texture cache. For example, under-sampling from a high resolution
texture.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexFiltStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitStallCyclesFilteringUnitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_TFCH_STARVED_PENDING_DATA_FETCH</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitusagerate">Texture Unit Usage Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the properties of texturing workloads that are being
performed.</p>
<div class="lgc-series">
<h4 id="c_65620">Full speed filter rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of texture filtering cycles using the
full width of the texture filtering data path.</p>
<p>Filtering will run at half rate for formats that are stored in the cache at
more than 32-bits per decompressed texel. When using the ASTC texture format,
use the decode mode extensions to opt-in to a 32-bit per pixel intermediate
format to ensure you can use the full filtering performance.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexFiltFullRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliTexFullBiFiltCy + MaliTexFullTriFiltCy) / MaliTexFiltIssueCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliTextureUnitCyclesFullBilinearFilteringActive + $MaliTextureUnitCyclesFullTrilinearFilteringActive) / $MaliTextureUnitCyclesFilteringActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((TEX_FILT_NUM_FXR_OPERATIONS + TEX_FILT_NUM_FST_OPERATIONS) / TEX_FILT_NUM_OPERATIONS) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitcpi">Texture Unit CPI <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the average cost of texture samples.</p>
<div class="lgc-series">
<h4 id="c_65626">Texture CPI <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of texture filtering cycles per
instruction. For texture-limited content that has a CPI higher than the optimal
throughout of this core (<a href="#c_65610">8</a> samples per cycle), consider
using simpler texture filters. See <a href="#c_457">Texture unit issue
cycles</a> for details of the expected performance for different types of
operation.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexCPI</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliTexFiltIssueCy / (MaliTexOutMsg * 8)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliTextureUnitCyclesFilteringActive / ($MaliTextureUnitQuadsTextureMessages * 8)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>TEX_FILT_NUM_OPERATIONS / (TEX_MSGO_NUM_MSG * 8)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitutilization">Texture Unit Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the use of some of the functional units and data paths
inside the texture unit, relative to their speed-of-light capability.</p>
<div class="lgc-series">
<h4 id="c_65618">Input bus utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage load on the texture message input bus.</p>
<p>If bus utilization is higher than the filtering unit utilization, your content
might be limited by texture operation parameter passing. Requests that require
more input parameters, such as 3D accesses, array accesses, and accesses using
an explicit level-of-detail, place a higher load on the bus than basic 2D
texture operations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexInBusUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliTexInBt / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliTextureUnitBusInputBeats / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((TEX_MSGI_NUM_FLITS / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65619">Output bus utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage load on the texture message output bus.</p>
<p>If bus utilization is higher than the filtering unit utilization, your content
might be limited by texture result return. Requests that require higher
precision sampler return type place a higher load on the bus, so it is
recommended to use a 16-bit sampler precision whenever possible.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexOutBusUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliTexOutBt / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliTextureUnitBusOutputBeats / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((TEX_MSGO_NUM_FLITS / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_textureunitbus">Texture Unit Bus <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bus cycles used on the texture unit
memory bus connecting the texture unit to the rest of the shader core.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_267">Input beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle of input request data sent to the
texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexInBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitBusInputBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_MSGI_NUM_FLITS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_268">Output beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle of output response data sent by
the texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexOutBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitBusOutputBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_MSGO_NUM_FLITS</code>
</div>
</div>
</div>
</div>
<div class="lgc-section lgc-advanced-app">
<h2 id="s_shadercoreotherunits">Shader Core Other Units <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>In addition to the main units, covered in earlier sections, the shader core has
several other units that can be measured.</p>
<p>Performance counters in this section show the workload on these other units.</p>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_attributeunitrequests">Attribute Unit Requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of requests made to the attribute unit.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_283">Attribute requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction run by the attribute unit.</p>
<p>Each instruction converts a logical attribute access into a pointer-based
access, which is then processed by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliAttrInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliAttributeUnitRequestsAttributeRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ATTR_INSTR</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercorememoryaccess">Shader Core Memory Access <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>GPUs are data-plane processors, so understanding your memory bandwidth and
where it is coming from is a critical piece of knowledge when trying to improve
performance.</p>
<p>Performance counters in this section show the breakdown of memory accesses by
shader core hardware unit, showing the total amount of read and write bandwidth
being generated by the shader core.</p>
<p>Read bandwidth is split to show how much was provided by the GPU L2 cache and
how much was provided by the external memory system. Write bandwidth does not
have an equivalent split, and it is not possible to tell from the counters if a
write went to L2 or directly to external memory.</p>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_shadercorel2reads">Shader Core L2 Reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of shader core read transactions served
from the L2 cache, broken down by hardware unit inside the shader core.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_285">Fragment front-end beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the fixed-function
fragment front-end.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusFFEL2RdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2ReadsFragmentFrontEndBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_FTC</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_287">Load/store unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSL2RdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2ReadsLoadStoreUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_LSC</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_289">Texture unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexL2RdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2ReadsTextureUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_TEX</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_291">Other unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by any unit that is not
identified as a specific data destination.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusOtherL2RdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2ReadsOtherUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_OTHER</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_shadercoreexternalreads">Shader Core External Reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of shader core read transactions served
from external memory, broken down by hardware unit inside the shader core.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_286">Fragment front-end beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the fixed-function
fragment front-end that required an external memory access because of an L2
cache miss.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusFFEExtRdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreExternalReadsFragmentFrontEndBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_FTC_EXT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_288">Load/store unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the load/store unit
that required an external memory access because of an L2 cache miss.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSExtRdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreExternalReadsLoadStoreUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_LSC_EXT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_290">Texture unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the texture unit that
required an external memory access because of an L2 cache miss.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexExtRdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreExternalReadsTextureUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_TEX_EXT</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_shadercorel2writes">Shader Core L2 Writes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of shader core write transactions, broken
down by hardware unit inside the shader core.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_292">Load/store unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write beat sent by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSWrBt</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusLSWBWrBt + MaliSCBusLSOtherWrBt</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreL2WritesLoadStoreUnitWriteBackBeats + $MaliShaderCoreL2WritesLoadStoreUnitOtherBeats</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_WR_LSC_WB + BEATS_WR_LSC_OTHER</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_293">Load/store unit write-back beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write beat by the load/store unit that are
because of write-back.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSWBWrBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2WritesLoadStoreUnitWriteBackBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_WR_LSC_WB</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_294">Load/store unit other beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write beat by the load/store unit that are
because of any reason other than write-back.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSOtherWrBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2WritesLoadStoreUnitOtherBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_WR_LSC_OTHER</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_295">Tile unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write beat sent by the tile write-back unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTileWrBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2WritesTileUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_WR_TIB</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shadercorel2readbytes">Shader Core L2 Read Bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes read from the L2 cache by the
shader core, broken down by hardware unit inside the shader core.</p>
<div class="lgc-series">
<h4 id="c_65659">Fragment front-end bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the L2 memory
system by the fragment front-end.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusFFEL2RdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusFFEL2RdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreL2ReadsFragmentFrontEndBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_FTC * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65631">Load/store unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the L2 memory
system by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSL2RdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusLSL2RdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreL2ReadsLoadStoreUnitBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_LSC * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65635">Texture unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the L2 memory
system by the texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexL2RdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusTexL2RdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreL2ReadsTextureUnitBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_TEX * 16</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shadercoreexternalreadbytes">Shader Core External Read Bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes read from external memory by the
shader core, broken down by hardware unit inside the shader core.</p>
<div class="lgc-series">
<h4 id="c_65660">Fragment front-end bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the external memory
system by the fragment front-end.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusFFEExtRdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusFFEExtRdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreExternalReadsFragmentFrontEndBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_FTC_EXT * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65633">Load/store unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the external memory
system by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSExtRdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusLSExtRdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreExternalReadsLoadStoreUnitBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_LSC_EXT * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65637">Texture unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the external memory
system by the texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexExtRdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusTexExtRdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreExternalReadsTextureUnitBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_TEX_EXT * 16</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shadercorel2writebytes">Shader Core L2 Write Bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes written by the shader core, broken
down by hardware unit inside the shader core.</p>
<p>These writes are written to the L2 memory system, but counters cannot determine
if the write was written to the L2 cache or directly to external memory.</p>
<div class="lgc-series">
<h4 id="c_65639">Load/store unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes written to the L2 memory
system by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSWrBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusLSWBWrBt + MaliSCBusLSOtherWrBt) * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreL2WritesLoadStoreUnitWriteBackBeats + $MaliShaderCoreL2WritesLoadStoreUnitOtherBeats) * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_WR_LSC_WB + BEATS_WR_LSC_OTHER) * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65642">Tile unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes written to the L2 memory
system by the tile write-back unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTileWrBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusTileWrBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreL2WritesTileUnitBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_WR_TIB * 16</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_loadstoreunitbytescycle">Load/Store Unit Bytes/Cycle <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes accessed in the L2 cache and
external memory per load/store cache access cycle. This gives some measure of
how effectively the GPU is caching load/store data.</p>
<div class="lgc-series">
<h4 id="c_65632">L2 read bytes/cy <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes read from the L2 memory
system by the load/store unit per read cycle. This metric gives some idea how
effectively data is being cached in the L1 load/store cache.</p>
<p>If more bytes are being requested per access than you would expect for the data
layout you are using, review your data layout and access patterns.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSL2RdByPerRd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusLSL2RdBt * 16) / (MaliLSFullRd + MaliLSPartRd)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreL2ReadsLoadStoreUnitBeats * 16) / ($MaliLoadStoreUnitCyclesFullReads + $MaliLoadStoreUnitCyclesPartialReads)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_RD_LSC * 16) / (LS_MEM_READ_FULL + LS_MEM_READ_SHORT)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65641">L2 write bytes/cy <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes written to the L2 memory
system by the load/store unit per write cycle.</p>
<p>If more bytes are being written per access than you would expect for the data
layout you are using, review your data layout and access patterns to improve
cache locality.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSWrByPerWr</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>((MaliSCBusLSWBWrBt + MaliSCBusLSOtherWrBt) * 16) / (MaliLSFullWr + MaliLSPartWr)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>(($MaliShaderCoreL2WritesLoadStoreUnitWriteBackBeats + $MaliShaderCoreL2WritesLoadStoreUnitOtherBeats) * 16) / ($MaliLoadStoreUnitCyclesFullWrites + $MaliLoadStoreUnitCyclesPartialWrites)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>((BEATS_WR_LSC_WB + BEATS_WR_LSC_OTHER) * 16) / (LS_MEM_WRITE_FULL + LS_MEM_WRITE_SHORT)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65634">External read bytes/cy <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes read from the external
memory system by the load/store unit per read cycle. This metric indicates how
effectively data is being cached in the L2 cache.</p>
<p>If more bytes are being requested per access than you would expect for the data
layout you are using, review your data layout and access patterns.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSExtRdByPerRd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusLSExtRdBt * 16) / (MaliLSFullRd + MaliLSPartRd)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreExternalReadsLoadStoreUnitBeats * 16) / ($MaliLoadStoreUnitCyclesFullReads + $MaliLoadStoreUnitCyclesPartialReads)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_RD_LSC_EXT * 16) / (LS_MEM_READ_FULL + LS_MEM_READ_SHORT)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitbytescycle">Texture Unit Bytes/Cycle <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes accessed in the L2 cache and
external memory per texture sample. This gives some measure of how effectively
the GPU is caching texture data.</p>
<div class="lgc-series">
<h4 id="c_65636">L2 read bytes/cy <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes read from the L2 memory
system by the texture unit per filtering cycle. This metric indicates how
effectively textures are being cached in the L1 texture cache.</p>
<p>If more bytes are being requested per access than you would expect for the
format you are using, review your texture settings. Arm recommends:</p>
<ul>
<li>Using mipmaps for offline generated textures.</li>
<li>Using ASTC or ETC compression for offline generated textures.</li>
<li>Replacing runtime framebuffer formats with narrower formats.</li>
<li>Reducing use of imageLoad/Store to allow framebuffer compression.</li>
<li>Reducing use of negative LOD bias used for texture sharpening.</li>
<li>Reducing use of anisotropic filtering, or reducing the level of
  MAX_ANISOTROPY used.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexL2RdByPerRd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusTexL2RdBt * 16) / MaliTexFiltIssueCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreL2ReadsTextureUnitBeats * 16) / $MaliTextureUnitCyclesFilteringActive</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_RD_TEX * 16) / TEX_FILT_NUM_OPERATIONS</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65638">External read bytes/cy <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes read from the external
memory system by the texture unit per filtering cycle. This metric indicates
how effectively textures are being cached in the L2 cache.</p>
<p>If more bytes are being requested per access than you would expect for the
format you are using, review your texture settings. Arm recommends:</p>
<ul>
<li>Using mipmaps for offline generated textures.</li>
<li>Using ASTC or ETC compression for offline generated textures.</li>
<li>Replacing runtime framebuffer formats with narrower formats.</li>
<li>Reducing use of imageLoad/Store to allow framebuffer compression.</li>
<li>Reducing use of negative LOD bias used for texture sharpening.</li>
<li>Reducing use of anisotropic filtering, or reducing the level of
  MAX_ANISOTROPY used.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexExtRdByPerRd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusTexExtRdBt * 16) / MaliTexFiltIssueCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreExternalReadsTextureUnitBeats * 16) / $MaliTextureUnitCyclesFilteringActive</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_RD_TEX_EXT * 16) / TEX_FILT_NUM_OPERATIONS</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_tileunitbytespixel">Tile Unit Bytes/Pixel <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes written by the tile unit per
output pixel. This can be used to determine the efficiency of application
render pass store configuration.</p>
<p>Applications can minimize the number of bytes stored by following best
practices:</p>
<ul>
<li>Use the smallest pixel color format that meets your requirements.</li>
<li>Discard transient attachments that are no longer required at the end of
  each render pass (Vulkan storeOp=DONT_CARE or storeOp=NONE).</li>
<li>Use resolve attachments to resolve multi-sampled data into a single value
  as part of tile write-back and discard the multi-sampled data so that it is
  not written back to memory.</li>
</ul>
<div class="lgc-series">
<h4 id="c_544">External write bytes/px <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes written to the L2 memory
system by the tile unit per output pixel.</p>
<p>If more bytes are being written per pixel than expected, Arm recommends:</p>
<ul>
<li>Using narrower attachment color formats with fewer bytes per pixel.</li>
<li>Configuring attachments so that they can use framebuffer compression.</li>
<li>Invalidating transient attachments to skip writing to memory.</li>
<li>Using inline multi-sample resolve to skip writing the multi-sampled data to
  memory.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTileWrBPerPx</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusTileWrBt * 16) / (MaliFragQueueTask * 1024)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreL2WritesTileUnitBeats * 16) / ($MaliGPUTasksFragmentTasks * 1024)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_WR_TIB * 16) / (ITER_FRAG_TASK_COMPLETED * 1024)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_tiling">Tiling <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The tiler hardware orchestrates vertex shading, and binning primitives into the
tile lists read during fragment shading.</p>
<p>Performance counters in this section show how the tiler processed the
binning-time vertex and primitive workload.</p>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_tilerstallcycles">Tiler Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles that individual sub-units inside
the tiler were stalled.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_162">Position FIFO full stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the tiler has a position shading
request that it can not send to a shader core because the position buffer is
full.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerPosShadFIFOFullCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerStallCyclesPositionFIFOFullStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>IDVS_POS_FIFO_FULL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_161">Position shading stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the tiler has a position shading
request that it can not send to a shader core because the shading request queue
is full.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerPosShadStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerStallCyclesPositionShadingStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>IDVS_POS_SHAD_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_176">Varying shading stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the tiler has a varying shading
request that it can not send to a shader core because the shading request queue
is full.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerVarShadStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerStallCyclesVaryingShadingStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>IDVS_VAR_SHAD_STALL</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_tilervertexcache">Tiler Vertex Cache <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of accesses made into the vertex position
and varying post-transform caches.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_164">Position cache hits <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every time a vertex position lookup hits in the vertex
cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerPosCacheHit</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerVertexCachePositionCacheHits</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VCACHE_HIT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_165">Position cache misses <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every time a vertex position lookup misses in the
vertex cache. Cache misses at this stage result in a position shading request,
although a single request can produce data to handle multiple cache misses.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerPosCacheMiss</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerVertexCachePositionCacheMisses</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VCACHE_MISS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_172">Varying cache hits <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every time a vertex varying lookup results in a
successful hit in the vertex cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerVarCacheHit</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerVertexCacheVaryingCacheHits</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>IDVS_VBU_HIT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_173">Varying cache misses <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every time a vertex varying lookup misses in the vertex
cache. Cache misses at this stage result in a varying shading request, although
a single request can produce data to handle multiple cache misses.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerVarCacheMiss</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerVertexCacheVaryingCacheMisses</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>IDVS_VBU_MISS</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_tilerl2accesses">Tiler L2 Accesses <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of tiler memory transactions into the L2
memory system.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_154">Read beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data read cycle the tiler uses on the
internal bus.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerRdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerL2AccessesReadBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BUS_READ</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_tilershadingrequests">Tiler Shading Requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group tracks the number of shading requests that are made by the
tiler when processing vertex shaders.</p>
<p>Application vertex shaders are split into two pieces, a position shader that
computes the vertex position, and a varying shader that computes the remaining
vertex shader outputs. The varying shader is only run if a group contains
visible vertices that survive primitive culling.</p>
<div class="lgc-series">
<h4 id="c_159">Position shading requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every position shading request in the tiler
geometry flow. Position shading runs the first part of the vertex shader,
computing the position required to perform clipping and culling. A vertex that
has been evicted from the post-transform cache must be reshaded if used again,
so your index buffers must have good spatial locality of index reuse.</p>
<p>Each request contains <a href="#c_65564">4</a> vertices.</p>
<p>Note that not all types of draw call use this tiler workflow, so this counter
might not account for all submitted geometry.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomPosShadTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerShadingRequestsPositionShadingRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>IDVS_POS_SHAD_REQ</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_175">Varying shading requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every varying shading request in the tiler geometry
flow. Varying shading runs the second part of the vertex shader, for any
primitive that survives clipping and culling. The same vertex is shaded
multiple times if it has been evicted from the post-transform cache before
reuse occurs. Keep good spatial locality of index reuse in your index buffers.</p>
<p>Each request contains <a href="#c_65564">4</a> vertices.</p>
<p>Note that not all types of draw call use this tiler workflow, so this counter
might not account for all submitted geometry.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomVarShadTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerShadingRequestsVaryingShadingRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>IDVS_VAR_SHAD_REQ</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_vertexcachehitrate">Vertex Cache Hit Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the hit rate in the tiler post-transform caches.</p>
<div class="lgc-series">
<h4 id="c_65663">Position read hit rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage hit rate of the tiler position cache
used for the index-driven vertex shading pipeline.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerPosCacheHitRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliTilerPosCacheHit / (MaliTilerPosCacheHit + MaliTilerPosCacheMiss)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliTilerVertexCachePositionCacheHits / ($MaliTilerVertexCachePositionCacheHits + $MaliTilerVertexCachePositionCacheMisses)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((VCACHE_HIT / (VCACHE_HIT + VCACHE_MISS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65664">Varying read hit rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage hit rate of the tiler varying cache used
for the index-driven vertex shading pipeline.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerVarCacheHitRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliTilerVarCacheHit / (MaliTilerVarCacheHit + MaliTilerVarCacheMiss)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliTilerVertexCacheVaryingCacheHits / ($MaliTilerVertexCacheVaryingCacheHits + $MaliTilerVertexCacheVaryingCacheMisses)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((IDVS_VBU_HIT / (IDVS_VBU_HIT + IDVS_VBU_MISS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_internalmemorysystem">Internal Memory System <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The GPU internal memory interface connects the processing units, such as the
shader cores and the tiler, to the GPU L2 cache.</p>
<p>Performance counters in this section show reads and writes into the L2 cache
and how the cache responded to them.</p>
<div class="lgc-group lgc-advanced-app lgc-advanced-sys">
<h3 id="g_l2cacherequests">L2 Cache Requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of requests made into the L2 cache
from any source. This includes any requests made</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_94">Read requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read request received by the L2 cache from an
internal requester.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheRd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsReadRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_IN</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_98">Write requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write request received by the L2 cache from
an internal requester.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheWr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsWriteRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_WR_MSG_IN</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_100">Snoop requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every coherency snoop request received by the L2
cache from internal requesters.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheSnp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsSnoopRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_SNP_MSG_IN</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_96">Clean unique requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every line clean unique request received by the L2
cache from an internal requester.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheCleanUnique</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsCleanUniqueRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_IN_CU</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_95">Evict requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every line evict request received by the L2 cache
from an internal requester.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheEvict</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsEvictRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_IN_EVICT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_102">L1 read requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L1 cache read request or read response sent
by the L2 cache to an internal requester.</p>
<p>Read requests are triggered by a snoop request from one requester that needs
data from another requester's L1 to resolve.</p>
<p>Read responses are standard responses back to a requester in response to its
own read requests.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheL1Rd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsL1ReadRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_OUT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_106">L1 write requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L1 cache write response sent by the L2 cache
to an internal requester.</p>
<p>Write responses are standard responses back to a requester in response to its
own write requests.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheL1Wr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsL1WriteRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_WR_MSG_OUT</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_l2cachelookups">L2 Cache Lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of lookups made into the L2 cache
from any source.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_107">Any lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L2 cache lookup made, including all reads,
writes, coherency snoops, and cache flush operations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheLookup</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheLookupsAnyLookups</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_ANY_LOOKUP</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_108">Read lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L2 cache read lookup made.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheRdLookup</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheLookupsReadLookups</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_READ_LOOKUP</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_109">Write lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L2 cache write lookup made.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheWrLookup</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheLookupsWriteLookups</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_WRITE_LOOKUP</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_110">External snoop lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every coherency snoop lookup performed that is
triggered by a requester outside of the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheSnpLookup</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheLookupsExternalSnoopLookups</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_SNOOP_LOOKUP</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_l2cachestallcycles">L2 Cache Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of stall cycles that impact L2 cache
lookups.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_97">Read stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle an L2 cache read request from an
internal requester is stalled.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheRdStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheStallCyclesReadStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_IN_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_99">Write stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when an L2 cache write request
from an internal requester is stalled.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheWrStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheStallCyclesWriteStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_WR_MSG_IN_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_101">Snoop stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when an L2 cache coherency snoop
request from an internal requester is stalled.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheSnpStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheStallCyclesSnoopStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_SNP_MSG_IN_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_105">L1 read stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when L1 cache read requests and
responses sent by the L2 cache to an internal requester are stalled.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheL1RdStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheStallCyclesL1ReadStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_OUT_STALL</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_l2cachemissrate">L2 Cache Miss Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the miss rate in the L2 cache.</p>
<div class="lgc-series">
<h4 id="c_65547">Read miss rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of internal L2 cache reads that result
in an external read.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheRdMissRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliExtBusRd / MaliL2CacheRdLookup) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliExternalBusAccessesReadTransactions / $MaliL2CacheLookupsReadLookups) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((L2_EXT_READ / L2_READ_LOOKUP) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65552">Write miss rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of internal L2 cache writes that result
in an external write.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheWrMissRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliExtBusWr / MaliL2CacheWrLookup) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliExternalBusAccessesWriteTransactions / $MaliL2CacheLookupsWriteLookups) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((L2_EXT_WRITE / L2_WRITE_LOOKUP) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_stage1mmutranslations">Stage 1 MMU Translations <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of stage 1 page table lookups handled by
the GPU MMU.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_84">MMU lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every address lookup made by the main GPU MMU.
Increments only occur if all lookups into a local TLB miss.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMMULookup</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliStage1MMUTranslationsMMULookups</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MMU_REQUESTS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_86">L2 table reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read of a level 2 MMU translation table
entry. Each address translation at this level covers a 2MB section, which is
typically broken down into further into 4KB pages using a subsequent level 3
translation table lookup.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMMUL2Rd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliStage1MMUTranslationsL2TableReads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MMU_TABLE_READS_L2</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_88">L2 table read hits <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read of a level 2 MMU translation table entry
that results in a successful hit in the main MMU's TLB.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMMUL2Hit</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliStage1MMUTranslationsL2TableReadHits</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MMU_HIT_L2</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_85">L3 table reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read of a level 3 MMU translation table
entry. Each address translation at this level covers a single 4KB page.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMMUL3Rd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliStage1MMUTranslationsL3TableReads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MMU_TABLE_READS_L3</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_87">L3 table read hits <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read of a level 3 MMU translation table entry
that results in a successful hit in the main MMU's TLB.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMMUL3Hit</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliStage1MMUTranslationsL3TableReadHits</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MMU_HIT_L3</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_constants">Constants <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>Arm GPUs are configurable, with variable performance across products, and
variable configurations across devices.</p>
<p>This section lists useful symbolic configuration and constant values that can
be used in expressions to compute derived counters. Note that configuration
values must be provided by a run-time tool that can query the actual
implementation configuration of the target device.</p>
<div class="lgc-group">
<h3 id="g_implementationconfiguration">Implementation Configuration <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This constants group contains symbolic constants that define the configuration
of a particular device. These must be populated by the counter sampling runtime
tooling.</p>
<div class="lgc-series">
<h4 id="c_65655">Shader core count <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This configuration constant defines the number of shader cores in the design.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliConfigCoreCount</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MALI_CONFIG_SHADER_CORE_COUNT</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliConstantsShaderCoreCount</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>MALI_CONFIG_SHADER_CORE_COUNT</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65654">L2 cache slice count <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This configuration constant defines the number of L2 cache slices in the
design.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliConfigL2CacheCount</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MALI_CONFIG_L2_CACHE_COUNT</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliConstantsL2SliceCount</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>MALI_CONFIG_L2_CACHE_COUNT</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65653">External bus beat size <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This configuration constant defines the number of bytes transferred per
external bus beat.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliConfigExtBusBeatSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliConstantsBusWidthBits / 8)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_staticconfiguration">Static Configuration <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This constants group contains literal constants that define the static
configuration and performance characteristics of this product.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65537">Fragment queue task size <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of pixels in each axis per fragment task.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragQueueTaskSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>32</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>32</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>32</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65564">Tiler shader task thread count <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of threads per vertex shading task issued by
the tiler, to perform position shading or varying shading concurrently, for
multiple sequential vertices.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUGeomTaskSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>4</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65647">Tile size <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the size of a tile.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUTileSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>32</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>32</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>32</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65656">Tile storage/pixel <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of bits of color storage per pixel available
when using a <a href="#c_65647">32</a> x <a href="#c_65647">32</a> tile size.
If you use more storage than the available storage for multi-sampling, wide
color formats, or multiple render targets, the driver dynamically reduces the
tile size until sufficient storage is available.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUMaxPixelStorage</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>256</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>256</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>256</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65649">Warp size <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of threads in a single warp.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUWarpSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_322">Varying slot count <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of varying unit slots.</p>
<p>The width of a slot is GPU-dependent.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVarSlotPerCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>2</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>2</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>2</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65610">Texture samples/cycle <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the maximum number of texture samples that can be made
per cycle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexSamplePerCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>8</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>8</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>8</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65611">Texture cycles/sample <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the minimum number of cycles needed to make a texture
sample.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexCyPerSample</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>0.125</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>0.125</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>0.125</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65652">Internal bus beat size <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of bytes transferred per internal bus beat.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusBeatSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
</div>
</div>
</div>
      </div>
      <div class="lgc-footerpanel">
        <p>Copyright &copy; Arm 2025</p>
      </div>
    </div>
  </main>
  <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
    <div id="liveToast" class="toast hide" role="alert">
      <div class="toast-header">
        <strong class="me-auto">Note</strong>
        <button type="button" class="btn-close" data-bs-dismiss="toast"></button>
      </div>
      <div class="toast-body">
        <p>Your address selected an advanced counter, so advanced counters have
           been automatically enabled. They can be disabled in the side menu.</p>
      </div>
    </div>
  </div>
  <script src="./js/bootstrap-5.3.8.bundle.min.js"></script>
  <script src="./js/fontawesome-7.1.0.all.min.js"></script>
  <script src="./js/jquery-3.7.1.min.js"></script>
  <script src="./js/document.js"></script>
</body>
</html>
