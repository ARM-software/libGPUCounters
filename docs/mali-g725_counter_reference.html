<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arm Mali-G725 Performance Counter Reference Guide</title>
  <link href="./css/lato-font.css" rel="stylesheet">
  <link href="./css/bootstrap-5.3.8.min.css" rel="stylesheet">
  <link href="./css/fontawesome-7.1.0.all.min.css" rel="stylesheet">
  <link href="./css/document.css" rel="stylesheet">
</head>
<body>
  <!-- Side menu -->
  <input id="lgc-navtoggle" type="checkbox" class="vh" />
  <input id="lgc-navpin" type="checkbox" class="vh" />
  <aside class="lgc-menupanel lgc-no-print">
    <label class="lgc-toggle" for="lgc-navtoggle" data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Toggle menu"><i class="fa-solid fa-angles-right"></i></label>
    <label class="lgc-pin" for="lgc-navpin" data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Pin menu"><i class="fa-solid fa-thumbtack"></i></label>
    <div class="lgc-menuoptions">
      <div class="lgc-filter form-group">
        <i class="lgc-filter-icon fa-solid fa-filter"></i>
        <input type="search" class="lgc-filter-input rounded-pill form-control form-control-placeholdericon" placeholder="Filter" id="lgc-filterInput" />
      </div>
      <div class="lgc-filter form-group">
        <button class="lgc-menu-controls rounded-pill btn btn-primary" type="button" data-bs-toggle="collapse" data-bs-target="#collapseExample" aria-expanded="true" aria-controls="collapseExample">
          Toggle controls
        </button>
      </div>
      <div class="collapse show" id="collapseExample">
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="checkbox" role="switch" id="lgc-enableAdvancedApp" />
          <label class="form-check-label" for="enableAdvancedApp">Show advanced for applications</label>
          <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Show advanced counters for application developers"><i class="lgc-info-icon fa-solid fa-circle-info"></i></span>
        </div>
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="checkbox" role="switch" id="lgc-enableAdvancedSys" />
          <label class="form-check-label" for="enableAdvancedSys">Show advanced for systems</label>
          <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Show advanced counters for system developers"><i class="lgc-info-icon fa-solid fa-circle-info"></i></span>
        </div>
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="checkbox" role="switch" id="lgc-enableEquations" />
          <label class="form-check-label" for="enableEquations">Show equations</label>
          <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Show source equations for derived counters"><i class="lgc-info-icon fa-solid fa-circle-info"></i></span>
        </div>
        <p class="lgc-menuitem ">Select counter naming convention:</p>
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="radio" name="formatRadios" id="lgc-format-lgc" checked>
          <label class="form-check-label" for="lgc-format-lgc">libGPUCounters format</label>
        </div>
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="radio" name="formatRadios" id="lgc-format-sl">
          <label class="form-check-label" for="lgc-format-sl">Streamline format</label>
        </div>
        <div class="lgc-menuitem form-check form-switch">
          <input class="form-check-input" type="radio" name="formatRadios" id="lgc-format-hw">
          <label class="form-check-label" for="lgc-format-hw">Hardware format</label>
        </div>
      </div>
      <hr class="lgc-menuitem">
    </div>
    <!-- Menu is built on the fly on page load -->
    <div class="lgc-menutree" id="lgc-toc">
    </div>
  </aside>

  <!-- Main page content -->
  <main>
    <div class="lgc-titlepanel">
      <h1>Arm Mali-G725</h1>
      <p><a href="./index.html">Home</a> / Arm Mali-G725 Performance Counter Reference <span class="lgc-filtered-pill badge rounded-pill">Filtered</span></p>
    </div>
    <div class="lgc-mainpanel">
      <div class="lgc-contentpanel">
        <div class="lgc-section">
<h2 id="s_introduction">Introduction</h2>
<p>This guide explains the performance counters for the Mali-G725, which is a
member of the Valhall second generation architecture family.</p>
<p>This introduction section will explain the high level goals to consider when
profiling this GPU. Later sections will explain the available counters for each
part of the GPU design.</p>
<h3>Profiling GPU scheduling</h3>
<p>The GPU runs workloads that have been submitted by the graphics driver, using
scheduling barriers between workloads to ensure they run in the correct order.
Workloads are scheduled to run by adding them to the appropriate hardware
queue, which will run enqueued workloads in a pipelined FIFO processing order.</p>
<p><img alt="5th Generation top-level" src="./images/gen5-csf-top-level.svg" /></p>
<h4>Tile-based rendering</h4>
<p>Arm GPUs are tile-based GPUs, meaning that they process graphics render passes
in two distinct phases. The first phase processes geometry to determine which
primitives contribute to which screen-space tiles. The second phase renders the
output framebuffer tile-by-tile.</p>
<p>In this design, tiles are small enough to be kept in on-chip tile memory, which
makes fragment processing more efficient. This generation of GPUs introduces
deferred vertex shading, which means that the first phase only computes the
primitive binning metadata. Full vertex shading is deferred to the second main
phase. This generation of GPUs is far more bandwidth efficient than earlier Arm
GPUs for geometry heavy scenes.</p>
<h4>GPU queues</h4>
<p>The GPU front-end in this generation of hardware has three hardware queues:</p>
<ul>
<li>Compute queue</li>
<li>Binning phase queue</li>
<li>Main phase queue</li>
</ul>
<p>The Compute queue is used for all compute-like workloads, including compute
shaders, buffer transfers, geometry shaders, and tessellation shaders. The
Binning phase queue is used for computing vertex positions and binning. The
Main queue is used for the main render pass processing, including vertex
shading and fragment shading, and most image transfers.</p>
<p>Monitoring your application's queue usage is the first stage of profiling an
Arm GPU, as the queue costs give the overall processing cost of each type of
workload. In addition you can see if your application is using barriers
efficiently, allowing the queues to run their workloads in parallel.</p>
<h3>Profiling GPU memory bandwidth</h3>
<p>GPUs are data-plane processors, so memory access efficiency is an important
factor for overall performance.</p>
<p><img alt="5th Generation memory system" src="./images/bifrost-memory-system.svg" /></p>
<p>Memory system performance outside of the GPU cannot be directly observed via
GPU performance counters, but the counters can show the performance observed by
the GPU on its memory interface.</p>
<h4>Reducing bandwidth</h4>
<p>Accessing external DRAM is a very energy-intensive operation, which makes
reducing external bandwidth an important optimization goal for mobile devices.
Sustained high bandwidth can cause poor performance in main-stream devices, and
thermal issues in high-end devices.</p>
<p>Shader core performance counters can give you more breakdown about which
functional units are generating memory traffic, guiding your optimization
efforts.</p>
<h4>Reducing stalls</h4>
<p>The memory system outside of the GPU is implemented by the chip manufacturer,
and designs can vary and have different performance characteristics. Workloads
that generate a significant number of memory stall cycles, or that see a large
percentage of high latency reads, might be stressing the external memory system
beyond its capabilities. Reducing memory bandwidth often gives measurable
performance gains in these scenarios.</p>
<h3>Profiling shader core usage</h3>
<p>If the GPU queues are scheduling well, the next thing that you will need to
profile to determine the processing bottleneck of a workload is your
application's use of the shader core.</p>
<p>The Mali-G725 shader cores use a massively multi-threaded architecture,
supporting thousands of concurrently running threads. A large pool of available
threads allows the hardware to fill parallel functional units by switching to
any of the available threads if the current thread becomes blocked for any
reason.</p>
<p><img alt="5th Generation core" src="./images/valhall-execution-core-rtu.svg" /></p>
<p>In this type of architecture, the utilization of the functional units reflects
the overall demand of the running shader programs. This is relatively
independent of localized hot-spots in shaders that stress a single functional
unit, because other threads will be running other parts of the program and will
load-balance the hardware. This is quite different to profiling a CPU, where
the serial instruction stream means that performance can be very sensitive to
both latency and localized hot-spots.</p>
<h3>Improve speed-of-light utilization</h3>
<p>For functional unit profiling, we therefore aim for at least 75% utilization of
the most heavily used functional unit, relative to its best case
'speed-of-light' performance. This shows that the application has done a good
job getting its workload running without problematic stalls.</p>
<p>In this situation, reducing demand on the most heavily used functional units,
either by improving efficiency or reducing size, should improve application
performance.</p>
<h4>Reduce shader core stalls</h4>
<p>If no functional unit is heavily utilized, the shader core is running out of
work to do. This can occur for multiple reasons, and should be avoided if
possible.</p>
<p>The first reason is that the shader is literally running out of threads to run,
and the shader core is running with low thread occupancy. GPUs rely on
workloads having a lot of threads to fill the capacity of the shader core. You
should avoid running small workloads with few threads on the GPU, preferring to
use the CPU if possible. Note that some workloads, such as depth shadow maps,
may not generate many fragment threads due to their algorithmic design. This is
usually unavoidable, but is something to remember when profiling.</p>
<p>The second reason is that the running shader programs are causing operations to
stall by missing in descriptor caches or data caches. GPUs use their thread
count to hide the impact and latency of cache misses, but there are limits to
the density of misses that can be hidden. In this situation, try to identify
which workload is causing stalls and try to minimize them. There are not
specific performance counters for every stall reason, so this can take some
investigation and experimentation to determine which resource is causing the
problem.</p>
<h3>Profiling workload</h3>
<p>In addition to profiling use of the hardware, measuring cycles and bytes, Arm
GPUs provide many performance counters that can help you to understand the size
and characteristics of your workload. These counters gives feedback in the
context of API constructs, such as vertices, triangles, and pixels making it
easier for developers to understand the feedback.</p>
<p><img alt="5th Generation shader core" src="./images/valhall-shader-core.svg" /></p>
<p>Supplementing the workload size counters, Arm GPUs also provide counters that
indicate areas where content is not following best practice guidelines.
Improving these best practice metrics will nearly always improve your
application's performance or energy efficiency.</p>
</div>
<div class="lgc-section">
<h2 id="s_gpufrontend">GPU Front-end <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The GPU front-end is the interface between the GPU hardware and the driver. The
front-end schedules command streams submitted by the driver on to multiple
hardware work queues. Each work queue handles a specific type of workload and
is responsible for breaking a workload into smaller tasks that can be
dispatched to the shader cores. Work stays at the head of the queue while being
processed, so queue activity is a direct way of measuring that the GPU is busy
handling a workload.</p>
<p>In this generation of hardware there are three work queues:</p>
<ul>
<li>Compute queue for compute shaders and advanced geometry shaders.</li>
<li>Binning phase queue for the first phase of a render pass, handling vertex
  position calculation, and primitive culling and binning.</li>
<li>Main phase queue for the second phase of a render pass, handling any
  deferred vertex shading and fragment shading.</li>
</ul>
<p>It is beneficial to schedule work on multiple queues in parallel, as this can
more evenly load balance the hardware. In this generation of hardware the
Compute and Binning phase queues can run in parallel to the Main phase queue,
but serially with respect to each other. Parallel processing will increase the
latency of individual tasks, but usually significantly improves overall
throughput.</p>
<p>Performance counters in this section can show activity on each of the queues,
which indicates the complexity and scheduling patterns of submitted workloads.</p>
<div class="lgc-group">
<h3 id="g_gpucycles">GPU Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the workload processing activity level of the GPU,
showing the overall use and when work was running for each of the hardware
scheduling queues.</p>
<div class="lgc-series">
<h4 id="c_6">GPU active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the GPU has any pending workload
present in one of its processing queues. It shows the overall GPU processing
load requested by the application.</p>
<p>This counter increments when any workload is present in any processing queue,
even if the GPU is stalled waiting for external memory. These cycles are
counted as active time even though no progress is being made.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCyclesGPUActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>GPU_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_1">Any queue active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when any GPU command queue is active
with work for the tiler or shader cores.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUAnyQueueActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCyclesAnyQueueActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>GPU_ITER_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_26">Compute queue active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments every clock cycle when the command stream compute
queue has at least one task issued for processing.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueActiveCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliCompQueuedCy - MaliCompQueueAssignStallCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliGPUQueuedCyclesComputeQueued - $MaliGPUWaitCyclesComputeQueueEndpointStalls</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>ITER_COMP_ACTIVE - ITER_COMP_READY_BLOCKED</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_404">Binning phase queue active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments every clock cycle when the command stream binning
phase queue has at least one task issued for processing. The binning phase
includes vertex position shading and primitive binning.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliBinningQueueActiveCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliBinningQueuedCy - MaliBinningQueueAssignStallCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliGPUQueuedCyclesBinningPhaseQueued - $MaliGPUWaitCyclesBinningPhaseQueueEndpointStalls</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>ITER_TILER_ACTIVE - ITER_TILER_READY_BLOCKED</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_400">Main phase queue active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments every clock cycle when the command stream main phase
queue has at least one task issued for processing. The main phase includes any
deferred vertex processing and all fragment shading.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMainQueueActiveCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliMainQueuedCy - MaliMainQueueAssignStallCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliGPUQueuedCyclesMainPhaseQueued - $MaliGPUWaitCyclesMainPhaseQueueEndpointStalls</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>ITER_FRAG_ACTIVE - ITER_FRAG_READY_BLOCKED</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_139">Tiler active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle the tiler has a workload in its
processing queue. The tiler is responsible for coordinating geometry processing
and providing the fixed-function tiling needed for the Mali tile-based
rendering pipeline. It can run in parallel to vertex shading and fragment
shading.</p>
<p>A high cycle count here does not necessarily imply a bottleneck, unless the <a
href="#c_472">Compute or binning phase active cycles</a> counter in the shader
core is comparatively low.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCyclesTilerActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TILER_ACTIVE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_54">GPU interrupt active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the GPU has an interrupt pending
and is waiting for the CPU to process it.</p>
<p>Cycles with a pending interrupt do not necessarily indicate lost performance
because the GPU can process other queued work in parallel. However, if <a
href="#c_54">GPU interrupt pending cycles</a> are a high percentage of <a
href="#c_6">GPU active cycles</a>, an underlying problem might be preventing
the CPU from efficiently handling interrupts. This problem is normally a system
integration issue, which an application developer cannot work around.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUIRQActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCyclesGPUInterruptActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>GPU_IRQ_ACTIVE</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_gpuqueuedcycles">GPU Queued Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the workload scheduling behavior of the GPU queues,
showing when queues contained work, including cycles where a queue was stalled
and could not start an enqueued workload.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_349">Compute queued <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the command stream compute queue
has work queued. The count includes cycles when the queue is stalled because of
endpoint contention.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueuedCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUQueuedCyclesComputeQueued</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_COMP_ACTIVE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_402">Binning phase queued <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the command stream binning phase
queue has work queued. The binning phase includes vertex position shading,
culling, and primitive binning, and includes cycles when the queue is stalled
because of endpoint contention.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliBinningQueuedCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUQueuedCyclesBinningPhaseQueued</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_TILER_ACTIVE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_398">Main phase queued <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the command stream main phase
queue has work queued. The main phase includes any deferred vertex processing
and all fragment shading, and can include cycles when the queue is stalled
because of endpoint contention.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMainQueuedCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUQueuedCyclesMainPhaseQueued</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_FRAG_ACTIVE</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app lgc-advanced-sys">
<h3 id="g_gpuwaitcycles">GPU Wait Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the workload scheduling behavior of the GPU queues,
showing reasons for any scheduling stalls for each queue.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_32">Compute queue endpoint drain stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when compute work is queued but
cannot start because IDVS work is still active on the shared endpoints.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueDrainStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUWaitCyclesComputeQueueEndpointDrainStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_COMP_EP_DRAIN</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_33">Compute queue endpoint stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when compute work is queued but
cannot start because no endpoints have been assigned.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueAssignStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUWaitCyclesComputeQueueEndpointStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_COMP_READY_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_40">Binning phase queue endpoint drain stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when binning phase work is queued but
cannot start because compute work is still active on the shared endpoints.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerQueueDrainStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUWaitCyclesBinningPhaseQueueEndpointDrainStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_TILER_EP_DRAIN</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_403">Binning phase queue endpoint stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when binning phase work is queued but
cannot start because no endpoints have been assigned. The binning phase
includes vertex position shading and primitive binning.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliBinningQueueAssignStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUWaitCyclesBinningPhaseQueueEndpointStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_TILER_READY_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_399">Main phase queue endpoint stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when main phase work is queued but
cannot start because no endpoints have been assigned. The main phase includes
any deferred vertex processing and all fragment shading.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMainQueueAssignStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUWaitCyclesMainPhaseQueueEndpointStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_FRAG_READY_BLOCKED</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_gpujobs">GPU Jobs <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of workload jobs issued to the GPU
front-end for each queue. Most jobs will correspond to an API workload, for
example a compute dispatch generates a compute job. However, the driver can
also generate small house-keeping jobs for each queue, so job counts do not
directly correlate with API behavior.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_29">Compute jobs <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every job processed by the compute queue.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueJob</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUJobsComputeJobs</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_COMP_JOB_COMPLETED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_448">Binning phase jobs <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every job processed by the binning phase queue.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliBinningQueueJob</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUJobsBinningPhaseJobs</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_TILER_JOB_COMPLETED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_452">Main phase jobs <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every job processed by the main phase queue.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMainQueueJob</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUJobsMainPhaseJobs</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_FRAG_JOB_COMPLETED</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app lgc-advanced-sys">
<h3 id="g_gputasks">GPU Tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of workload tasks issued by the GPU
front-end to the processing end-points inside the GPU.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_30">Compute tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every compute task processed by the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUTasksComputeTasks</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_COMP_TASK_COMPLETED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_449">Binning phase tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every binning phase task processed by the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliBinningQueueTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUTasksBinningPhaseTasks</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_TILER_IDVS_TASK_COMPLETED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_446">Main phase tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every <a href="#c_445">64</a> x <a
href="#c_445">64</a> pixel region of a render pass that is processed by the
GPU. The processed region of a render pass can be smaller than the full size of
the attached surfaces if the application's viewport and scissor settings
prevent the whole image being rendered.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMainQueueTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUTasksMainPhaseTasks</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ITER_FRAG_TASK_COMPLETED</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_gpuutilization">GPU Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the workload processing activity level of the GPU
queues, normalized as a percentage of overall GPU activity.</p>
<div class="lgc-series">
<h4 id="c_65543">Compute queue utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the compute queue utilization compared against the GPU
active cycles.</p>
<p>For GPU bound content, it is expected that the GPU queues process work in
parallel. The dominant queue must be close to 100% utilized to get the best
performance. If no queue is dominant, but the GPU is fully utilized, then a
serialization or dependency problem might be preventing queue overlap.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompQueueUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliCompQueuedCy - MaliCompQueueAssignStallCy) / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliGPUQueuedCyclesComputeQueued - $MaliGPUWaitCyclesComputeQueueEndpointStalls) / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((ITER_COMP_ACTIVE - ITER_COMP_READY_BLOCKED) / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_405">Binning phase queue utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the binning phase queue utilization compared against
the GPU active cycles. The binning phase includes vertex position shading,
culling, and primitive binning.</p>
<p>For GPU bound content, it is expected that the GPU queues process work in
parallel. The dominant queue must be close to 100% utilized to get the best
performance. If no queue is dominant, but the GPU is fully utilized, then a
serialization or dependency problem might be preventing queue overlap.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliBinningQueueUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliBinningQueuedCy - MaliBinningQueueAssignStallCy) / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliGPUQueuedCyclesBinningPhaseQueued - $MaliGPUWaitCyclesBinningPhaseQueueEndpointStalls) / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((ITER_TILER_ACTIVE - ITER_TILER_READY_BLOCKED) / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_401">Main phase queue utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the main phase queue utilization compared against the
GPU active cycles. The main phase includes any deferred vertex processing and
all fragment shading.</p>
<p>For GPU bound content, it is expected that the GPU queues process work in
parallel. The dominant queue must be close to 100% utilized to get the best
performance. If no queue is dominant, but the GPU is fully utilized, then a
serialization or dependency problem might be preventing queue overlap.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMainQueueUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliMainQueuedCy - MaliMainQueueAssignStallCy) / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliGPUQueuedCyclesMainPhaseQueued - $MaliGPUWaitCyclesMainPhaseQueueEndpointStalls) / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((ITER_FRAG_ACTIVE - ITER_FRAG_READY_BLOCKED) / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65545">Tiler utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the tiler utilization compared to the total GPU active
cycles.</p>
<p>Note that this metric measures the overall processing time for the tiler
geometry pipeline. The metric includes aspects of vertex shading, in addition
to the fixed-function tiling process.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliTilerActiveCy / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliGPUCyclesTilerActive / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((TILER_ACTIVE / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_65544">Interrupt utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the IRQ pending utilization compared against the GPU
active cycles. In a well-functioning system, this expression should be less
than 3% of the total cycles. If the value is much higher than this, a system
issue might be preventing the CPU from efficiently handling interrupts.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUIRQUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliGPUIRQActiveCy / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliGPUCyclesGPUInterruptActive / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((GPU_IRQ_ACTIVE / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_gpumessages">GPU Messages <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of control-plane messages issued by
the GPU front-end to the processing end-points inside the GPU.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_55">GPU interrupts <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every interrupt raised by the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUIRQ</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUMessagesGPUInterrupts</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>GPU_IRQ_COUNT</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_gpucacheflushes">GPU Cache Flushes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of L2 cache and MMU operations
performed by the GPU top-level.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_82">L2 cache flushes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L2 cache flush that is performed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheFlush</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCacheFlushesL2CacheFlushes</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CACHE_FLUSH</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_gpucacheflushcycles">GPU Cache Flush Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of cycles spent performing L2 cache
and MMU operations by GPU top-level.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_83">L2 cache flush <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the GPU is flushing the L2
cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheFlushCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliGPUCacheFlushCyclesL2CacheFlush</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CACHE_FLUSH_CYCLES</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_csfcycles">CSF Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of cycles that each of the sub-units
inside the command stream front-end was active.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_5">CEU active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the GPU command execution unit
is active.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCEUActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFCyclesCEUActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CEU_ACTIVE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_2">LSU active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the GPU command load/store unit
is active.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFLSUActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFCyclesLSUActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LSU_ACTIVE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_0">MCU active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the GPU command stream
management microcontroller is executing. Cycles waiting for interrupts or
events are not counted.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFMCUActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFCyclesMCUActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MCU_ACTIVE</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_csfutilization">CSF Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the use of each of the functional units inside the
command stream front-end, relative to their speed-of-light capability.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_317">CEU utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the front-end command execution unit utilization
compared against the GPU active cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCEUUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCSFCEUActiveCy / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliCSFCyclesCEUActive / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((CEU_ACTIVE / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_316">LSU utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the front-end load/store unit utilization compared
against the GPU active cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFLSUUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCSFLSUActiveCy / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliCSFCyclesLSUActive / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((LSU_ACTIVE / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_65541">MCU utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the microcontroller utilization compared against the
GPU active cycles.</p>
<p>High microcontroller load can be indicative of content using many emulated
commands, such as command stream scheduling and synchronization operations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFMCUUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCSFMCUActiveCy / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliCSFCyclesMCUActive / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((MCU_ACTIVE / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_csfstreamcycles">CSF Stream Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of cycles that each of the command
stream interfaces was active.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_10">CS0 active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 0
contained a command stream. This does not necessarily indicate that the command
stream was actively being processed by the main GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCS0ActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamCyclesCS0Active</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF0_ENABLED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_14">CS1 active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 1
contained a command stream. This does not necessarily indicate that the command
stream was actively being processed by the main GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCS1ActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamCyclesCS1Active</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF1_ENABLED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_18">CS2 active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 2
contained a command stream. This does not necessarily indicate that the command
stream was actively being processed by the main GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCS2ActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamCyclesCS2Active</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF2_ENABLED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_22">CS3 active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 3
contained a command stream. This does not necessarily indicate that the command
stream was actively being processed by the main GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCS3ActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamCyclesCS3Active</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF3_ENABLED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_354">CS4 active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 4
contained a command stream. This does not necessarily indicate that the command
stream was actively being processed by the main GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCS4ActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamCyclesCS4Active</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF4_ENABLED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_355">CS5 active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 5
contained a command stream. This does not necessarily indicate that the command
stream was actively being processed by the main GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCSFCS5ActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamCyclesCS5Active</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF5_ENABLED</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_csfstreamstallcycles">CSF Stream Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of cycles that each of the command
stream interfaces stalled for any reason.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_13">CS0 wait stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 0 was
blocked due an outstanding scheduling dependency.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCS0WaitStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamStallCyclesCS0WaitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF0_WAIT_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_17">CS1 wait stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 1 was
blocked due an outstanding scheduling dependency.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCS1WaitStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamStallCyclesCS1WaitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF1_WAIT_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_21">CS2 wait stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 2 was
blocked due an outstanding scheduling dependency.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCS2WaitStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamStallCyclesCS2WaitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF2_WAIT_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_25">CS3 wait stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 3 was
blocked due an outstanding scheduling dependency.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCS3WaitStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamStallCyclesCS3WaitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF3_WAIT_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_359">CS4 wait stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 4 was
blocked due an outstanding scheduling dependency.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCS4WaitStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamStallCyclesCS4WaitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF4_WAIT_BLOCKED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_363">CS5 wait stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when command stream interface 5 was
blocked due an outstanding scheduling dependency.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCS5WaitStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliCSFStreamStallCyclesCS5WaitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CSHWIF5_WAIT_BLOCKED</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_externalmemorysystem">External Memory System <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The GPU external memory interface connects the GPU to the system DRAM, via an
on-chip memory bus. The exact configuration of the memory system outside of the
GPU varies from device to device and might include additional levels of system
cache before reaching the off-chip memory.</p>
<p>GPUs are data-plane processors, with workloads that are too large to keep in
system cache and that therefore make heavy use of main memory. GPUs are
designed to be tolerant of high latency, when compared to a CPU, but poor
memory system performance can still reduce GPU efficiency.</p>
<p>Accessing external DRAM is one of the most energy-intensive operations that the
GPU can perform. Reducing memory bandwidth is a key optimization goal for
mobile applications, even if not bandwidth limited, ensuring users get long
battery life and thermally stable performance.</p>
<p>Performance counters in this section measure how much memory bandwidth your
application uses, as well as stall and latency counters to show how well the
memory system is coping with the generated traffic.</p>
<div class="lgc-group lgc-advanced-app lgc-advanced-sys">
<h3 id="g_externalbusaccesses">External Bus Accesses <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the absolute number of external memory transactions
generated by the GPU.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_111">Read transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external read transaction made on the memory
bus. These transactions typically result in an external DRAM access, but some
designs include a system cache which can provide some buffering.</p>
<p>The longest memory transaction possible is 64 bytes in length, but shorter
transactions are generated in some circumstances.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesReadTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_READ</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_124">Write transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external write transaction made on the memory
bus. These transactions typically result in an external DRAM access, but some
chips include a system cache which can provide some buffering.</p>
<p>The longest memory transaction possible is 64 bytes in length, but shorter
transactions are generated in some circumstances.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesWriteTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_112">ReadNoSnoop transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every non-coherent (ReadNoSnp) transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdNoSnoop</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesReadNoSnoopTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_READ_NOSNP</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_113">ReadUnique transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every coherent exclusive read (ReadUnique)
transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdUnique</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesReadUniqueTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_READ_UNIQUE</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_134">Snoop transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every coherency snoop transaction received from an
external requester.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheIncSnp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesSnoopTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_SNOOP</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_125">WriteNoSnoopFull transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external non-coherent full write
(WriteNoSnpFull) transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrNoSnoopFull</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesWriteNoSnoopFullTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE_NOSNP_FULL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_126">WriteNoSnoopPartial transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external non-coherent partial write
(WriteNoSnpPtl) transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrNoSnoopPart</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesWriteNoSnoopPartialTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE_NOSNP_PTL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_127">WriteSnoopFull transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external coherent full write (WriteBackFull
or WriteUniqueFull) transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrSnoopFull</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesWriteSnoopFullTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE_SNP_FULL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_128">WriteSnoopPartial transactions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every external coherent partial write (WriteBackPtl
or WriteUniquePtl) transaction.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrSnoopPart</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusAccessesWriteSnoopPartialTransactions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE_SNP_PTL</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_externalbusbeats">External Bus Beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the absolute amount of external memory data transfer
cycles used by the GPU.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_114">Read beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when a data beat was read from
the external memory bus.</p>
<p>Most implementations use a 128-bit (16-byte) data bus, enabling a single
64-byte read transaction to be read using 4 bus cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusBeatsReadBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_READ_BEATS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_129">Write beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when a data beat was written to
the external memory bus.</p>
<p>Most implementations use a 128-bit (16-byte) data bus, enabling a single
64-byte read transaction to be written using 4 bus cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusBeatsWriteBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_WRITE_BEATS</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_externalbusbytes">External Bus Bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the absolute amount of external memory traffic
generated by the GPU. Absolute measures are the most useful way to check actual
bandwidth against a per-frame bandwidth budget.</p>
<div class="lgc-series">
<h4 id="c_65548">Read bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total output read bandwidth for the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliExtBusRdBt * MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliExternalBusBeatsReadBeats * ($MaliConstantsBusWidthBits / 8)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>L2_EXT_READ_BEATS * MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65553">Write bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total output write bandwidth for the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliExtBusWrBt * MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliExternalBusBeatsWriteBeats * ($MaliConstantsBusWidthBits / 8)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>L2_EXT_WRITE_BEATS * MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_externalbusbandwidth">External Bus Bandwidth <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the external memory traffic generated by the GPU,
presented as a bytes/second rate. Rates are the most useful way to check actual
bandwidth against the design limits of a chip, which will usually be specified
in bytes/second.</p>
<div class="lgc-series">
<h4 id="c_554">Read bandwidth <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total output read bandwidth for the GPU, measured
in bytes per second.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdBPS</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliExtBusRdBt * MALI_CONFIG_EXT_BUS_BYTE_SIZE) / MALI_CONFIG_TIME_SPAN</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliExternalBusBeatsReadBeats * ($MaliConstantsBusWidthBits / 8)) / $ZOOM</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(L2_EXT_READ_BEATS * MALI_CONFIG_EXT_BUS_BYTE_SIZE) / MALI_CONFIG_TIME_SPAN</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_555">Write bandwidth <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total output write bandwidth for the GPU, measured
in bytes per second.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrBPS</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliExtBusWrBt * MALI_CONFIG_EXT_BUS_BYTE_SIZE) / MALI_CONFIG_TIME_SPAN</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliExternalBusBeatsWriteBeats * ($MaliConstantsBusWidthBits / 8)) / $ZOOM</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(L2_EXT_WRITE_BEATS * MALI_CONFIG_EXT_BUS_BYTE_SIZE) / MALI_CONFIG_TIME_SPAN</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app lgc-advanced-sys">
<h3 id="g_externalbusstallcycles">External Bus Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the absolute number of external memory interface
stalls, which is the number of cycles that the GPU was trying to send data but
the external bus could not accept it.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_115">Read stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every stall cycle on the AXI bus where the GPU has
a valid read transaction to send, but is awaiting a ready signal from the bus.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusStallCyclesReadStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AR_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_130">Write stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every stall cycle on the external bus where the GPU
has a valid write transaction to send, but is awaiting a ready signal from the
external bus.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusStallCyclesWriteStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_W_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_135">Snoop stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when a coherency snoop
transaction received from an external requester is stalled by the L2 cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheIncSnpStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusStallCyclesSnoopStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_SNOOP_STALL</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_externalbusstallrate">External Bus Stall Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the percentage of cycles that the GPU was trying to
send data, but by the external bus could not accept it.</p>
<p>A small number of stalls is expected, but sustained periods of with stall rates
above 10% might indicate that the GPU is generating more traffic than the
downstream memory system can handle efficiently.</p>
<div class="lgc-series">
<h4 id="c_65549">Read stall rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of GPU cycles with a memory stall on an
external read transaction.</p>
<p>Stall rates can be reduced by reducing the size of data resources, such as
buffers or textures.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdStallRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliExtBusRdStallCy / MALI_CONFIG_L2_CACHE_COUNT / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliExternalBusStallCyclesReadStalls / $MaliConstantsL2SliceCount / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((L2_EXT_AR_STALL / MALI_CONFIG_L2_CACHE_COUNT / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65554">Write stall rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of GPU cycles with a memory stall on an
external write transaction.</p>
<p>Stall rates can be reduced by reducing geometry complexity, or the size of
framebuffers in memory.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrStallRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliExtBusWrStallCy / MALI_CONFIG_L2_CACHE_COUNT / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliExternalBusStallCyclesWriteStalls / $MaliConstantsL2SliceCount / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((L2_EXT_W_STALL / MALI_CONFIG_L2_CACHE_COUNT / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_externalbusreadlatency">External Bus Read Latency <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the histogram distribution of memory latency for GPU
reads.</p>
<p>GPUs are more tolerant to latency than a CPU, but sustained periods of high
latency might indicate that the GPU is generating more traffic than the
downstream memory system can handle efficiently.</p>
<div class="lgc-series">
<h4 id="c_119">0-127 cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data beat that is returned between 0 and 127
cycles after the read transaction started. This latency is considered a fast
access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat0</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusReadLatency0127Cycles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_RRESP_0_127</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_120">128-191 cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data beat that is returned between 128 and
191 cycles after the read transaction started. This latency is considered a
normal access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat128</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusReadLatency128191Cycles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_RRESP_128_191</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_121">192-255 cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data beat that is returned between 192 and
255 cycles after the read transaction started. This latency is considered a
normal access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat192</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusReadLatency192255Cycles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_RRESP_192_255</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_122">256-319 cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data beat that is returned between 256 and
319 cycles after the read transaction started. This latency is considered a
slow access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat256</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusReadLatency256319Cycles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_RRESP_256_319</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_123">320-383 cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data beat that is returned between 320 and
383 cycles after the read transaction started. This latency is considered a
slow access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat320</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusReadLatency320383Cycles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_RRESP_320_383</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_65551">384+ cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments for every read beat that is returned at least 384
cycles after the transaction started. This latency is considered a very slow
access response speed.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdLat384</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliExtBusRdBt - MaliExtBusRdLat0 - MaliExtBusRdLat128 - MaliExtBusRdLat192 - MaliExtBusRdLat256 - MaliExtBusRdLat320</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliExternalBusBeatsReadBeats - $MaliExternalBusReadLatency0127Cycles - $MaliExternalBusReadLatency128191Cycles - $MaliExternalBusReadLatency192255Cycles - $MaliExternalBusReadLatency256319Cycles - $MaliExternalBusReadLatency320383Cycles</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>L2_EXT_READ_BEATS - L2_EXT_RRESP_0_127 - L2_EXT_RRESP_128_191 - L2_EXT_RRESP_192_255 - L2_EXT_RRESP_256_319 - L2_EXT_RRESP_320_383</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_externalbusoutstandingreads">External Bus Outstanding Reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the histogram distribution of the use of the available
pool of outstanding memory read transactions.</p>
<p>Sustained periods with most read transactions outstanding may indicate that the
GPU hardware configuration is running out of outstanding read capacity.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_116">0-25% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read transaction initiated when 0-25% of the
available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdOTQ1</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingReads025Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AR_CNT_Q1</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_117">25-50% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read transaction initiated when 25-50% of the
available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdOTQ2</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingReads2550Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AR_CNT_Q2</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_118">50-75% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read transaction initiated when 50-75% of the
available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdOTQ3</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingReads5075Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AR_CNT_Q3</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_65550">75-100% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments for every read transaction initiated when 75-100% of
transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusRdOTQ4</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliExtBusRd - MaliExtBusRdOTQ1 - MaliExtBusRdOTQ2 - MaliExtBusRdOTQ3</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliExternalBusAccessesReadTransactions - $MaliExternalBusOutstandingReads025Outstanding - $MaliExternalBusOutstandingReads2550Outstanding - $MaliExternalBusOutstandingReads5075Outstanding</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>L2_EXT_READ - L2_EXT_AR_CNT_Q1 - L2_EXT_AR_CNT_Q2 - L2_EXT_AR_CNT_Q3</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_externalbusoutstandingwrites">External Bus Outstanding Writes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the histogram distribution of the use of the available
pool of outstanding memory write transactions.</p>
<p>Sustained periods with most write transactions outstanding may indicate that
the GPU hardware configuration is running out of outstanding write capacity.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_131">0-25% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write transaction initiated when 0-25% of the
available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrOTQ1</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingWrites025Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AW_CNT_Q1</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_132">25-50% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write transaction initiated when 25-50% of
the available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrOTQ2</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingWrites2550Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AW_CNT_Q2</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_133">50-75% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write transaction initiated when 50-75% of
the available transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrOTQ3</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliExternalBusOutstandingWrites5075Outstanding</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_AW_CNT_Q3</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_65555">75-100% outstanding <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression increments for every write transaction initiated when 75-100%
of transaction IDs are in use.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliExtBusWrOTQ4</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliExtBusWr - MaliExtBusWrOTQ1 - MaliExtBusWrOTQ2 - MaliExtBusWrOTQ3</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliExternalBusAccessesWriteTransactions - $MaliExternalBusOutstandingWrites025Outstanding - $MaliExternalBusOutstandingWrites2550Outstanding - $MaliExternalBusOutstandingWrites5075Outstanding</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>L2_EXT_WRITE - L2_EXT_AW_CNT_Q1 - L2_EXT_AW_CNT_Q2 - L2_EXT_AW_CNT_Q3</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_graphicsgeometryworkload">Graphics Geometry Workload <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>Graphics workloads using the rasterization pipeline pass inputs to the GPU as a
geometry stream. Vertices in this stream are position shaded, assembled into
primitives, and then passed through a culling pipeline before being passed to
the Arm GPU binning unit.</p>
<p>Performance counters in this section show how the input geometry is processed,
indicating the overall complexity of the geometry workload and how it is
processed by the primitive culling stages.</p>
<div class="lgc-group">
<h3 id="g_inputprimitives">Input Primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of input primitives to the GPU, before any
culling is applied.</p>
<div class="lgc-series">
<h4 id="c_65556">Input primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of input primitives to the rendering
process.</p>
<p>High complexity geometry is one of the most expensive inputs to the GPU,
because vertices are much larger than compressed texels. Optimize your geometry
to minimize mesh complexity, using dynamic level-of-detail and normal maps to
reduce the number of primitives required.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomTotalPrim</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliGeomFaceCullPrim + MaliGeomPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomScissorCullPrim + MaliGeomVisiblePrim</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliPrimitiveCullingFacingTestCulledPrimitives + $MaliPrimitiveCullingFrustumTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingScissorTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>PRIM_FACE_CULLED + PRIM_FRUSTUM_CULLED + PRIM_SAMPLE_CULLED + PRIM_SCISSOR_CULLED + PRIM_VISIBLE</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_143">Triangle primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every input triangle primitive. The count is made
before any culling or clipping.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomTrianglePrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliInputPrimitivesTrianglePrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TRIANGLES</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_144">Line primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every input line primitive. The count is made
before any culling or clipping.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomLinePrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliInputPrimitivesLinePrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LINES</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_145">Point primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every input point primitive. The count is made
before any culling or clipping.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomPointPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliInputPrimitivesPointPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>POINTS</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_visibleprimitives">Visible Primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the properties of any visible primitives, after any
culling is applied.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_146">Front-facing primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every visible front-facing triangle that survives
culling.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomFrontFacePrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliVisiblePrimitivesFrontFacingPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRONT_FACING</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_147">Back-facing primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every visible back-facing triangle that survives
culling.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomBackFacePrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliVisiblePrimitivesBackFacingPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BACK_FACING</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_primitiveculling">Primitive Culling <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the absolute number of primitives that are culled by
each of the culling stages in the geometry pipeline, and the number of visible
primitives that are not culled by any stage.</p>
<div class="lgc-series">
<h4 id="c_148">Visible primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every visible primitive that survives all culling
stages.</p>
<p>All fragments of the primitive might be occluded by other primitives closer to
the camera, and so produce no visible output.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomVisiblePrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliPrimitiveCullingVisiblePrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>PRIM_VISIBLE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_65562">Culled primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of primitives that were culled during the
rendering process, for any reason.</p>
<p>For efficient 3D content, it is expected that only 50% of primitives are
visible because back-face culling is used to remove half of each model.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomTotalCullPrim</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliGeomFaceCullPrim + MaliGeomPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomScissorCullPrim</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliPrimitiveCullingFacingTestCulledPrimitives + $MaliPrimitiveCullingFrustumTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingScissorTestCulledPrimitives</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>PRIM_FACE_CULLED + PRIM_FRUSTUM_CULLED + PRIM_SAMPLE_CULLED + PRIM_SCISSOR_CULLED</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_297">Facing test culled primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive culled by the facing test.</p>
<p>For an arbitrary 3D scene we would expect approximately half of the triangles
to be back-facing. If you see a significantly lower percentage than this, check
that the facing test is properly enabled.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomFaceCullPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliPrimitiveCullingFacingTestCulledPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>PRIM_FACE_CULLED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_298">Frustum test culled primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive culled by testing against the view
frustum clip planes.</p>
<p>If significant numbers of triangles are culled by this test, Arm recommends
reviewing application culling and batching. Test draw call bounding boxes
against the frustum to cull draws that are completely out-of-frustum. Reduce
the size of static batches to reduce the bounding volume of each batch,
enabling better culling.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomPlaneCullPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliPrimitiveCullingFrustumTestCulledPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>PRIM_FRUSTUM_CULLED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_334">Scissor test culled primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive culled by the scissor test.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomScissorCullPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliPrimitiveCullingScissorTestCulledPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>PRIM_SCISSOR_CULLED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_151">Sample test culled primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive culled by the sample coverage test.
It is expected that a few primitives are small and fail the sample coverage
test, as application mesh level-of-detail selection can never be perfect. If
the number of primitives counted is more than than 5-10% of the total number,
this might indicate that the application has a large number of very small
triangles, which are very expensive for a GPU to process.</p>
<p>Aim to keep triangle screen area above 10 pixels. Use schemes such as mesh
level-of-detail to select simplified meshes as objects move further away from
the camera.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomSampleCullPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliPrimitiveCullingSampleTestCulledPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>PRIM_SAMPLE_CULLED</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_primitivecullingrate">Primitive Culling Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the percentage of the primitives that use each culling
stage that are culled by it, and the percentage of primitives that are visible
and not culled by any stage.</p>
<div class="lgc-series">
<h4 id="c_65557">Visible primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives that are visible after
culling.</p>
<p>For efficient 3D content, it is expected that only 50% of primitives are
visible because back-face culling is used to remove half of each model.</p>
<ul>
<li>A significantly higher visibility rate indicates that the facing test might
  not be enabled.</li>
<li>A significantly lower visibility rate indicates that geometry is being
  culled for other reasons, which is often possible to optimize. Use the
  individual culling counters for a more detailed breakdown.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomVisibleRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliGeomVisiblePrim / (MaliGeomFaceCullPrim + MaliGeomPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomScissorCullPrim + MaliGeomVisiblePrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliPrimitiveCullingVisiblePrimitives / ($MaliPrimitiveCullingFacingTestCulledPrimitives + $MaliPrimitiveCullingFrustumTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingScissorTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((PRIM_VISIBLE / (PRIM_FACE_CULLED + PRIM_FRUSTUM_CULLED + PRIM_SAMPLE_CULLED + PRIM_SCISSOR_CULLED + PRIM_VISIBLE)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65671">Facing culled primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives entering the facing test
that are culled by it. Back-facing triangles that are inside the frustum are
culled by this stage.</p>
<p>For efficient 3D content, it is expected that 50% of primitives are culled by
the facing test. If you see a significantly lower percentage, check that the
facing test is properly enabled.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomFaceCullRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliGeomFaceCullPrim / ((MaliGeomFaceCullPrim + MaliGeomPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomScissorCullPrim + MaliGeomVisiblePrim) - MaliGeomPlaneCullPrim - MaliGeomScissorCullPrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliPrimitiveCullingFacingTestCulledPrimitives / (($MaliPrimitiveCullingFacingTestCulledPrimitives + $MaliPrimitiveCullingFrustumTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingScissorTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives) - $MaliPrimitiveCullingFrustumTestCulledPrimitives - $MaliPrimitiveCullingScissorTestCulledPrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((PRIM_FACE_CULLED / ((PRIM_FACE_CULLED + PRIM_FRUSTUM_CULLED + PRIM_SAMPLE_CULLED + PRIM_SCISSOR_CULLED + PRIM_VISIBLE) - PRIM_FRUSTUM_CULLED - PRIM_SCISSOR_CULLED)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65672">Frustum culled primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives entering the frustum test
that are culled by it. Primitives that are outside of the view frustum are
culled by this stage.</p>
<p>If a significant percentage of triangles are culled by this test we recommend
reviewing application culling and batching. Test draw call bounding boxes
against the frustum to cull draws that are completely out-of-frustum. Reduce
the size of static batches to reduce the bounding volume of each batch,
enabling better culling.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomPlaneCullRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliGeomPlaneCullPrim / (MaliGeomFaceCullPrim + MaliGeomPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomScissorCullPrim + MaliGeomVisiblePrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliPrimitiveCullingFrustumTestCulledPrimitives / ($MaliPrimitiveCullingFacingTestCulledPrimitives + $MaliPrimitiveCullingFrustumTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingScissorTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((PRIM_FRUSTUM_CULLED / (PRIM_FACE_CULLED + PRIM_FRUSTUM_CULLED + PRIM_SAMPLE_CULLED + PRIM_SCISSOR_CULLED + PRIM_VISIBLE)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_412">Scissor culled primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives entering the scissor test
that are culled by it. Primitives outside of the active scissor region are
killed by this stage.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomScissorCullRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliGeomScissorCullPrim / ((MaliGeomFaceCullPrim + MaliGeomPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomScissorCullPrim + MaliGeomVisiblePrim) - MaliGeomPlaneCullPrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliPrimitiveCullingScissorTestCulledPrimitives / (($MaliPrimitiveCullingFacingTestCulledPrimitives + $MaliPrimitiveCullingFrustumTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingScissorTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives) - $MaliPrimitiveCullingFrustumTestCulledPrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((PRIM_SCISSOR_CULLED / ((PRIM_FACE_CULLED + PRIM_FRUSTUM_CULLED + PRIM_SAMPLE_CULLED + PRIM_SCISSOR_CULLED + PRIM_VISIBLE) - PRIM_FRUSTUM_CULLED)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65560">Sample culled primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives entering the sample
coverage test that are culled by it. This stage culls primitives that are so
small that they hit no rasterizer sample points.</p>
<p>If a significant number of triangles are culled at this stage, the application
is using geometry meshes that are too complex for their screen coverage. Use
schemes such as mesh level-of-detail to select simplified meshes as objects
move further away from the camera.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomSampleCullRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliGeomSampleCullPrim / ((MaliGeomFaceCullPrim + MaliGeomPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomScissorCullPrim + MaliGeomVisiblePrim) - MaliGeomPlaneCullPrim - MaliGeomScissorCullPrim - MaliGeomFaceCullPrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliPrimitiveCullingSampleTestCulledPrimitives / (($MaliPrimitiveCullingFacingTestCulledPrimitives + $MaliPrimitiveCullingFrustumTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingScissorTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives) - $MaliPrimitiveCullingFrustumTestCulledPrimitives - $MaliPrimitiveCullingScissorTestCulledPrimitives - $MaliPrimitiveCullingFacingTestCulledPrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((PRIM_SAMPLE_CULLED / ((PRIM_FACE_CULLED + PRIM_FRUSTUM_CULLED + PRIM_SAMPLE_CULLED + PRIM_SCISSOR_CULLED + PRIM_VISIBLE) - PRIM_FRUSTUM_CULLED - PRIM_SCISSOR_CULLED - PRIM_FACE_CULLED)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_geometrythreads">Geometry Threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of vertex shader threads of each type that
are generated during the binning phase processing.</p>
<p>All vertices must be position shaded, but only visible vertices of draw calls
that are incompatible with deferred vertex shading will be varying shaded.</p>
<div class="lgc-series">
<h4 id="c_65565">Position shading threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of position shader thread invocations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomPosShadThread</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliGeomPosShadTask * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliTilerShadingRequestsPositionShadingRequests * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>POS_SHADER_WARPS * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65566">Varying shading threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of varying shader thread invocations
triggered during the binning phase.</p>
<p>This GPU can defer varying shading to the main pass, which is not visible in
this counter.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomVarShadThread</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliGeomVarShadTask * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliTilerShadingRequestsVaryingShadingRequests * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>VAR_SHADER_WARPS * 16</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_geometryefficiency">Geometry Efficiency <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of vertex shader threads of each type that
are generated per primitive during vertex processing. Efficient geometry aims
to keep these metrics as low as possible.</p>
<p>This GPU has deferred vertex shading which means that most triangles will defer
varying shading until the main phase processing, so the number of varying
threads per primitive has a different meaning than earlier GPUs without
deferred vertex shading.</p>
<div class="lgc-series">
<h4 id="c_65666">Position threads/input primitive <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of position shader threads per input
primitive.</p>
<p>Efficient meshes with a good vertex reuse have average less than 1.5 vertices
shaded per triangle, as vertex computation is shared by multiple primitives.
Minimize this number by reusing vertices for nearby primitives, improving
temporal locality of index reuse, and avoiding unused values in the active
index range.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomPosShadThreadPerPrim</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliGeomPosShadTask * 16) / (MaliGeomFaceCullPrim + MaliGeomPlaneCullPrim + MaliGeomSampleCullPrim + MaliGeomScissorCullPrim + MaliGeomVisiblePrim)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliTilerShadingRequestsPositionShadingRequests * 16) / ($MaliPrimitiveCullingFacingTestCulledPrimitives + $MaliPrimitiveCullingFrustumTestCulledPrimitives + $MaliPrimitiveCullingSampleTestCulledPrimitives + $MaliPrimitiveCullingScissorTestCulledPrimitives + $MaliPrimitiveCullingVisiblePrimitives)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(POS_SHADER_WARPS * 16) / (PRIM_FACE_CULLED + PRIM_FRUSTUM_CULLED + PRIM_SAMPLE_CULLED + PRIM_SCISSOR_CULLED + PRIM_VISIBLE)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_graphicsfragmentworkload">Graphics Fragment Workload <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>Graphics workloads using the rasterization pipeline are rendered into the
framebuffer to create output images.</p>
<p>Performance counters in this section show the workload complexity of your
fragment rendering.</p>
<div class="lgc-group">
<h3 id="g_outputpixels">Output pixels <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of output pixels rendered.</p>
<div class="lgc-series">
<h4 id="c_65546">Pixels <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of pixels that are shaded by the GPU,
including on-screen and off-screen render passes.</p>
<p>This measure can be a slight overestimate because it assumes all pixels in each
active <a href="#c_445">64</a> x <a href="#c_445">64</a> pixel region are
shaded. If the rendered region does not align with <a href="#c_445">64</a>
pixel aligned boundaries, then this metric includes pixels that are not
actually shaded.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUPix</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliMainQueueTask * 4096</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliGPUTasksMainPhaseTasks * 4096</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>ITER_FRAG_TASK_COMPLETED * 4096</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_overdraw">Overdraw <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of fragments rendered per pixel.</p>
<div class="lgc-series">
<h4 id="c_65585">Fragments/pixel <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression computes the number of fragments shaded per output pixel.</p>
<p>GPU processing cost per pixel accumulates with the layer count. High overdraw
can build up to a significant processing cost, especially when rendering to a
high-resolution framebuffer. Minimize overdraw by rendering opaque objects
front-to-back and minimizing use of blended transparent layers.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragOverdraw</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliFragThread / (MaliMainQueueTask * 4096)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderThreadsAllFragmentThreads / ($MaliGPUTasksMainPhaseTasks * 4096)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>FRAG_SHADER_THREADS / (ITER_FRAG_TASK_COMPLETED * 4096)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_workloadcost">Workload Cost <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>Workload cost metrics give an average throughput per item of work processed by
the GPU.</p>
<p>Performance counters in this section can be used to track average performance
against budget, and to monitor the impact of application changes over time.</p>
<div class="lgc-group">
<h3 id="g_averageworkloadcost">Average Workload Cost <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group gives the average cycle throughput for the different kinds
of workloads the GPU is running.</p>
<p>When running workloads in parallel the shader core is shared, and these
throughput metrics will be impacted by cross-talk across the queues. However,
they still a useful tool for managing performance budgets.</p>
<div class="lgc-series">
<h4 id="c_65673">GPU cycles/pixel <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of GPU cycles being spent per pixel
rendered. This includes the cost of all shader stages.</p>
<p>It is a useful exercise to set a cycle budget for each render pass in your
application, based on your target resolution and frame rate. Rendering 1080p60
is possible with an entry-level device, but you have a small number of cycles
per pixel to work so must use them efficiently.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUCyPerPix</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliGPUActiveCy / (MaliMainQueueTask * 4096)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliGPUCyclesGPUActive / ($MaliGPUTasksMainPhaseTasks * 4096)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>GPU_ACTIVE / (ITER_FRAG_TASK_COMPLETED * 4096)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65593">Shader cycles/non-fragment thread <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of shader core cycles per
non-fragment thread.</p>
<p>This measurement captures the overall shader core throughput, not the shader
processing cost. It will be impacted by cycles lost to stalls that could not be
hidden by other processing. In addition, it will be impacted by any fragment
workloads that are running concurrently in the shader core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliNonFragThroughputCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliCompOrBinningActiveCy / (MaliNonFragWarp * 16)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreCyclesComputeOrBinningPhaseActive / ($MaliShaderWarpsNonFragmentWarps * 16)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>COMPUTE_ACTIVE / (COMPUTE_WARPS * 16)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65575">Shader cycles/fragment thread <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of shader core cycles per fragment
thread.</p>
<p>This measurement captures the overall shader core throughput, not the shader
processing cost. It will be impacted by cycles lost to stalls that could not be
hidden by other processing. In addition, it will be impacted by any fragment
workloads that are running concurrently in the shader core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragThroughputCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliMainActiveCy / ((MaliFragWarp - MaliFragPrepassWarp) * 16)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreCyclesMainPhaseActive / (($MaliShaderWarpsFragmentWarps - $MaliShaderWarpsFragmentPrepassWarps) * 16)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>FRAG_ACTIVE / ((FRAG_WARPS - FRAG_WARPS_PRE_PASS) * 16)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercorefrontend">Shader Core Front-end <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The shader core front-ends are the internal interfaces inside the GPU that
accept tasks from other parts of the GPU and turn them into shader threads
running in the programmable core.</p>
<p>Each shader core has two front-ends:</p>
<ul>
<li>Compute and Binning phase front-end for tasks including compute,
  binning-time vertex shading, and advanced geometry.</li>
<li>Main phase front-end for all main phase tasks, including deferred vertex
  shading, and fragment shading.</li>
</ul>
<p>The front-ends show as active until task processing is complete, so front-end
activity is a direct way of measuring that the shader core is busy handling a
workload.</p>
<p>The Execution core is the programmable core at the heart of the shader core
hardware. The Execution core shows as active if there is at least on thread
running, and monitoring its activity is an indirect way of checking that the
front-ends are managing to keep the GPU busy.</p>
<p>Performance counters in this section measure the overall workload scheduling
for the shader core, showing how busy the shader core is. Note that front-end
counters can tell you that a task was scheduled but cannot tell you how heavily
the programmable core is being used.</p>
<div class="lgc-group">
<h3 id="g_shadercorecycles">Shader Core Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the scheduling load on the shader core, indicating
which of the shader core front-ends have work scheduled and whether they are
running threads on the programmable core.</p>
<div class="lgc-series">
<h4 id="c_207">Any workload active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the shader core is processing
any type of workload, irrespective of which queue the workload came from.</p>
<p>This counter is particularly useful in high-end GPU configurations where it can
indicate the shader core clock rate. This rate can be lower than the GPU
top-level clock rate.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliAnyActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreCyclesAnyWorkloadActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>SHADER_CORE_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_472">Compute or binning phase active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the shader core is processing
some compute or binning phase workload. Active processing includes any cycle
that compute or binning work is queued in the fixed-function front-end or
programmable core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompOrBinningActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreCyclesComputeOrBinningPhaseActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>COMPUTE_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_469">Main phase active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the shader core is processing
some main phase workload. Active processing includes any cycle that fragment
work is running anywhere in the fixed-function front-end, fixed-function
back-end, or programmable core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMainActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreCyclesMainPhaseActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_212">Fragment pre-pipe buffer active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the pre-pipe quad queue contains
at least one quad waiting to run. If this queue completely drains, a fragment
warp cannot be spawned when space for new threads becomes available in the
shader core. You can experience reduced performance when low thread occupancy
starves the functional units of work to process.</p>
<p>Possible causes for this include:</p>
<ul>
<li>Tiles which contain no geometry, which are commonly encountered when
  creating shadow maps, where many tiles contain no shadow casters.</li>
<li>Tiles which contain a lot of geometry which are killed by early ZS or
  hidden surface removal.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragFPKActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreCyclesFragmentPrePipeBufferActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_FPK_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_230">Execution core active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the shader core is processing at
least one warp. Note that this counter does not provide detailed information
about how the functional units are utilized inside the shader core, but simply
gives an indication that something was running.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreCyclesExecutionCoreActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_CORE_ACTIVE</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shadercoreutilization">Shader Core Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the scheduling load on the shader core, normalized
against the overall shader core activity.</p>
<div class="lgc-series">
<h4 id="c_473">Compute or binning phase utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the shader core compute
or binning phase path. This counter measures any cycle that a compute or
binning phase workload is active in the fixed-function front-end or
programmable core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCompOrBinningUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCompOrBinningActiveCy / MaliAnyActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreCyclesComputeOrBinningPhaseActive / $MaliShaderCoreCyclesAnyWorkloadActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((COMPUTE_ACTIVE / SHADER_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_470">Main phase utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the shader core main
phase path. This counter measures any cycle that a main phase workload is
active in the fixed-function front-end, fixed-function back-end, or
programmable core.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMainUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliMainActiveCy / MaliAnyActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreCyclesMainPhaseActive / $MaliShaderCoreCyclesAnyWorkloadActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_ACTIVE / SHADER_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65569">Fragment pre-pipe buffer utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of cycles when the pre-pipe quad buffer
contains at least one fragment quad. This buffer is located after early ZS but
before the programmable core.</p>
<p>During fragment shading this counter must be close to 100%. This indicates that
the fragment front-end is able to keep up with the shader core shading rate.
This counter commonly drops below 100% for three reasons:</p>
<ul>
<li>The running workload has many empty tiles with no geometry to render. Empty
  tiles are common in shadow maps, for any screen region with no shadow
  casters.</li>
<li>The application consists of simple shaders but a high percentage of
  microtriangles. This combination causes the shader core to complete fragments
  faster than they are rasterized, so the quad buffer starts to drain.</li>
<li>The application consists of layers which stall at early ZS because of a
  dependency on an earlier fragment layer which is still in flight. Stalled
  layers prevent new fragments entering the quad buffer, so the quad buffer
  starts to drain.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragFPKBUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragFPKActiveCy / MaliMainActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreCyclesFragmentPrePipeBufferActive / $MaliShaderCoreCyclesMainPhaseActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_FPK_ACTIVE / FRAG_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65579">Execution core utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the programmable core,
measuring cycles when the shader core contains at least one warp. A low
utilization here indicates lost performance, because there are spare shader
core cycles that are unused.</p>
<p>In some use cases an idle core is unavoidable. For example, a clear color tile
that contains no shaded geometry, or a shadow map that is resolved entirely
using early ZS depth updates.</p>
<p>Improve programmable core utilization by parallel processing of the GPU work
queues, running overlapping workloads from multiple render passes. Also aim to
keep the FPK buffer utilization as high as possible, ensuring constant
forward-pressure on fragment shading.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCoreActiveCy / MaliAnyActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreCyclesExecutionCoreActive / $MaliShaderCoreCyclesAnyWorkloadActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_CORE_ACTIVE / SHADER_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shaderclockratio">Shader Clock Ratio <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group gives an estimate of the clock ratio between the shader core
and the GPU top-level. In large systems the shader cores will typically be
clocked more slowly than the top-level to improve energy efficiency.</p>
<div class="lgc-series">
<h4 id="c_65596">Shader core clock ratio <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage usage of the shader core, relative to
the top-level GPU clock.</p>
<p>To improve energy efficiency, some systems clock the shader cores at a lower
frequency than the GPU top-level components. In these systems, the maximum
achievable usage value is the clock ratio between the GPU top-level clock and
the shader clock. For example, a GPU with an 800MHz top-level clock and a
400MHz shader clock can achieve a maximum usage of 50%.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliAnyUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliAnyActiveCy / MALI_CONFIG_SHADER_CORE_COUNT / MaliGPUActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreCyclesAnyWorkloadActive / $MaliConstantsShaderCoreCount / $MaliGPUCyclesGPUActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((SHADER_CORE_ACTIVE / MALI_CONFIG_SHADER_CORE_COUNT / GPU_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_shadercoretasks">Shader Core Tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of tasks processed by the shader cores.
Task sizes for compute tasks are variable, so this is not expected to be a
useful measure of workload.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_227">Non-main phase tasks <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every non-main phase task issued to the shader
core. The size of these tasks is variable.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliNonFragTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreTasksNonMainPhaseTasks</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>COMPUTE_TASKS</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercorefragmentfrontend">Shader Core Fragment Front-end <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The shader core fragment front-end is a complex multi-stage pipeline that
converts an incoming primitive stream for a screen-space tile into fragment
threads that need to be shaded. The fragment front-end handles rasterization,
early depth (Z) and stencil (S) testing, and hidden surface removal (HSR).</p>
<p>Performance counters in this section measure how the incoming stream was turned
into quads, and how efficiently those quads interacted with ZS testing and HSR.</p>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_fragmenttiles">Fragment Tiles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of fragment tiles processed by the shader
cores.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_223">Tiles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every tile processed by the shader core. Note that
tiles are normally <a href="#c_65647">32</a> x <a href="#c_65647">32</a> pixels
but can vary depending on per-pixel storage requirements and the tile buffer
size of the current GPU.</p>
<p>This GPU supports full size tiles when using up to and including <a
href="#c_65656">256</a> bits per pixel of color storage. Pixel storage
requirements depend on the number of color attachments, their data format, and
the number of multi-sampling samples per pixel.</p>
<p>The most accurate way to get the total pixel count rendered by the application
is to use the <a href="#c_446">Main phase tasks</a> counter, because it always
counts <a href="#c_445">64</a> x <a href="#c_445">64</a> pixel regions.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragTile</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentTilesTiles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_PTILES</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_224">Killed unchanged tiles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every 16x16 pixel tile or tile sub-region killed by
a transaction elimination CRC check, where the data is the same as the content
already stored in memory.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragTileKill</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentTilesKilledUnchangedTiles</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_TRANS_ELIM</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_fragmentprimitives">Fragment Primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows how the fragment front-end handles the incoming
primitive stream from the tile list built during the binning phase.</p>
<p>Large primitives will be read in multiple tiles and will therefore cause
multiple increments to these counter values. These counters will not match the
input primitive counts passed in by the application.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_464">Input primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of unique primitives loaded by the fragment
front-end for each tile.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragInputPrim</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliFragPrim + MaliFragPrepassCullPrim) - MaliFragPrepassPrim</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliFragmentPrimitivesLoadedPrimitives + $MaliFragmentPrimitivesPrepassCulledPrimitives) - $MaliFragmentPrimitivesLoadedPrepassPrimitives</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(FRAG_PRIMITIVES_OUT + FRAG_PRIMITIVES_HSR_CULLED) - FRAG_PRIMITIVES_OUT_PRE_PASS</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_384">Loaded primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive loaded by the fragment front-end.</p>
<p>Primitives might be loaded up to two times per tile, depending on interaction
with Fragment Prepass hidden surface removal.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentPrimitivesLoadedPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_PRIMITIVES_OUT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_385">Loaded prepass primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive loaded by the fragment front-end
that are used in the fragment prepass.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentPrimitivesLoadedPrepassPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_PRIMITIVES_OUT_PRE_PASS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_386">Prepass culled primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive loaded by the fragment front-end
that is optimized out by the fragment prepass hidden surface removal.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassCullPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentPrimitivesPrepassCulledPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_PRIMITIVES_HSR_CULLED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_387">Prepass skipped primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive that is not tested by fragment
prepass hidden surface removal because an earlier primitive was incompatible
and terminated the prepass.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassSkippedPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentPrimitivesPrepassSkippedPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_PRIMITIVES_HSR_DISABLED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_211">Rasterized primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every primitive entering the rasterization unit for
each tile shaded. This increments per tile, which means that a single primitive
that spans multiple tiles is counted multiple times. If you want to know the
total number of primitives in the scene refer to the <a href="#c_65556">Total
input primitives</a> expression.</p>
<p>Input primitives might be rasterized up to two times per tile, depending on
interaction with Fragment Prepass hidden surface removal.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragRastPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentPrimitivesRasterizedPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_PRIM_RAST</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_fragmentprepassproperties">Fragment Prepass Properties <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows how the fragment prepass hidden surface removal
processed the incoming primitive stream.</p>
<div class="lgc-series">
<h4 id="c_465">Prepass primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives that are processed by
fragment prepass hidden surface removal.</p>
<p>A low percentage indicates that many primitives are using a render state that
is ineligible for the prepass, or a primitive used a render state that caused
the prepass to terminate early. Review application draw call settings to ensure
compatibility with the fragment prepass requirements.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassPrimRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragPrepassPrim / ((MaliFragPrim + MaliFragPrepassCullPrim) - MaliFragPrepassPrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentPrimitivesLoadedPrepassPrimitives / (($MaliFragmentPrimitivesLoadedPrimitives + $MaliFragmentPrimitivesPrepassCulledPrimitives) - $MaliFragmentPrimitivesLoadedPrepassPrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_PRIMITIVES_OUT_PRE_PASS / ((FRAG_PRIMITIVES_OUT + FRAG_PRIMITIVES_HSR_CULLED) - FRAG_PRIMITIVES_OUT_PRE_PASS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_468">Prepass warp rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of warps that are processed by the
fragment prepass relative to the main pass.</p>
<p>A high percentage here indicates a potential inefficiency. It can indicate that
a high percentage of draw calls require prepass shaders due to use of
shader-based alpha-testing or alpha-to-coverage. It can also indicate that a
high percentage of geometry is being culled by hidden surface removal.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassWarpRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragPrepassWarp / (MaliFragWarp - MaliFragPrepassWarp)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderWarpsFragmentPrepassWarps / ($MaliShaderWarpsFragmentWarps - $MaliShaderWarpsFragmentPrepassWarps)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_WARPS_PRE_PASS / (FRAG_WARPS - FRAG_WARPS_PRE_PASS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_466">Culled primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives in the main pass that are
culled by the fragment prepass.</p>
<p>A high percentage indicates that a lot of geometry is being occluded by opaque
primitives. If objects are completely occluded by geometry closer to the
camera, consider applying higher level culling algorithms that can completely
optimize away the occluded geometry.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassCullPrimRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragPrepassCullPrim / ((MaliFragPrim + MaliFragPrepassCullPrim) - MaliFragPrepassPrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentPrimitivesPrepassCulledPrimitives / (($MaliFragmentPrimitivesLoadedPrimitives + $MaliFragmentPrimitivesPrepassCulledPrimitives) - $MaliFragmentPrimitivesLoadedPrepassPrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_PRIMITIVES_HSR_CULLED / ((FRAG_PRIMITIVES_OUT + FRAG_PRIMITIVES_HSR_CULLED) - FRAG_PRIMITIVES_OUT_PRE_PASS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_467">Skipped primitive rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of primitives that are not be tested by
fragment prepass hidden surface removal.</p>
<p>A high percentage indicates that many primitives are submitted after a
primitive that used a render state that caused the prepass to terminate. Review
application draw call settings to ensure compatibility with the fragment
prepass requirements. If an incompatible render state must be used, move all
draw calls using that state after all prepass compatible draw calls.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassSkipPrimRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragPrepassSkippedPrim / ((MaliFragPrim + MaliFragPrepassCullPrim) - MaliFragPrepassPrim)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentPrimitivesPrepassSkippedPrimitives / (($MaliFragmentPrimitivesLoadedPrimitives + $MaliFragmentPrimitivesPrepassCulledPrimitives) - $MaliFragmentPrimitivesLoadedPrepassPrimitives)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_PRIMITIVES_HSR_DISABLED / ((FRAG_PRIMITIVES_OUT + FRAG_PRIMITIVES_HSR_CULLED) - FRAG_PRIMITIVES_OUT_PRE_PASS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_444">Culled quad rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of rasterized quads that are killed by
the fragment prepass hidden surface removal scheme.</p>
<p>Quads killed at this stage are killed before shading, so a high percentage here
is not generally a performance problem. However, performance could be improved
if occluded objects were removed using software culling techniques.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassKillRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragPrepassKillQd / MaliFragPrepassTestQd) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentZSQuadsPrepassKilledQuads / $MaliFragmentZSQuadsPrepassTestedQuads) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_QUADS_HSR_BUF_KILLED / FRAG_QUADS_HSR_BUF_TEST) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_463">Main pass stall rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of cycles when the fragment main pass is
stalled waiting for the fragment prepass to complete.</p>
<p>A high percentage here indicates that the fragment prepass is a bottleneck.
This can be caused by a high amount of geometry or a high number of primitives
needing prepass shading.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragMainPassStallRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragMainPassStallCy / MaliMainActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreStallCyclesFragmentMainPassStalls / $MaliShaderCoreCyclesMainPhaseActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_MAIN_PASS_STALLED_BY_PRE_PASS / FRAG_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_fragmentquads">Fragment Quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows how the rasterizer turns the incoming primitive stream
in to 2x2 sample quads for shading.</p>
<div class="lgc-series">
<h4 id="c_216">Rasterized fine quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every fine quad generated by the rasterization
phase. A fine quad covers a 2x2 pixel screen region. The quads generated have
at least some coverage based on the current sample pattern, but can
subsequently be killed by early ZS testing or hidden surface removal before
they are shaded.</p>
<p>Input quads might be rasterized up to two times, depending on interaction with
Fragment Prepass hidden surface removal.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragRastQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentQuadsRasterizedFineQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_RAST</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_217">Partial rasterized fine quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every rasterized fine quad containing pixels that
have no active sample points. Partial coverage occurs when any of sample points
span the edge of a triangle.</p>
<p>Note that a non-partial fine quad can become partial before shading if some
samples fail early ZS testing. This change is not visible in this counter.</p>
<p>Input quads might be rasterized up to two times, depending on interaction with
Fragment Prepass hidden surface removal.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragRastPartQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentQuadsPartialRasterizedFineQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_PARTIAL_QUADS_RAST</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_59">Rasterized coarse quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every coarse quad generated by the rasterization
phase. A coarse quad covers a 2x2 block of fragment threads. The quads
generated have at least some coverage based on the current sample pattern, but
can subsequently be killed by early ZS testing or hidden surface removal before
they are shaded.</p>
<p>There are more coarse quads than fine quads if the application is using
sample-rate shading when rendering to multi-sampled framebuffers.</p>
<p>There are fewer coarse quads than fine quads if the application is using
variable rate shading to reduce the fragment density and shade multiple pixels
per fragment.</p>
<p>Input quads might be rasterized up to two times, depending on interaction with
Fragment Prepass hidden surface removal.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragRastCoarseQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentQuadsRasterizedCoarseQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_COARSE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_65570">Shaded coarse quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of 2x2 fragment quads that are spawned as
executing threads in the shader core.</p>
<p>This expression is an approximation assuming that all spawned fragment warps
contain a full set of quads. Comparing the total number of warps against the <a
href="#c_232">Full warps</a> counter can indicate how close this approximation
is.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragShadedQd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliFragWarp * 16) / 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderWarpsFragmentWarps * 16) / 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(FRAG_WARPS * 16) / 4</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_fragmentzsquads">Fragment ZS Quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows how the depth (Z) and stencil (Z) test unit handles
quads for early and late ZS test and update.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_389">Prepass tested quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad that is tested by the fragment prepass
hidden surface removal.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassTestQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsPrepassTestedQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_HSR_BUF_TEST</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_390">Prepass killed quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad that is killed by the fragment prepass
hidden surface removal.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassKillQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsPrepassKilledQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_HSR_BUF_KILLED</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_388">Prepass early ZS updated quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad that updates the fragment prepass during
early depth and stencil testing.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassEZSUpdateQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsPrepassEarlyZSUpdatedQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_HSR_BUF_EZS_UPDATE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_218">Early ZS tested quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad undergoing early depth and stencil
testing.</p>
<p>For maximum performance, this number must be close to the total number of input
quads. We want as many of the input quads as possible to be subject to early ZS
testing because early ZS testing is significantly more efficient than late ZS
testing, which only kills threads after they have been shaded.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragEZSTestQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsEarlyZSTestedQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_EZS_TEST</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_220">Early ZS killed quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad killed by early depth and stencil
testing.</p>
<p>Quads killed at this stage are killed before shading, so a high percentage here
is not generally a performance problem. However, it can indicate an opportunity
to use software culling techniques such as portal culling to avoid sending
occluded geometry to the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragEZSKillQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsEarlyZSKilledQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_EZS_KILL</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_219">Early ZS updated quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad undergoing early depth and stencil
testing that can update the framebuffer. Quads that have a depth value that
depends on shader behavior, or those that have indeterminate coverage because
of use of alpha-to-coverage or discard statements in the shader, might be early
ZS tested but can not do an early ZS update.</p>
<p>For maximum performance, this number must be close to the total number of input
quads. Aim to maximize the number of quads that are capable of doing an early
ZS update.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragEZSUpdateQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsEarlyZSUpdatedQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_QUADS_EZS_UPDATE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_222">Late ZS killed quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad killed by late depth and stencil
testing.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragLZSKillQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsLateZSKilledQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_LZS_KILL</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_221">Late ZS tested quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad undergoing late depth and stencil
testing.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragLZSTestQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentZSQuadsLateZSTestedQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_LZS_TEST</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_zsunittestrate">ZS Unit Test Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the relative numbers of quads doing early and late
depth (Z) and stencil (Z) testing.</p>
<div class="lgc-series">
<h4 id="c_65584">Late ZS kill rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of rasterized quads that are killed by
late depth and stencil testing. Quads killed by late ZS testing run at least
some of their fragment program before being killed. A significant number of
quads being killed at late ZS testing indicates a potential overhead. Aim to
minimize the number of quads using and being killed by late ZS testing.</p>
<p>Shaders with mutable coverage, mutable depth, or side-effects on shared
resources in memory, use late ZS testing.</p>
<p>The driver also generates late ZS updates to preload a depth or stencil
attachment at the start of a render pass, which is needed if the render pass
does not start from a cleared depth value. These fragments show as a late ZS
kill, as no shader is needed after the depth or stencil value has been set.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragLZSKillRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragLZSKillQd / (4 * MaliFragWarp)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentZSQuadsLateZSKilledQuads / (4 * $MaliShaderWarpsFragmentWarps)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_LZS_KILL / (4 * FRAG_WARPS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65583">Late ZS test rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of rasterized quads that are tested by
late depth and stencil testing.</p>
<p>A high percentage of fragments performing a late ZS update can cause slow
performance, even if fragments are not killed. Younger fragments cannot
complete early ZS until all older fragments at the same coordinate have
completed their late ZS operations, which can cause stalls.</p>
<p>You achieve the lowest late test rates by avoiding draw calls with modifiable
coverage, or with shader programs that write to their depth value or that have
memory-visible side-effects</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragLZSTestRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragLZSTestQd / (4 * MaliFragWarp)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentZSQuadsLateZSTestedQuads / (4 * $MaliShaderWarpsFragmentWarps)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_LZS_TEST / (4 * FRAG_WARPS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_fragmentfpkhsrquads">Fragment FPK HSR Quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows how many of the generated quads are eligible to be
occluders for the Forward Pixel Kill (FPK) hidden surface removal scheme.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_225">Occluding quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad that is a valid occluder for hidden
surface removal. To be a candidate occluder, a quad must be guaranteed to be
opaque and have fulled resolved at early ZS.</p>
<p>Draw calls that use blending, shader discard, alpha-to-coverage, programmable
depth, or programmable tile buffer access can not be occluders.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragOpaqueQd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliFragmentFPKHSRQuadsOccludingQuads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>QUAD_FPK_KILLER</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_fragmentshadingrate">Fragment Shading Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the rate of fragment generation relative to the number
of covered pixels.</p>
<p>The fragment shading rate will be lower than 100% if the application is using
variable-rate shading to reduce shading rate.</p>
<p>The fragment shading rate will be higher than 100% if the application is using
sample-rate shading to increase shading rate for a multi-sampled render.</p>
<div class="lgc-series">
<h4 id="c_319">Shading rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of coarse quads generated relative to
the number of fine quads that were rasterized. Coarse quads cover a 2x2
fragment region. Fine quads cover a 2x2 pixel region.</p>
<p>The fragment shading rate is lower than 100% if the application uses
variable-rate shading to reduce shading rate.</p>
<p>The fragment shading rate is higher than 100% if the application uses
sample-rate shading to increase shading rate for a multi-sampled render.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragShadRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragRastCoarseQd / MaliFragRastQd) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentQuadsRasterizedCoarseQuads / $MaliFragmentQuadsRasterizedFineQuads) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_QUADS_COARSE / FRAG_QUADS_RAST) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_fragmentworkloadproperties">Fragment Workload Properties <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows properties of the fragment front-end workload that can
identify specific application optimization opportunities.</p>
<div class="lgc-series">
<h4 id="c_65577">Partial coverage rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of fragment quads that contain samples
with no coverage. A high percentage can indicate that the content has a high
density of small triangles, which are expensive to process. To avoid this, use
mesh level-of-detail algorithms to select simpler meshes as objects move
further from the camera.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragRastPartQdRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragRastPartQd / MaliFragRastQd) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentQuadsPartialRasterizedFineQuads / $MaliFragmentQuadsRasterizedFineQuads) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_PARTIAL_QUADS_RAST / FRAG_QUADS_RAST) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65586">Unchanged tile kill rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of tiles that are killed by the
transaction elimination CRC check because the content of a tile matches the
content already stored in memory.</p>
<p>A high percentage of tile writes being killed indicates that a significant part
of the framebuffer is static from frame to frame. Consider using scissor
rectangles to reduce the area that is redrawn. To help manage the partial frame
updates for window surfaces consider using the EGL extensions such as:</p>
<ul>
<li>EGL_KHR_partial_update</li>
<li>EGL_EXT_swap_buffers_with_damage</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragTileKillRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragTileKill / (4 * MaliFragTile)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliFragmentTilesKilledUnchangedTiles / (4 * $MaliFragmentTilesTiles)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_TRANS_ELIM / (4 * FRAG_PTILES)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercoreprogrammablecore">Shader Core Programmable Core <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The programmable core is responsible for executing shader programs. This
generation of Arm GPUs are warp-based, scheduling multiple threads from the
same program in lockstep to improve energy efficiency.</p>
<p>The programmable core is a massively multi-threaded core, allowing many
concurrently resident warps, which provides a level of tolerance to cache
misses and data fetch latency. For most applications having more threads
resident improves performance, as it increases the number of threads available
for latency hiding, but it might decrease performance if the additional threads
cause cache thrashing.</p>
<p>The core is built from a multiple independent hardware units, which can be
simultaneously processing workloads from any of the resident threads. The most
heavily loaded unit will set the upper bound on performance, with the other
units running in parallel to it.</p>
<p>Performance counters in this section show the overall utilization of the
different hardware units, as well as any indication of unit backpressure
overload, making it easier to identify the units that are on the critical path.</p>
<div class="lgc-group">
<h3 id="g_shadercoreunitutilization">Shader Core Unit Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the use of each of the functional units inside the
shader core, relative to their speed-of-light capability.</p>
<p>These units can run in parallel, and well performing content can expect peak
load to be above 80% utilization on the most heavily used units. In this
scenario reducing use of those units is likely to improve application
performance.</p>
<p>If no unit is heavily loaded, it implies that the shader core is starving for
work. This can be because not enough threads are getting spawned by the
front-end, or because threads in the core are blocked on memory access. Other
counters can help determine which of these situations is occurring.</p>
<div class="lgc-series">
<h4 id="c_65643">Arithmetic unit utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the arithmetic unit in
the programmable core.</p>
<p>The most effective technique for reducing arithmetic load is reducing the
complexity of your shader programs. Using narrower 8 and 16-bit data types can
also help, as it allows multiple operations to be processed in parallel.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliALUUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((max((MaliEngFMAInstr + MaliEngCVTInstr + MaliEngSFUInstr) - MaliEngSlot1IssueCy, MaliEngSlot1IssueCy, MaliEngSFUInstr * 4) / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((max(($MaliALUInstructionsFMAPipeInstructions + $MaliALUInstructionsCVTPipeInstructions + $MaliALUInstructionsSFUPipeInstructions) - $MaliALUIssuesSlot1Issues, $MaliALUIssuesSlot1Issues, $MaliALUInstructionsSFUPipeInstructions * 4) / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((max((EXEC_INSTR_FMA + EXEC_INSTR_CVT + EXEC_INSTR_SFU) - EXEC_INSTR_SLOT_1, EXEC_INSTR_SLOT_1, EXEC_INSTR_SFU * 4) / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65646">Load/store unit utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the load/store unit. The
load/store unit is used for general-purpose memory accesses, including vertex
attribute access, buffer access, work group shared memory access, and stack
access. This unit also implements imageLoad/Store and atomic access
functionality.</p>
<p>For traditional graphics content the most significant contributor to load/store
usage is vertex data. Arm recommends simplifying mesh complexity, using fewer
triangles, fewer vertices, and fewer bytes per vertex.</p>
<p>Shaders that spill to stack are also expensive, as any spilling is multiplied
by the large number of parallel threads that are running. You can use the Mali
Offline Compiler to check your shaders for spilling.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliLSFullRd + MaliLSPartRd + MaliLSFullWr + MaliLSPartWr + MaliLSAtomic) / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliLoadStoreUnitCyclesFullReads + $MaliLoadStoreUnitCyclesPartialReads + $MaliLoadStoreUnitCyclesFullWrites + $MaliLoadStoreUnitCyclesPartialWrites + $MaliLoadStoreUnitCyclesAtomicAccesses) / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((LS_MEM_READ_FULL + LS_MEM_READ_SHORT + LS_MEM_WRITE_FULL + LS_MEM_WRITE_SHORT + LS_MEM_ATOMIC) / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65645">Varying unit utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the varying unit.</p>
<p>The most effective technique for reducing varying load is reducing the number
of interpolated values read by the fragment shading. Increasing shader usage of
16-bit input variables also helps, as they can be interpolated as twice the
speed of 32-bit variables.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVarUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((((MaliVar32IssueSlot / 4) + (MaliVar16IssueSlot / 4)) / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(((($MaliVaryingUnitRequests32BitInterpolationSlots / 4) + ($MaliVaryingUnitRequests16BitInterpolationSlots / 4)) / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((((VARY_SLOT_32 / 4) + (VARY_SLOT_16 / 4)) / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65644">Texture unit utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the texturing unit.</p>
<p>The most effective technique for reducing texturing unit load is reducing the
number of texture samples read by your shaders. Using 32bpp color formats, and
the ASTC decode mode extensions to select a 32bpp intermediate precision, can
reduce cache access cost. Using simpler texture filters can reduce filtering
cost. Using a 16bit per component sampler result can reduce data return cost.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((max(MaliTexFiltIssueCy, MaliTexCacheLookupCy, MaliTexCacheSimpleLoadCy, MaliTexCacheComplexLoadCy, MaliTexInBt, MaliTexOutBt, MaliTexL1CacheOutputCy, MaliTexL1CacheLookupCy, MaliTexIndexCy) / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((max($MaliTextureUnitCyclesFilteringActive, $MaliTextureUnitCacheCyclesCacheLookupActive, $MaliTextureUnitCacheCyclesSimpleLoadActive, $MaliTextureUnitCacheCyclesComplexLoadActive, $MaliTextureUnitBusInputBeats, $MaliTextureUnitBusOutputBeats, $MaliTextureUnitCacheCyclesL1OutputActive, $MaliTextureUnitCacheCyclesL1LookupActive, $MaliTextureUnitCyclesIndexCalculationActive) / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((max(TEX_FILT_NUM_OPERATIONS, TEX_TFCH_NUM_TCL_OPERATIONS, TEX_CFCH_NUM_DIRECT_PATH_OPERATIONS, TEX_CFCH_NUM_RP_OPERATIONS, TEX_MSGI_NUM_FLITS, TEX_RSPS_NUM_OPERATIONS, TEX_CFCH_NUM_L1_CL_OPERATIONS, TEX_CFCH_NUM_L1_CT_OPERATIONS, TEX_TIDX_NUM_OPERATIONS) / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_321">Ray tracing unit utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage utilization of the ray tracing unit.</p>
<p>The most effective technique for reducing ray tracing load is reducing the
amount of geometry in the acceleration structure, and ensuring that rays issued
in each warp are spatially coherent.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((max(MaliRTUBoxIssueCy, MaliRTUTriIssueCy) / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((max($MaliRayTracingUnitCyclesBoxTesterIssues, $MaliRayTracingUnitCyclesTriangleTesterIssues) / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((max(RT_RAY_BOX_ISSUED, RT_RAY_TRI_ISSUED) / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_shadercorebackpressurecycles">Shader Core Backpressure Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the absolute amount of backpressure being generated by
functional units that are overloaded and unable to accept more work.</p>
<p>Backpressure is a strong indicator that a unit is unable to meet requested
demand, either due to workload complexity or slow process inside the unit due
to cache misses. Reduce the size, or improving the efficiency, of the workload
for the impacted unit will improve application performance.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_377">Load/store unit backpressure <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle new work could not be sent to the
load/store unit. This indicates that the unit is overloaded and might be a
bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngLSBackpressureCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreBackpressureCyclesLoadStoreUnitBackpressure</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_MSG_STALLED_LSC</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_379">Varying unit backpressure <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle new work could not be sent to the
varying unit. This indicates that the unit is overloaded and might be a
bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngVarBackpressureCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreBackpressureCyclesVaryingUnitBackpressure</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_MSG_STALLED_VARY</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_378">Texture unit backpressure <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle new work could not be sent to the
texture unit. This indicates that the unit is overloaded and might be a
bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngTexBackpressureCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreBackpressureCyclesTextureUnitBackpressure</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_MSG_STALLED_TEX</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_367">Attribute unit backpressure <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle new work could not be sent to the
attribute unit. This indicates that the unit is overloaded and might be a
bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngAttrBackpressureCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreBackpressureCyclesAttributeUnitBackpressure</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_MSG_STALLED_ATTR</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_380">ZS unit backpressure <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle new work could not be sent to the
depth/stencil test unit. This indicates that the unit is overloaded and might
be a bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngZSBackpressureCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreBackpressureCyclesZSUnitBackpressure</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_MSG_STALLED_ZS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_376">Blend unit backpressure <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle new work could not be sent to the
blend unit. This indicates that the unit is overloaded and might be a
bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngBlendBackpressureCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreBackpressureCyclesBlendUnitBackpressure</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_MSG_STALLED_BLEND</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shadercorebackpressurerate">Shader Core Backpressure Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the relative amount of backpressure being generated by
functional units that are overloaded and unable to accept more work.</p>
<p>Backpressure is a strong indicator that a unit is unable to meet requested
demand, either due to workload complexity or slow process inside the unit due
to cache misses. Reduce the size, or improving the efficiency, of the workload
for the impacted unit will improve application performance.</p>
<div class="lgc-series">
<h4 id="c_394">Load/store unit rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of shader core cycles when new work
could not be sent to the load/store unit. A high percentage indicates that the
unit is overloaded and might be a bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngLSBackpressureRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngLSBackpressureCy / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreBackpressureCyclesLoadStoreUnitBackpressure / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_MSG_STALLED_LSC / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_396">Varying unit rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of shader core cycles when new work
could not be sent to the varying unit. A high percentage indicates that the
unit is overloaded and might be a bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngVarBackpressureRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngVarBackpressureCy / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreBackpressureCyclesVaryingUnitBackpressure / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_MSG_STALLED_VARY / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_395">Texture unit rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of shader core cycles when new work
could not be sent to the texture unit. A high percentage indicates that the
unit is overloaded and might be a bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngTexBackpressureRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngTexBackpressureCy / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreBackpressureCyclesTextureUnitBackpressure / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_MSG_STALLED_TEX / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_392">Attribute unit rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of shader core cycles when new work
could not be sent to the attribute unit. A high percentage indicates that the
unit is overloaded and might be a bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngAttrBackpressureRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngAttrBackpressureCy / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreBackpressureCyclesAttributeUnitBackpressure / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_MSG_STALLED_ATTR / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_397">ZS unit rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of shader core cycles when new work
could not be sent to the depth/stencil test unit. A high percentage indicates
that the unit is overloaded and might be a bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngZSBackpressureRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngZSBackpressureCy / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreBackpressureCyclesZSUnitBackpressure / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_MSG_STALLED_ZS / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_393">Blend unit rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of shader core cycles when new work
could not be sent to the blend unit. A high percentage indicates that the unit
is overloaded and might be a bottleneck.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngBlendBackpressureRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngBlendBackpressureCy / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderCoreBackpressureCyclesBlendUnitBackpressure / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_MSG_STALLED_BLEND / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_shadercorestallcycles">Shader Core Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles that the shader core is able to
accept new warps, but the front-end has no new warp ready to run. This might be
because the front-end is a bottleneck, or because the workload requires no
warps to be spawned.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_383">Fragment main pass stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when a fragment main pass cannot
start because the fragment main pass is waiting for a prepass result.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragMainPassStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreStallCyclesFragmentMainPassStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_MAIN_PASS_STALLED_BY_PRE_PASS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_236">Execution engine starvation <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the processing unit is starved
of work because all warps are blocked on message dependencies or instruction
cache misses.</p>
<p>This counter increments per fetch unit, and so can increase by up to 4 in a
clock cycle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngStarveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreStallCyclesExecutionEngineStarvation</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_STARVE_ARITH</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercoreworkload">Shader Core Workload <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The programmable core runs the shader program threads that generate the desired
application output.</p>
<p>Performance counters in this section show how the programmable core converts
incoming work into the threads and warps running in the shader core, as well as
other important properties of the running workload such as warp divergence.</p>
<div class="lgc-group">
<h3 id="g_shaderwarps">Shader Warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of warps created, split by type. This can
help you to understand the running workload mix.</p>
<div class="lgc-series">
<h4 id="c_228">Non-fragment warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every created non-fragment warp. For this GPU, a
warp contains <a href="#c_65649">16</a> threads.</p>
<p>For compute shaders, to ensure full utilization of the warp capacity, work
groups must be a multiple of warp size.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliNonFragWarp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderWarpsNonFragmentWarps</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>COMPUTE_WARPS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_366">Deferred vertex warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every created deferred vertex warp. For this GPU, a
warp contains <a href="#c_65649">16</a> threads.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliDefVertWarp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderWarpsDeferredVertexWarps</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>DVS_WARPS</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_214">Fragment warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every created fragment warp. For this GPU, a warp
contains <a href="#c_65649">16</a> threads.</p>
<p>Fragment warps are populated with fragment quads, where each quad corresponds
to a 2x2 fragment region from a single triangle. Threads in a quad which
correspond to a sample point outside of the triangle still consume shader
resource, which makes small triangles disproportionately expensive.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragWarp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderWarpsFragmentWarps</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_WARPS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_381">Fragment prepass warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every created fragment prepass warp. For this GPU,
a warp contains <a href="#c_65649">16</a> threads.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassWarp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderWarpsFragmentPrepassWarps</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_WARPS_PRE_PASS</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_232">Full warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every warp that has a full thread slot allocation.
Note that allocated thread slots might not contain a running thread if the
workload cannot fill the whole allocation.</p>
<p>If many warps are not fully allocated then performance is reduced. Fully
allocated warps are more likely if:</p>
<ul>
<li>Draw calls avoid late ZS dependency hazards.</li>
<li>Draw calls use meshes with a low percentage of tiny primitives.</li>
<li>Compute dispatches use work groups that are a multiple of warp size.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreFullWarp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderWarpsFullWarps</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FULL_QUAD_WARPS</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_231">All register warps <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every warp that requires more than 32 registers.
Threads which require more than 32 registers consume two thread slots in the
register file, halving the number of threads that can be concurrently active in
the shader core.</p>
<p>Reduction in thread count can impact the ability of the shader core to keep
functional units busy, and means that performance is more likely to be impacted
by stalls caused by cache misses.</p>
<p>Aim to minimize the number of threads requiring more than 32 registers, by
using simpler shader programs and lower precision data types.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreAllRegsWarp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderWarpsAllRegisterWarps</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>WARP_REG_SIZE_64</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shaderthreads">Shader Threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of threads created, split by type. This can
help you to understand the running workload mix.</p>
<p>Counters in this group are derived by scaling quad or warp counters, and their
counts will include unused thread slots in the coarser granule.</p>
<div class="lgc-series">
<h4 id="c_65591">Non-fragment threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of non-fragment threads started.</p>
<p>The expression is an approximation, based on the assumption that all warps are
fully populated with threads. The <a href="#c_232">Full warps</a> counter can
give some indication of warp occupancy.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliNonFragThread</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliNonFragWarp * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderWarpsNonFragmentWarps * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>COMPUTE_WARPS * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65572">All fragment threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter defines the total number of fragment threads started, including
prepass and main pass threads. This counter assumes all 4 lanes in a coarse
quad are active, so this counter includes helper threads and idle thread slots
if a coarse quad has partial coverage.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragThread</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderThreadsAllFragmentThreads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>FRAG_SHADER_THREADS</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_382">Fragment prepass threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of fragment threads started in the prepass.
This expression assumes all lanes in a warp are active.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragPrepassThread</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliFragPrepassWarp * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderWarpsFragmentPrepassWarps * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>FRAG_WARPS_PRE_PASS * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_462">Fragment main pass threads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of fragment threads started in the main
pass. This expression assumes all lanes in a warp are active.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliFragMainThread</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliFragWarp - MaliFragPrepassWarp) * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderWarpsFragmentWarps - $MaliShaderWarpsFragmentPrepassWarps) * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(FRAG_WARPS - FRAG_WARPS_PRE_PASS) * 16</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shaderworkloadproperties">Shader Workload Properties <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows interesting properties of the running shader code,
most of which highlight an interesting optimization opportunity.</p>
<div class="lgc-series">
<h4 id="c_320">Fragment warp occupancy <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression measures the thread occupancy of the fragment warps in percent.
Threads are counted as active if they are part of a coarse quad, even if they
have no sample coverage.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreFragWarpOcc</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliFragThread / (MaliFragWarp * 16)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderThreadsAllFragmentThreads / ($MaliShaderWarpsFragmentWarps * 16)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FRAG_SHADER_THREADS / (FRAG_WARPS * 16)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65598">Full warp rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of warps that have a full thread slot
allocation. Note that allocated thread slots might not contain a running thread
if the workload cannot fill the whole allocation.</p>
<p>If a high percentage of warps are not fully allocated then performance is
reduced. Fully allocated warps are more likely if:</p>
<ul>
<li>Draw calls avoid late ZS dependency hazards.</li>
<li>Draw calls use meshes with a low percentage of tiny primitives.</li>
<li>Compute dispatches use work groups that are a multiple of warp size.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreFullWarpRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCoreFullWarp / (MaliNonFragWarp + MaliFragWarp)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderWarpsFullWarps / ($MaliShaderWarpsNonFragmentWarps + $MaliShaderWarpsFragmentWarps)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((FULL_QUAD_WARPS / (COMPUTE_WARPS + FRAG_WARPS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65597">All registers warp rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of warps that use more than 32
registers, requiring the full register allocation of 64 registers. Warps that
require more than 32 registers halve the peak thread occupancy of the shader
core, and can make shader performance more sensitive to cache misses and memory
stalls.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliCoreAllRegsWarpRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliCoreAllRegsWarp / (MaliNonFragWarp + MaliFragWarp)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliShaderWarpsAllRegisterWarps / ($MaliShaderWarpsNonFragmentWarps + $MaliShaderWarpsFragmentWarps)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((WARP_REG_SIZE_64 / (COMPUTE_WARPS + FRAG_WARPS)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65599">Warp divergence rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of instructions that have control flow
divergence across the warp.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngDivergedInstrRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngDivergedInstr / (MaliEngFMAInstr + MaliEngCVTInstr + MaliEngSFUInstr)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliALUInstructionsDivergedInstructions / ($MaliALUInstructionsFMAPipeInstructions + $MaliALUInstructionsCVTPipeInstructions + $MaliALUInstructionsSFUPipeInstructions)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_INSTR_DIVERGED / (EXEC_INSTR_FMA + EXEC_INSTR_CVT + EXEC_INSTR_SFU)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_318">Narrow arithmetic rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of arithmetic instructions that operate
on 8/16-bit types. These are more energy efficient, and require fewer registers
for variable storage, than 32-bit operations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngNarrowInstrRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngNarrowInstr / (MaliEngFMAInstr + MaliEngCVTInstr + MaliEngSFUInstr)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliALUInstructionsNarrowInstructions / ($MaliALUInstructionsFMAPipeInstructions + $MaliALUInstructionsCVTPipeInstructions + $MaliALUInstructionsSFUPipeInstructions)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_INSTR_NARROW / (EXEC_INSTR_FMA + EXEC_INSTR_CVT + EXEC_INSTR_SFU)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65658">Shader blend rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of fragments that use shader-based
blending, rather than the fixed-function blend path. These fragments are caused
by the application using color formats, or advanced blend equations, which the
fixed-function blend path does not support.</p>
<p>Vulkan shaders that use software blending do not show up in this data, because
the blend is inlined in to the main body of the shader program.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngSWBlendRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliEngSWBlendInstr * 4) / MaliFragWarp) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliALUInstructionsBlendShaderInstructions * 4) / $MaliShaderWarpsFragmentWarps) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((CALL_BLEND_SHADER * 4) / FRAG_WARPS) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercorearithmeticunit">Shader Core Arithmetic Unit <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The arithmetic unit in the shader core processes all the arithmetic and logic
operations in the running shader programs.</p>
<p>Performance counters in this section show how the running programs used the
arithmetic units, which may indicate the type of operations that are consuming
the most performance.</p>
<div class="lgc-group">
<h3 id="g_alucycles">ALU Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles when work was issued to the
arithmetic and logic unit.</p>
<div class="lgc-series">
<h4 id="c_556">Arithmetic unit issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of cycles that the arithmetic unit was busy
processing work.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliALUIssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max((MaliEngFMAInstr + MaliEngCVTInstr + MaliEngSFUInstr) - MaliEngSlot1IssueCy, MaliEngSlot1IssueCy, MaliEngSFUInstr * 4)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(($MaliALUInstructionsFMAPipeInstructions + $MaliALUInstructionsCVTPipeInstructions + $MaliALUInstructionsSFUPipeInstructions) - $MaliALUIssuesSlot1Issues, $MaliALUIssuesSlot1Issues, $MaliALUInstructionsSFUPipeInstructions * 4)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max((EXEC_INSTR_FMA + EXEC_INSTR_CVT + EXEC_INSTR_SFU) - EXEC_INSTR_SLOT_1, EXEC_INSTR_SLOT_1, EXEC_INSTR_SFU * 4)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_instructioncache">Instruction Cache <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group monitors the behavior of the instruction cache.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_245">I-cache misses <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction cache miss.</p>
<p>Note that the instruction cache is shared across both processing units. Unlike
most processing unit counters this counter increments for cache misses from
both units.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngICacheMiss</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliInstructionCacheICacheMisses</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_ICACHE_MISS</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_aluinstructions">ALU Instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group gives a breakdown of the types of arithmetic instructions
being used by the shader program.</p>
<div class="lgc-series">
<h4 id="c_65668">Executed instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of total instructions issued to any of the
arithmetic pipe types.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngArithInstr</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliEngFMAInstr + MaliEngCVTInstr + MaliEngSFUInstr</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliALUInstructionsFMAPipeInstructions + $MaliALUInstructionsCVTPipeInstructions + $MaliALUInstructionsSFUPipeInstructions</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>EXEC_INSTR_FMA + EXEC_INSTR_CVT + EXEC_INSTR_SFU</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_241">FMA pipe instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction issued to the fused
multiply-accumulate pipe.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngFMAInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUInstructionsFMAPipeInstructions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_INSTR_FMA</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_242">CVT pipe instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction issued to the convert pipe.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngCVTInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUInstructionsCVTPipeInstructions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_INSTR_CVT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_243">SFU pipe instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction issued to the special functions
unit pipe.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngSFUInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUInstructionsSFUPipeInstructions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_INSTR_SFU</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_235">Diverged instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction the programmable core processes
per warp where there is control flow divergence across the warp. Control flow
divergence erodes arithmetic processing efficiency because it implies some
threads in the warp are idle because they did not take the current control path
through the code. Aim to minimize control flow divergence when designing shader
effects.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngDivergedInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUInstructionsDivergedInstructions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_INSTR_DIVERGED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_302">Narrow instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction that does 16-bit or narrower
calculations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngNarrowInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUInstructionsNarrowInstructions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_INSTR_NARROW</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_247">Blend shader instructions <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every blend shader invocation run.</p>
<p>This counter increments per fetch unit, and so can increase by up to 4 in a
clock cycle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngSWBlendInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUInstructionsBlendShaderInstructions</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>CALL_BLEND_SHADER</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_aluutilization">ALU Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group gives a breakdown of the usage of the different arithmetic
sub-units, relative to their speed-of-light performance.</p>
<p>Due to shared issue data paths, it might not be possible for individual ALU
units to reach their speed-of-light if the other ALU hardware units are also in
use.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65601">FMA pipe utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the fused multiply-accumulate pipeline utilization.</p>
<p>This pipeline shares instruction issue slots with CVT and SFU instructions, so
it is not possible to achieve 100% utilization unless the other pipelines are
idle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngFMAPipeUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngFMAInstr / (2 * MaliCoreActiveCy)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliALUInstructionsFMAPipeInstructions / (2 * $MaliShaderCoreCyclesExecutionCoreActive)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_INSTR_FMA / (2 * EXEC_CORE_ACTIVE)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65602">CVT pipe utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the convert pipeline utilization.</p>
<p>This pipeline shares instruction issue slots with FMA and SFU instructions, so
it is not possible to achieve 100% utilization unless the other pipelines are
idle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngCVTPipeUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliEngCVTInstr / (2 * MaliCoreActiveCy)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliALUInstructionsCVTPipeInstructions / (2 * $MaliShaderCoreCyclesExecutionCoreActive)) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((EXEC_INSTR_CVT / (2 * EXEC_CORE_ACTIVE)) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65603">SFU pipe utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the special functions unit pipeline utilization.</p>
<p>This pipeline shares instruction issue slots with CVT and SFU instructions, so
it is not possible to achieve 100% utilization unless the other pipelines are
idle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngSFUPipeUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min(((MaliEngSFUInstr * 4) / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min((($MaliALUInstructionsSFUPipeInstructions * 4) / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min(((EXEC_INSTR_SFU * 4) / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_aluissues">ALU Issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group gives a breakdown of the usage of the arithmetic instruction
issue ports. Issue port contention will usually become a bottleneck before
individual functional pipelines, as pipelines often share issue port bandwidth.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_375">Any slot issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when issues an instruction to
either arithmetic issue slot.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngSlotAnyIssueCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUIssuesAnySlotIssues</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_ISSUE_SLOT_ANY</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_391">Slot 0 issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when issues an instruction to
issue slot 0.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngSlot0IssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliEngFMAInstr + MaliEngCVTInstr + MaliEngSFUInstr) - MaliEngSlot1IssueCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliALUInstructionsFMAPipeInstructions + $MaliALUInstructionsCVTPipeInstructions + $MaliALUInstructionsSFUPipeInstructions) - $MaliALUIssuesSlot1Issues</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(EXEC_INSTR_FMA + EXEC_INSTR_CVT + EXEC_INSTR_SFU) - EXEC_INSTR_SLOT_1</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_374">Slot 1 issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when issues an instruction to
issue slot 1.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliEngSlot1IssueCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliALUIssuesSlot1Issues</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>EXEC_INSTR_SLOT_1</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercoreloadstoreunit">Shader Core Load/store Unit <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The load/store unit in the shader core handles all generic read/write data
access, including access to vertex attributes, buffers, images, workgroup local
storage, and program stack.</p>
<p>Performance counters in this section show the breakdown of performed load/store
cache accesses, showing whether accesses are using an entire cache line or just
using part of one.</p>
<div class="lgc-group">
<h3 id="g_loadstoreunitcycles">Load/Store Unit Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles when work was issued to the
load/store unit.</p>
<div class="lgc-series">
<h4 id="c_65629">Load/store unit issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of load/store cache access cycles.
This counter ignores secondary effects such as cache misses, so provides the
minimum possible cycle usage.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSIssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliLSFullRd + MaliLSPartRd + MaliLSFullWr + MaliLSPartWr + MaliLSAtomic</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliLoadStoreUnitCyclesFullReads + $MaliLoadStoreUnitCyclesPartialReads + $MaliLoadStoreUnitCyclesFullWrites + $MaliLoadStoreUnitCyclesPartialWrites + $MaliLoadStoreUnitCyclesAtomicAccesses</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>LS_MEM_READ_FULL + LS_MEM_READ_SHORT + LS_MEM_WRITE_FULL + LS_MEM_WRITE_SHORT + LS_MEM_ATOMIC</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65627">Reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of load/store read cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSRdCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliLSFullRd + MaliLSPartRd</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliLoadStoreUnitCyclesFullReads + $MaliLoadStoreUnitCyclesPartialReads</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>LS_MEM_READ_FULL + LS_MEM_READ_SHORT</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_275">Full reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every full-width load/store cache read.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSFullRd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliLoadStoreUnitCyclesFullReads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LS_MEM_READ_FULL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_276">Partial reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every partial-width load/store cache read. Partial
data accesses do not make full use of the load/store cache capability. Merging
short accesses together to make fewer larger requests improves efficiency. To
do this in shader code:</p>
<ul>
<li>Use vector data loads.</li>
<li>Avoid padding in strided data accesses.</li>
<li>Write compute shaders so that adjacent threads in a warp access adjacent
  addresses in memory.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSPartRd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliLoadStoreUnitCyclesPartialReads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LS_MEM_READ_SHORT</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_65628">Writes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of load/store write cycles.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSWrCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliLSFullWr + MaliLSPartWr</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliLoadStoreUnitCyclesFullWrites + $MaliLoadStoreUnitCyclesPartialWrites</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>LS_MEM_WRITE_FULL + LS_MEM_WRITE_SHORT</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_277">Full writes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every full-width load/store cache write.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSFullWr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliLoadStoreUnitCyclesFullWrites</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LS_MEM_WRITE_FULL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_278">Partial writes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every partial-width load/store cache write. Partial
data accesses do not make full use of the load/store cache capability. Merging
short accesses together to make fewer larger requests improves efficiency. To
do this in shader code:</p>
<ul>
<li>Use vector data loads.</li>
<li>Avoid padding in strided data accesses.</li>
<li>Write compute shaders so that adjacent threads in a warp access adjacent
  addresses in memory.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSPartWr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliLoadStoreUnitCyclesPartialWrites</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LS_MEM_WRITE_SHORT</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_279">Atomic accesses <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every atomic access.</p>
<p>Atomic memory accesses are typically multicycle operations per thread in the
warp, so they are exceptionally expensive. Minimize the use of atomics in
performance critical code. For some types of atomic operation, it can be
beneficial to perform a warp-wide reduction using subgroup operations and then
use a single thread to update the atomic value.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliLSAtomic</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliLoadStoreUnitCyclesAtomicAccesses</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>LS_MEM_ATOMIC</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercorevaryingunit">Shader Core Varying Unit <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The varying unit in the shader core handles all vertex data interpolation in
fragment shaders.</p>
<p>Performance counters in this section show the breakdown of performed
interpolation operations.</p>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_varyingunitrequests">Varying Unit Requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of requests made to the varying
interpolation unit.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_280">Interpolation requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every warp-width interpolation operation processed
by the varying unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVarInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliVaryingUnitRequestsInterpolationRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VARY_INSTR</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_324">16-bit interpolation slots <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every 16-bit interpolation slot processed by the
varying unit.</p>
<p>The width of each slot and the number of slots is GPU dependent.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVar16IssueSlot</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliVaryingUnitRequests16BitInterpolationSlots</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VARY_SLOT_16</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_323">32-bit interpolation slots <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every 32-bit interpolation slot processed by the
varying unit. 32-bit interpolation is half the performance of 16-bit
interpolation, so if content is varying bound consider reducing precision of
varying inputs to fragment shaders.</p>
<p>The width of each slot and the number of slots is GPU dependent.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVar32IssueSlot</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliVaryingUnitRequests32BitInterpolationSlots</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VARY_SLOT_32</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_varyingunitcycles">Varying Unit Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles when work was issued to the
varying interpolation unit.</p>
<div class="lgc-series">
<h4 id="c_65630">Varying unit issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of cycles when the varying
interpolator is issuing operations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVarIssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliVar32IssueSlot / 4) + (MaliVar16IssueSlot / 4)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliVaryingUnitRequests32BitInterpolationSlots / 4) + ($MaliVaryingUnitRequests16BitInterpolationSlots / 4)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(VARY_SLOT_32 / 4) + (VARY_SLOT_16 / 4)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_282">16-bit interpolation issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every 16-bit interpolation cycle processed by the
varying unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVar16IssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliVar16IssueSlot / 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliVaryingUnitRequests16BitInterpolationSlots / 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>VARY_SLOT_16 / 4</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_281">32-bit interpolation issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every 32-bit interpolation cycle processed by the
varying unit. 32-bit interpolation is half the performance of 16-bit
interpolation, so if content is varying bound consider reducing precision of
varying inputs to fragment shaders.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVar32IssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliVar32IssueSlot / 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliVaryingUnitRequests32BitInterpolationSlots / 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>VARY_SLOT_32 / 4</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercoretextureunit">Shader Core Texture Unit <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The texture unit in the shader core handles all read-only texture access and
filtering.</p>
<p>Performance counters in this section show the breakdown of performed texturing
operations, and use of sub-units inside the texturing hardware.</p>
<div class="lgc-group">
<h3 id="g_textureunitrequests">Texture Unit Requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of requests made to the texture unit.</p>
<div class="lgc-series">
<h4 id="c_65609">Texture samples <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the number of texture samples made.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexSample</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>((MaliTexOutMsg * 2) - MaliTexOutSingleMsg) * 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>(($MaliTextureUnitQuadsTextureMessages * 2) - $MaliTextureUnitQuadsTextureMessagesWithSingleQuad) * 4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>((TEX_MSGO_NUM_MSG * 2) - TEX_MSGO_NUM_SINGLE_QUAD_MSG) * 4</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitquads">Texture Unit Quads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of fragment quads submitted to the texture
unit for sampling.</p>
<div class="lgc-series">
<h4 id="c_257">Texture requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every quad-width texture operation processed by the
texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexQuads</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliTexOutMsg * 2) - MaliTexOutSingleMsg</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliTextureUnitQuadsTextureMessages * 2) - $MaliTextureUnitQuadsTextureMessagesWithSingleQuad</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(TEX_MSGO_NUM_MSG * 2) - TEX_MSGO_NUM_SINGLE_QUAD_MSG</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_315">Texture messages <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every texture message emitted by the texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexOutMsg</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitQuadsTextureMessages</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_MSGO_NUM_MSG</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_337">Texture messages with single quad <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every texture message emitted by the texture unit
which only contains a single quad.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexOutSingleMsg</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitQuadsTextureMessagesWithSingleQuad</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_MSGO_NUM_SINGLE_QUAD_MSG</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitcycles">Texture Unit Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles when work was issued to the
sub-units inside the texture unit.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_346">Texture unit clock active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the texture unit is active,
and contains an active sample message.</p>
<p>A high active time does not imply a high utilization. The unit counts as active
even if only a single pipeline stage is busy.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexClkActiveCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCyclesTextureUnitClockActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_TEXP_CLK_ACTIVE</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_457">Texture unit issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression measures the number of cycles the texture unit was busy
processing work.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexIssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(MaliTexFiltIssueCy, MaliTexCacheLookupCy, MaliTexCacheSimpleLoadCy, MaliTexCacheComplexLoadCy, MaliTexInBt, MaliTexOutBt, MaliTexL1CacheOutputCy, MaliTexL1CacheLookupCy, MaliTexIndexCy)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max($MaliTextureUnitCyclesFilteringActive, $MaliTextureUnitCacheCyclesCacheLookupActive, $MaliTextureUnitCacheCyclesSimpleLoadActive, $MaliTextureUnitCacheCyclesComplexLoadActive, $MaliTextureUnitBusInputBeats, $MaliTextureUnitBusOutputBeats, $MaliTextureUnitCacheCyclesL1OutputActive, $MaliTextureUnitCacheCyclesL1LookupActive, $MaliTextureUnitCyclesIndexCalculationActive)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(TEX_FILT_NUM_OPERATIONS, TEX_TFCH_NUM_TCL_OPERATIONS, TEX_CFCH_NUM_DIRECT_PATH_OPERATIONS, TEX_CFCH_NUM_RP_OPERATIONS, TEX_MSGI_NUM_FLITS, TEX_RSPS_NUM_OPERATIONS, TEX_CFCH_NUM_L1_CL_OPERATIONS, TEX_CFCH_NUM_L1_CT_OPERATIONS, TEX_TIDX_NUM_OPERATIONS)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_344">Index calculation active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the texture unit is
computing a texel index value.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexIndexCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCyclesIndexCalculationActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_TIDX_NUM_OPERATIONS</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_253">Filtering active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every texture filtering issue cycle. This GPU can
do <a href="#c_65610">8</a>x 2D bilinear texture samples per clock. More
complex filtering operations are composed of multiple 2D bilinear samples, and
take proportionally more filtering time to complete. The scaling factors for
more expensive operations are:</p>
<ul>
<li>2D trilinear filtering runs at half speed.</li>
<li>3D bilinear filtering runs at half speed.</li>
<li>3D trilinear filtering runs at quarter speed.</li>
</ul>
<p>Anisotropic filtering makes up to MAX_ANISOTROPY filtered subsamples of the
current base filter type. For example, using trilinear filtering with a
MAX_ANISOTROPY of 3 will require up to 6 bilinear filters.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexFiltIssueCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCyclesFilteringActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_FILT_NUM_OPERATIONS</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitstallcycles">Texture Unit Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of stall cycles when work could not be
issued to the sub-units inside the texture unit.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_343">Texture causing starvation <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the texture unit is active
and a response message could be accepted, but no response was generated.</p>
<p>A high value here can be indicative of a inefficient texturing operations which
are failing to sustain full throughput, and can be caused by a high miss rate
in either descriptor or data cache, or complex multicycle filtering operations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexClkStarvedCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitStallCyclesTextureCausingStarvation</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_MSGI_CLK_STARVED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_270">Descriptor stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle a quad is stalled on texture
descriptor fetch. This might not correspond to a stall cycle in the filtering
unit if there is enough work already buffered after the descriptor fetcher to
hide the stall.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexDescStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitStallCyclesDescriptorStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_DFCH_CLK_STALLED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_271">Fetch queue stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle a quad is stalled on entering
texture fetch because the fetch queue is full. This might not correspond to a
stall cycle in the filtering unit if there is enough work already buffered to
hide the stall.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexDataFetchStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitStallCyclesFetchQueueStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_TFCH_CLK_STALLED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_272">Filtering unit stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle the filtering unit is idle and
there is at least one quad present in the texture data fetch queue. A high
stall rate here can be indicative of content which is failing to make good use
of the texture cache. For example, under-sampling from a high resolution
texture.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexFiltStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitStallCyclesFilteringUnitStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_TFCH_STARVED_PENDING_DATA_FETCH</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitcpi">Texture Unit CPI <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the average cost of texture samples.</p>
<div class="lgc-series">
<h4 id="c_65626">Texture CPI <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of texture filtering cycles per
instruction. For texture-limited content that has a CPI higher than the optimal
throughout of this core (<a href="#c_65610">8</a> samples per cycle), consider
using simpler texture filters. See <a href="#c_457">Texture unit issue
cycles</a> for details of the expected performance for different types of
operation.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexCPI</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(MaliTexFiltIssueCy, MaliTexCacheLookupCy, MaliTexCacheSimpleLoadCy, MaliTexCacheComplexLoadCy, MaliTexInBt, MaliTexOutBt, MaliTexL1CacheOutputCy, MaliTexL1CacheLookupCy, MaliTexIndexCy) / (((MaliTexOutMsg * 2) - MaliTexOutSingleMsg) * 4)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max($MaliTextureUnitCyclesFilteringActive, $MaliTextureUnitCacheCyclesCacheLookupActive, $MaliTextureUnitCacheCyclesSimpleLoadActive, $MaliTextureUnitCacheCyclesComplexLoadActive, $MaliTextureUnitBusInputBeats, $MaliTextureUnitBusOutputBeats, $MaliTextureUnitCacheCyclesL1OutputActive, $MaliTextureUnitCacheCyclesL1LookupActive, $MaliTextureUnitCyclesIndexCalculationActive) / ((($MaliTextureUnitQuadsTextureMessages * 2) - $MaliTextureUnitQuadsTextureMessagesWithSingleQuad) * 4)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(TEX_FILT_NUM_OPERATIONS, TEX_TFCH_NUM_TCL_OPERATIONS, TEX_CFCH_NUM_DIRECT_PATH_OPERATIONS, TEX_CFCH_NUM_RP_OPERATIONS, TEX_MSGI_NUM_FLITS, TEX_RSPS_NUM_OPERATIONS, TEX_CFCH_NUM_L1_CL_OPERATIONS, TEX_CFCH_NUM_L1_CT_OPERATIONS, TEX_TIDX_NUM_OPERATIONS) / (((TEX_MSGO_NUM_MSG * 2) - TEX_MSGO_NUM_SINGLE_QUAD_MSG) * 4)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitutilization">Texture Unit Utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the use of some of the functional units and data paths
inside the texture unit, relative to their speed-of-light capability.</p>
<div class="lgc-series">
<h4 id="c_65618">Input bus utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage load on the texture message input bus.</p>
<p>If bus utilization is higher than the filtering unit utilization, your content
might be limited by texture operation parameter passing. Requests that require
more input parameters, such as 3D accesses, array accesses, and accesses using
an explicit level-of-detail, place a higher load on the bus than basic 2D
texture operations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexInBusUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliTexInBt / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliTextureUnitBusInputBeats / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((TEX_MSGI_NUM_FLITS / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65619">Output bus utilization <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage load on the texture message output bus.</p>
<p>If bus utilization is higher than the filtering unit utilization, your content
might be limited by texture result return. Requests that require higher
precision sampler return type place a higher load on the bus, so it is
recommended to use a 16-bit sampler precision whenever possible.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexOutBusUtil</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliTexOutBt / MaliCoreActiveCy) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliTextureUnitBusOutputBeats / $MaliShaderCoreCyclesExecutionCoreActive) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((TEX_RSPS_NUM_OPERATIONS / EXEC_CORE_ACTIVE) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_textureunitcachecycles">Texture Unit Cache Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cache access cycles for the data caches
inside the texture unit.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_345">Cache lookup active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the texture cache is
returning data.</p>
<p>A high value here can be indicative of a inefficient post-decompression texture
formats. For example, a 64-bpp format takes twice as long as a 32-bpp format.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexCacheLookupCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCacheCyclesCacheLookupActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_TFCH_NUM_TCL_OPERATIONS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_342">L1 load active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when data is being transferred
into the L1 texture cache.</p>
<p>A high value here can be indicative of a high cache miss rate in the texture
data cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexL1CacheLoadCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCacheCyclesL1LoadActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_CFCH_NUM_OUTPUT_OPERATIONS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_340">L1 lookup active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the L1 texture cache is
being accessed.</p>
<p>A high value here can be indicative of a high cache miss rate in the texture
data cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexL1CacheLookupCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCacheCyclesL1LookupActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_CFCH_NUM_L1_CT_OPERATIONS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_341">L1 output active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the L1 texture cache is
returning data for a sampling operation.</p>
<p>A high value here can be indicative of a high cache miss rate in the texture
data cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexL1CacheOutputCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCacheCyclesL1OutputActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_CFCH_NUM_L1_CL_OPERATIONS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_338">Simple load active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the texture cache is
fetching formats with simple data layouts using the direct path.</p>
<p>A high value here can be indicative of a high cache miss rate in the texture
data cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexCacheSimpleLoadCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCacheCyclesSimpleLoadActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_CFCH_NUM_DIRECT_PATH_OPERATIONS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_339">Complex load active <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when the texture cache is
fetching formats with complex data layouts using the decompressor path.</p>
<p>A high value here can be indicative of a high cache miss rate in the texture
data cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexCacheComplexLoadCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitCacheCyclesComplexLoadActive</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_CFCH_NUM_RP_OPERATIONS</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_textureunitbus">Texture Unit Bus <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bus cycles used on the texture unit
memory bus connecting the texture unit to the rest of the shader core.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_267">Input beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle of input request data sent to the
texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexInBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitBusInputBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_MSGI_NUM_FLITS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_268">Output beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle of output response data sent by
the texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexOutBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTextureUnitBusOutputBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>TEX_RSPS_NUM_OPERATIONS</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercoreraytracingunit">Shader Core Ray Tracing Unit <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The ray tracing unit in the shader core handles in the shader core handles
hardware accelerated bounding box and triangle intersection testing.</p>
<p>Performance counters in this section show the breakdown of performed
intersections tests texturing operations, and use of sub-units inside the
texture unit.</p>
<div class="lgc-group">
<h3 id="g_raytracingunitcycles">Ray Tracing Unit Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles when work was issued to the ray
tracing unit and the various sub-units inside it.</p>
<div class="lgc-series">
<h4 id="c_429">Ray tracing issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of cycles when the ray tracing unit
was issuing work to a functional unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUIssueCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(MaliRTUBoxIssueCy, MaliRTUTriIssueCy)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max($MaliRayTracingUnitCyclesBoxTesterIssues, $MaliRayTracingUnitCyclesTriangleTesterIssues)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(RT_RAY_BOX_ISSUED, RT_RAY_TRI_ISSUED)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_313">Box tester issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle the ray tracing unit issues a box
intersection operation. If this counter is a high percentage of shader core
active, then shader performance might be limited by acceleration structure
traversal.</p>
<p>The main workload for ray tracing is traversing the acceleration structure so
this counter is expected to be high. If the counter is not high, and a
significant number of rays are being used, it indicates that a bottleneck
exists elsewhere.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUBoxIssueCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitCyclesBoxTesterIssues</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_BOX_ISSUED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_314">Triangle tester issues <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle the ray tracing unit issues a
triangle intersection test. If this counter is a high percentage of shader core
active, then shader performance might be limited by triangle testing.</p>
<p>A good acceleration structure culls most triangles using box tests higher up
the tree, so that rays do not need to be tested against them. If this counter
is high it might indicate an issue with either geometry complexity or
acceleration structure efficiency.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUTriIssueCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitCyclesTriangleTesterIssues</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_TRI_ISSUED</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_raytracingunitrays">Ray Tracing Unit Rays <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of rays processed by the ray tracing unit,
including a breakdown of any interesting ray properties.</p>
<div class="lgc-series">
<h4 id="c_312">Started rays <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every ray that is started and tested against the
root node in the acceleration structure.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTURay</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitRaysStartedRays</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAYS_STARTED</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_310">First hit terminated rays <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every ray that terminates on its first triangle
hit. Rays that terminate on first hit are more efficient to process, as they do
not need to keep testing to find the closest hit.</p>
<p>First-hit tests are well suited to techniques that determine occlusion, such as
shadow mapping. In these use cases you don't need to know which object is hit,
just that an object was hit between the ray source and destination.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUFirstHitTerm</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitRaysFirstHitTerminatedRays</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_TERM_FIRST_HIT</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_311">Triangle misses <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every ray-triangle intersection test that does not
intersect the triangle.</p>
<p>Most triangles that a ray misses are expected to be culled by box tests during
acceleration structure traversal, so if rays are triggering a high number of
triangle intersection tests, try improving the acceleration structure quality.</p>
<p>A high number for this counter might also indicate a programming error, such as
using opaque triangles and requesting that opaque hits be culled.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUMiss</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitRaysTriangleMisses</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_MISS</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_raytracingunittriangletests">Ray Tracing Unit Triangle Tests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the histogram of triangle test unit occupancy, which
schedules tests on warp-width vectors. Warps with divergent rays will result in
tests with a subset of lanes active, which reduces efficiency.</p>
<div class="lgc-series">
<h4 id="c_265">Nodes with 1-4 rays <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This count increments for every triangle node tested when there are between 1
and 4 active rays in the warp. A high percentage of tests with low warp
occupancy can indicate an issue with ray coherency. Try to group rays with
similar origin, direction, and range together.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUTriBin1</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitTriangleTestsNodesWith14Rays</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_TRI_BIN_1_4</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_266">Nodes with 5-8 rays <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This count increments for every triangle node tested when there are between 5
and 8 active rays in the warp. A high percentage of tests with low warp
occupancy can indicate an issue with ray coherency. Try to group rays with
similar origin, direction, and range together.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUTriBin5</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitTriangleTestsNodesWith58Rays</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_TRI_BIN_5_8</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_269">Nodes with 9-12 rays <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This count increments for every triangle node tested when there are between 9
and 12 active rays in the warp. A high percentage of tests with low warp
occupancy can indicate an issue with ray coherency. Try to group rays with
similar origin, direction, and range together.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUTriBin9</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitTriangleTestsNodesWith912Rays</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_TRI_BIN_9_12</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_303">Nodes with 13-16 rays <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This count increments for every triangle node tested when there are between 13
and 16 active rays in the warp.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUTriBin13</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitTriangleTestsNodesWith1316Rays</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_TRI_BIN_13_16</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_raytracingunitboxtests">Ray Tracing Unit Box Tests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the histogram of bounding box test unit occupancy,
which schedules tests on warp-width vectors. Warps with divergent rays will
result in tests with a subset of lanes active, which reduces efficiency.</p>
<div class="lgc-series">
<h4 id="c_304">Nodes with 1-4 rays <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This count increments for every acceleration structure box node tested when
there are between 1 and 4 active rays in the warp. A high percentage of tests
with low warp occupancy can indicate an issue with ray coherency. Try to group
rays with similar origin, direction, and range together.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUBoxBin1</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitBoxTestsNodesWith14Rays</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_BOX_BIN_1_4</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_305">Nodes with 5-8 rays <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This count increments for every acceleration structure box node tested when
there are between 5 and 8 active rays in the warp. A high percentage of tests
with low warp occupancy can indicate an issue with ray coherency. Try to group
rays with similar origin, direction, and range together.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUBoxBin5</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitBoxTestsNodesWith58Rays</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_BOX_BIN_5_8</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_306">Nodes with 9-12 rays <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This count increments for every acceleration structure box node tested when
there are between 9 and 12 active rays in the warp. A high percentage of tests
with low warp occupancy can indicate an issue with ray coherency. Try to group
rays with similar origin, direction, and range together.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUBoxBin9</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitBoxTestsNodesWith912Rays</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_BOX_BIN_9_12</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_307">Nodes with 13-16 rays <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This count increments for every acceleration structure box node tested when
there are between 13 and 16 active rays in the warp.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUBoxBin13</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitBoxTestsNodesWith1316Rays</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_BOX_BIN_13_16</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_raytracingunitboxworkload">Ray Tracing Unit Box Workload <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bounding box tests processed by the box
test unit, including the split between TLAS and BLAS box tests.</p>
<div class="lgc-series">
<h4 id="c_246">Box tests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every acceleration structure bounding box node
tested. If this value is high then the ray tracing unit spent a lot of time
traversing the acceleration structure. High node counts, acceleration structure
inefficiency, and ray divergence across a warp can all cause the counter value
to be high.</p>
<p>Nodes have a variable duration that depends on the number of bounding boxes
they contain, and the number of active rays in each warp.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUBox</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitBoxWorkloadBoxTests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_BOX</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_raytracingunittriangleworkload">Ray Tracing Unit Triangle Workload <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of triangles processed by the triangle test
unit, including key properties of the triangles.</p>
<div class="lgc-series">
<h4 id="c_308">Opaque triangle hits <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every ray intersection with an opaque triangle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUOpaqueHit</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitTriangleWorkloadOpaqueTriangleHits</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_OPAQUE_HIT</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_309">Non-opaque triangle hits <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every ray intersection with a non-opaque triangle.</p>
<p>Non-opaque triangles are more expensive to process than opaque triangles, so
Arm recommends using opaque triangles in acceleration structures.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUNonOpaqueHit</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitTriangleWorkloadNonOpaqueTriangleHits</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_NON_OPAQUE_HIT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_210">Triangle nodes tested <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every triangle node tested. If this value is high
then the ray tracing unit spent a lot of time testing for intersection with
triangles, and can be caused by high triangle counts, acceleration structure
inefficiency, and ray divergence across a warp.</p>
<p>Nodes have a variable duration that depends on the number of triangles they
contain, and the number of active rays in each warp.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliRTUTri</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliRayTracingUnitTriangleWorkloadTriangleNodesTested</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>RT_RAY_TRI</code>
</div>
</div>
</div>
</div>
<div class="lgc-section lgc-advanced-app">
<h2 id="s_shadercoreotherunits">Shader Core Other Units <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>In addition to the main units, covered in earlier sections, the shader core has
several other units that can be measured.</p>
<p>Performance counters in this section show the workload on these other units.</p>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_attributeunitrequests">Attribute Unit Requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of requests made to the attribute unit.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_283">Attribute requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every instruction run by the attribute unit.</p>
<p>Each instruction converts a logical attribute access into a pointer-based
access, which is then processed by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliAttrInstr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliAttributeUnitRequestsAttributeRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>ATTR_INSTR</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_shadercorememoryaccess">Shader Core Memory Access <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>GPUs are data-plane processors, so understanding your memory bandwidth and
where it is coming from is a critical piece of knowledge when trying to improve
performance.</p>
<p>Performance counters in this section show the breakdown of memory accesses by
shader core hardware unit, showing the total amount of read and write bandwidth
being generated by the shader core.</p>
<p>Read bandwidth is split to show how much was provided by the GPU L2 cache and
how much was provided by the external memory system. Write bandwidth does not
have an equivalent split, and it is not possible to tell from the counters if a
write went to L2 or directly to external memory.</p>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_shadercorel2reads">Shader Core L2 Reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of shader core read transactions served
from the L2 cache, broken down by hardware unit inside the shader core.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_285">Fragment front-end beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the fixed-function
fragment front-end.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusFFEL2RdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2ReadsFragmentFrontEndBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_FTC</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_287">Load/store unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSL2RdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2ReadsLoadStoreUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_LSC</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_289">Texture unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexL2RdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2ReadsTextureUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_TEX</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_291">Other unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by any unit that is not
identified as a specific data destination.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusOtherL2RdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2ReadsOtherUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_OTHER</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_shadercoreexternalreads">Shader Core External Reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of shader core read transactions served
from external memory, broken down by hardware unit inside the shader core.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_286">Fragment front-end beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the fixed-function
fragment front-end that required an external memory access because of an L2
cache miss.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusFFEExtRdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreExternalReadsFragmentFrontEndBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_FTC_EXT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_288">Load/store unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the load/store unit
that required an external memory access because of an L2 cache miss.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSExtRdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreExternalReadsLoadStoreUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_LSC_EXT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_290">Texture unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read beat received by the texture unit that
required an external memory access because of an L2 cache miss.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexExtRdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreExternalReadsTextureUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_RD_TEX_EXT</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_shadercorel2writes">Shader Core L2 Writes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of shader core write transactions, broken
down by hardware unit inside the shader core.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_292">Load/store unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write beat sent by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSWrBt</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusLSWBWrBt + MaliSCBusLSOtherWrBt</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreL2WritesLoadStoreUnitWriteBackBeats + $MaliShaderCoreL2WritesLoadStoreUnitOtherBeats</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_WR_LSC_WB + BEATS_WR_LSC_OTHER</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_293">Load/store unit write-back beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write beat by the load/store unit that are
because of write-back.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSWBWrBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2WritesLoadStoreUnitWriteBackBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_WR_LSC_WB</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_294">Load/store unit other beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write beat by the load/store unit that are
because of any reason other than write-back.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSOtherWrBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2WritesLoadStoreUnitOtherBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_WR_LSC_OTHER</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_295">Tile unit beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write beat sent by the tile write-back unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTileWrBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliShaderCoreL2WritesTileUnitBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BEATS_WR_TIB</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shadercorel2readbytes">Shader Core L2 Read Bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes read from the L2 cache by the
shader core, broken down by hardware unit inside the shader core.</p>
<div class="lgc-series">
<h4 id="c_65659">Fragment front-end bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the L2 memory
system by the fragment front-end.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusFFEL2RdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusFFEL2RdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreL2ReadsFragmentFrontEndBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_FTC * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65631">Load/store unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the L2 memory
system by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSL2RdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusLSL2RdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreL2ReadsLoadStoreUnitBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_LSC * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65635">Texture unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the L2 memory
system by the texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexL2RdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusTexL2RdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreL2ReadsTextureUnitBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_TEX * 16</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shadercoreexternalreadbytes">Shader Core External Read Bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes read from external memory by the
shader core, broken down by hardware unit inside the shader core.</p>
<div class="lgc-series">
<h4 id="c_65660">Fragment front-end bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the external memory
system by the fragment front-end.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusFFEExtRdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusFFEExtRdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreExternalReadsFragmentFrontEndBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_FTC_EXT * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65633">Load/store unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the external memory
system by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSExtRdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusLSExtRdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreExternalReadsLoadStoreUnitBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_LSC_EXT * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65637">Texture unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes read from the external memory
system by the texture unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexExtRdBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusTexExtRdBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreExternalReadsTextureUnitBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_RD_TEX_EXT * 16</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_shadercorel2writebytes">Shader Core L2 Write Bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes written by the shader core, broken
down by hardware unit inside the shader core.</p>
<p>These writes are written to the L2 memory system, but counters cannot determine
if the write was written to the L2 cache or directly to external memory.</p>
<div class="lgc-series">
<h4 id="c_65639">Load/store unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes written to the L2 memory
system by the load/store unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSWrBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusLSWBWrBt + MaliSCBusLSOtherWrBt) * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreL2WritesLoadStoreUnitWriteBackBeats + $MaliShaderCoreL2WritesLoadStoreUnitOtherBeats) * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_WR_LSC_WB + BEATS_WR_LSC_OTHER) * 16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65642">Tile unit bytes <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the total number of bytes written to the L2 memory
system by the tile write-back unit.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTileWrBy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MaliSCBusTileWrBt * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliShaderCoreL2WritesTileUnitBeats * 16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>BEATS_WR_TIB * 16</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_loadstoreunitbytescycle">Load/Store Unit Bytes/Cycle <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes accessed in the L2 cache and
external memory per load/store cache access cycle. This gives some measure of
how effectively the GPU is caching load/store data.</p>
<div class="lgc-series">
<h4 id="c_65632">L2 read bytes/cy <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes read from the L2 memory
system by the load/store unit per read cycle. This metric gives some idea how
effectively data is being cached in the L1 load/store cache.</p>
<p>If more bytes are being requested per access than you would expect for the data
layout you are using, review your data layout and access patterns.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSL2RdByPerRd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusLSL2RdBt * 16) / (MaliLSFullRd + MaliLSPartRd)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreL2ReadsLoadStoreUnitBeats * 16) / ($MaliLoadStoreUnitCyclesFullReads + $MaliLoadStoreUnitCyclesPartialReads)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_RD_LSC * 16) / (LS_MEM_READ_FULL + LS_MEM_READ_SHORT)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65641">L2 write bytes/cy <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes written to the L2 memory
system by the load/store unit per write cycle.</p>
<p>If more bytes are being written per access than you would expect for the data
layout you are using, review your data layout and access patterns to improve
cache locality.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSWrByPerWr</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>((MaliSCBusLSWBWrBt + MaliSCBusLSOtherWrBt) * 16) / (MaliLSFullWr + MaliLSPartWr)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>(($MaliShaderCoreL2WritesLoadStoreUnitWriteBackBeats + $MaliShaderCoreL2WritesLoadStoreUnitOtherBeats) * 16) / ($MaliLoadStoreUnitCyclesFullWrites + $MaliLoadStoreUnitCyclesPartialWrites)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>((BEATS_WR_LSC_WB + BEATS_WR_LSC_OTHER) * 16) / (LS_MEM_WRITE_FULL + LS_MEM_WRITE_SHORT)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65634">External read bytes/cy <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes read from the external
memory system by the load/store unit per read cycle. This metric indicates how
effectively data is being cached in the L2 cache.</p>
<p>If more bytes are being requested per access than you would expect for the data
layout you are using, review your data layout and access patterns.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusLSExtRdByPerRd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusLSExtRdBt * 16) / (MaliLSFullRd + MaliLSPartRd)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreExternalReadsLoadStoreUnitBeats * 16) / ($MaliLoadStoreUnitCyclesFullReads + $MaliLoadStoreUnitCyclesPartialReads)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_RD_LSC_EXT * 16) / (LS_MEM_READ_FULL + LS_MEM_READ_SHORT)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_textureunitbytescycle">Texture Unit Bytes/Cycle <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes accessed in the L2 cache and
external memory per texture sample. This gives some measure of how effectively
the GPU is caching texture data.</p>
<div class="lgc-series">
<h4 id="c_65636">L2 read bytes/cy <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes read from the L2 memory
system by the texture unit per filtering cycle. This metric indicates how
effectively textures are being cached in the L1 texture cache.</p>
<p>If more bytes are being requested per access than you would expect for the
format you are using, review your texture settings. Arm recommends:</p>
<ul>
<li>Using mipmaps for offline generated textures.</li>
<li>Using ASTC or ETC compression for offline generated textures.</li>
<li>Replacing runtime framebuffer formats with narrower formats.</li>
<li>Reducing use of imageLoad/Store to allow framebuffer compression.</li>
<li>Reducing use of negative LOD bias used for texture sharpening.</li>
<li>Reducing use of anisotropic filtering, or reducing the level of
  MAX_ANISOTROPY used.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexL2RdByPerRd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusTexL2RdBt * 16) / MaliTexFiltIssueCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreL2ReadsTextureUnitBeats * 16) / $MaliTextureUnitCyclesFilteringActive</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_RD_TEX * 16) / TEX_FILT_NUM_OPERATIONS</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65638">External read bytes/cy <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes read from the external
memory system by the texture unit per filtering cycle. This metric indicates
how effectively textures are being cached in the L2 cache.</p>
<p>If more bytes are being requested per access than you would expect for the
format you are using, review your texture settings. Arm recommends:</p>
<ul>
<li>Using mipmaps for offline generated textures.</li>
<li>Using ASTC or ETC compression for offline generated textures.</li>
<li>Replacing runtime framebuffer formats with narrower formats.</li>
<li>Reducing use of imageLoad/Store to allow framebuffer compression.</li>
<li>Reducing use of negative LOD bias used for texture sharpening.</li>
<li>Reducing use of anisotropic filtering, or reducing the level of
  MAX_ANISOTROPY used.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTexExtRdByPerRd</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusTexExtRdBt * 16) / MaliTexFiltIssueCy</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreExternalReadsTextureUnitBeats * 16) / $MaliTextureUnitCyclesFilteringActive</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_RD_TEX_EXT * 16) / TEX_FILT_NUM_OPERATIONS</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_tileunitbytespixel">Tile Unit Bytes/Pixel <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of bytes written by the tile unit per
output pixel. This can be used to determine the efficiency of application
render pass store configuration.</p>
<p>Applications can minimize the number of bytes stored by following best
practices:</p>
<ul>
<li>Use the smallest pixel color format that meets your requirements.</li>
<li>Discard transient attachments that are no longer required at the end of
  each render pass (Vulkan storeOp=DONT_CARE or storeOp=NONE).</li>
<li>Use resolve attachments to resolve multi-sampled data into a single value
  as part of tile write-back and discard the multi-sampled data so that it is
  not written back to memory.</li>
</ul>
<div class="lgc-series">
<h4 id="c_544">External write bytes/px <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the average number of bytes written to the L2 memory
system by the tile unit per output pixel.</p>
<p>If more bytes are being written per pixel than expected, Arm recommends:</p>
<ul>
<li>Using narrower attachment color formats with fewer bytes per pixel.</li>
<li>Configuring attachments so that they can use framebuffer compression.</li>
<li>Invalidating transient attachments to skip writing to memory.</li>
<li>Using inline multi-sample resolve to skip writing the multi-sampled data to
  memory.</li>
</ul>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusTileWrBPerPx</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>(MaliSCBusTileWrBt * 16) / (MaliMainQueueTask * 4096)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliShaderCoreL2WritesTileUnitBeats * 16) / ($MaliGPUTasksMainPhaseTasks * 4096)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>(BEATS_WR_TIB * 16) / (ITER_FRAG_TASK_COMPLETED * 4096)</code></pre>
</div>
</div></div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_tiling">Tiling <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The tiler hardware orchestrates vertex shading, and binning primitives into the
tile lists read during fragment shading.</p>
<p>Performance counters in this section show how the tiler processed the binning
phase vertex and primitive workload.</p>
<p>This GPU uses deferred vertex shading, so the binning phase vertex shading
tracked by the tiler performance counters includes only the position shader.
Varying shading is deferred until the main phase of render pass processing for
most draw calls.</p>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_tilerstallcycles">Tiler Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of cycles that individual sub-units inside
the tiler were stalled.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_162">Position FIFO full stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the tiler has a position shading
request that it can not send to a shader core because the position buffer is
full.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerPosShadFIFOFullCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerStallCyclesPositionFIFOFullStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>POS_FIFO_FULL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_161">Position shading stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the tiler has a position shading
request that it can not send to a shader core because the shading request queue
is full.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerPosShadStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerStallCyclesPositionShadingStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>POS_SHADER_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_336">Primitive assembly position shading stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the late primitive assembly
stage is waiting for a position shading request to complete.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerPrimAsPosShadStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerStallCyclesPrimitiveAssemblyPositionShadingStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>PRIMASSY_POS_SHADER_WAIT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_176">Varying shading stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every clock cycle when the tiler has a varying shading
request that it can not send to a shader core because the shading request queue
is full.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerVarShadStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerStallCyclesVaryingShadingStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VAR_SHADER_STALL</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_tilervertexcache">Tiler Vertex Cache <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of accesses made into the vertex position
and varying post-transform caches.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_164">Position cache hits <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every time a vertex position lookup hits in the vertex
cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerPosCacheHit</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerVertexCachePositionCacheHits</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VCACHE_HIT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_172">Varying cache hits <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments every time a vertex varying lookup results in a
successful hit in the vertex cache.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerVarCacheHit</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerVertexCacheVaryingCacheHits</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VBU_HIT</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_tilerl2accesses">Tiler L2 Accesses <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of tiler memory transactions into the L2
memory system.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_154">Read beats <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every data read cycle the tiler uses on the
internal bus.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTilerRdBt</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerL2AccessesReadBeats</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>BUS_READ</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_tilershadingrequests">Tiler Shading Requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group tracks the number of shading requests that are made by the
tiler when processing vertex shaders during binning.</p>
<p>Application vertex shaders are split into two pieces, a position shader that
computes the vertex position, and a varying shader that computes the remaining
vertex shader outputs. The varying shader is only run if a group contains
visible vertices that survive primitive culling.</p>
<p>This GPU uses deferred vertex shading and will not varying shader all
primitives in the binning phase.</p>
<div class="lgc-series">
<h4 id="c_159">Position shading requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every position shading request in the tiler
geometry flow. Position shading runs the first part of the vertex shader,
computing the position required to perform clipping and culling. A vertex that
has been evicted from the post-transform cache must be reshaded if used again,
so your index buffers must have good spatial locality of index reuse.</p>
<p>Each request contains <a href="#c_65564">16</a> vertices.</p>
<p>Note that not all types of draw call use this tiler workflow, so this counter
might not account for all submitted geometry.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomPosShadTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerShadingRequestsPositionShadingRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>POS_SHADER_WARPS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_175">Varying shading requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every varying shading request in the tiler geometry
flow. Varying shading runs the second part of the vertex shader, for any
primitive that survives clipping and culling. The same vertex is shaded
multiple times if it has been evicted from the post-transform cache before
reuse occurs. Keep good spatial locality of index reuse in your index buffers.</p>
<p>Each request contains <a href="#c_65564">16</a> vertices.</p>
<p>Note that not all types of draw call use this tiler workflow, so this counter
might not account for all submitted geometry.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomVarShadTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerShadingRequestsVaryingShadingRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VAR_SHADER_WARPS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_368">Partial position shading requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every partial position shading request from the
tiler geometry flow. Partial tasks cannot fill a shader core warp, and can
result in lost efficiency.</p>
<p>Each request contains fewer than <a href="#c_65564">16</a> vertices.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomPosShadPartTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerShadingRequestsPartialPositionShadingRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>POS_SHADER_PARTIAL_WARPS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_369">Partial varying shading requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every partial varying shading request from the
tiler geometry flow. Partial tasks cannot fill a shader core warp, and can
result in lost efficiency.</p>
<p>Each request contains fewer than <a href="#c_65564">16</a> vertices.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomVarShadPartTask</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerShadingRequestsPartialVaryingShadingRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>VAR_SHADER_PARTIAL_WARPS</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_tilerworkloadproperties">Tiler Workload Properties <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows workload properties of the primitive stream being
process by the tiler.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_335">DVS primitives <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every visible primitive that is using deferred
vertex shading that survives all culling stages.</p>
<p>All fragments of the primitive might be occluded by other primitives closer to
the camera, and so produce no visible output.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGeomVisibleDVSPrim</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliTilerWorkloadPropertiesDVSPrimitives</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>PRIM_VISIBLE_DVS</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_internalmemorysystem">Internal Memory System <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>The GPU internal memory interface connects the processing units, such as the
shader cores and the tiler, to the GPU L2 cache.</p>
<p>Performance counters in this section show reads and writes into the L2 cache
and how the cache responded to them.</p>
<div class="lgc-group lgc-advanced-app lgc-advanced-sys">
<h3 id="g_l2cacherequests">L2 Cache Requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of requests made into the L2 cache
from any source. This includes any requests made</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_94">Read requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read request received by the L2 cache from an
internal requester.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheRd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsReadRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_IN</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_98">Write requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every write request received by the L2 cache from
an internal requester.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheWr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsWriteRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_WR_MSG_IN</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_100">Snoop requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every coherency snoop request received by the L2
cache from internal requesters.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheSnp</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsSnoopRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_SNP_MSG_IN</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_96">Clean unique requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every line clean unique request received by the L2
cache from an internal requester.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheCleanUnique</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsCleanUniqueRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_IN_CU</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_95">Evict requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every line evict request received by the L2 cache
from an internal requester.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheEvict</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsEvictRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_IN_EVICT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_102">L1 read requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L1 cache read request or read response sent
by the L2 cache to an internal requester.</p>
<p>Read requests are triggered by a snoop request from one requester that needs
data from another requester's L1 to resolve.</p>
<p>Read responses are standard responses back to a requester in response to its
own read requests.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheL1Rd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsL1ReadRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_OUT</code>
</div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_106">L1 write requests <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L1 cache write response sent by the L2 cache
to an internal requester.</p>
<p>Write responses are standard responses back to a requester in response to its
own write requests.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheL1Wr</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheRequestsL1WriteRequests</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_WR_MSG_OUT</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_l2cachelookups">L2 Cache Lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of lookups made into the L2 cache
from any source.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_107">Any lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L2 cache lookup made, including all reads,
writes, coherency snoops, and cache flush operations.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheLookup</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheLookupsAnyLookups</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_ANY_LOOKUP</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_108">Read lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L2 cache read lookup made.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheRdLookup</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheLookupsReadLookups</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_READ_LOOKUP</code>
</div>
</div>
<div class="lgc-series">
<h4 id="c_109">Write lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every L2 cache write lookup made.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheWrLookup</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheLookupsWriteLookups</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_WRITE_LOOKUP</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_110">External snoop lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every coherency snoop lookup performed that is
triggered by a requester outside of the GPU.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheSnpLookup</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheLookupsExternalSnoopLookups</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_EXT_SNOOP_LOOKUP</code>
</div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_l2cachestallcycles">L2 Cache Stall Cycles <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the total number of stall cycles that impact L2 cache
lookups.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_97">Read stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle an L2 cache read request from an
internal requester is stalled.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheRdStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheStallCyclesReadStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_IN_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_99">Write stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when an L2 cache write request
from an internal requester is stalled.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheWrStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheStallCyclesWriteStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_WR_MSG_IN_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_101">Snoop stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when an L2 cache coherency snoop
request from an internal requester is stalled.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheSnpStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheStallCyclesSnoopStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_SNP_MSG_IN_STALL</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_105">L1 read stalls <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every clock cycle when L1 cache read requests and
responses sent by the L2 cache to an internal requester are stalled.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheL1RdStallCy</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliL2CacheStallCyclesL1ReadStalls</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>L2_RD_MSG_OUT_STALL</code>
</div>
</div>
</div>
<div class="lgc-group">
<h3 id="g_l2cachemissrate">L2 Cache Miss Rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the miss rate in the L2 cache.</p>
<div class="lgc-series">
<h4 id="c_65547">Read miss rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of internal L2 cache reads that result
in an external read.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheRdMissRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliExtBusRd / MaliL2CacheRdLookup) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliExternalBusAccessesReadTransactions / $MaliL2CacheLookupsReadLookups) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((L2_EXT_READ / L2_READ_LOOKUP) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65552">Write miss rate <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This expression defines the percentage of internal L2 cache writes that result
in an external write.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliL2CacheWrMissRate</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>max(min((MaliExtBusWr / MaliL2CacheWrLookup) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>max(min(($MaliExternalBusAccessesWriteTransactions / $MaliL2CacheLookupsWriteLookups) * 100, 100), 0)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>max(min((L2_EXT_WRITE / L2_WRITE_LOOKUP) * 100, 100), 0)</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-sys">
<h3 id="g_stage1mmutranslations">Stage 1 MMU Translations <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This counter group shows the number of stage 1 page table lookups handled by
the GPU MMU.</p>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_84">MMU lookups <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every address lookup made by the main GPU MMU.
Increments only occur if all lookups into a local TLB miss.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMMULookup</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliStage1MMUTranslationsMMULookups</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MMU_REQUESTS</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_86">L2 table reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read of a level 2 MMU translation table
entry. Each address translation at this level covers a 2MB section, which is
typically broken down into further into 4KB pages using a subsequent level 3
translation table lookup.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMMUL2Rd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliStage1MMUTranslationsL2TableReads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MMU_TABLE_READS_L2</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_88">L2 table read hits <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read of a level 2 MMU translation table entry
that results in a successful hit in the main MMU's TLB.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMMUL2Hit</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliStage1MMUTranslationsL2TableReadHits</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MMU_HIT_L2</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_85">L3 table reads <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read of a level 3 MMU translation table
entry. Each address translation at this level covers a single 4KB page.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMMUL3Rd</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliStage1MMUTranslationsL3TableReads</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MMU_TABLE_READS_L3</code>
</div>
</div>
<div class="lgc-series lgc-advanced-sys">
<h4 id="c_87">L3 table read hits <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This counter increments for every read of a level 3 MMU translation table entry
that results in a successful hit in the main MMU's TLB.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMMUL3Hit</code>
</div>
<div class="lgc-equation-format-sl">
Streamline name: <code>$MaliStage1MMUTranslationsL3TableReadHits</code>
</div>
<div class="lgc-equation-format-hw">
Hardware name: <code>MMU_HIT_L3</code>
</div>
</div>
</div>
</div>
<div class="lgc-section">
<h2 id="s_constants">Constants <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h2>
<p>Arm GPUs are configurable, with variable performance across products, and
variable configurations across devices.</p>
<p>This section lists useful symbolic configuration and constant values that can
be used in expressions to compute derived counters. Note that configuration
values must be provided by a run-time tool that can query the actual
implementation configuration of the target device.</p>
<div class="lgc-group">
<h3 id="g_implementationconfiguration">Implementation Configuration <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This constants group contains symbolic constants that define the configuration
of a particular device. These must be populated by the counter sampling runtime
tooling.</p>
<div class="lgc-series">
<h4 id="c_65655">Shader core count <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This configuration constant defines the number of shader cores in the design.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliConfigCoreCount</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MALI_CONFIG_SHADER_CORE_COUNT</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliConstantsShaderCoreCount</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>MALI_CONFIG_SHADER_CORE_COUNT</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65654">L2 cache slice count <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This configuration constant defines the number of L2 cache slices in the
design.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliConfigL2CacheCount</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MALI_CONFIG_L2_CACHE_COUNT</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>$MaliConstantsL2SliceCount</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>MALI_CONFIG_L2_CACHE_COUNT</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series">
<h4 id="c_65653">External bus beat size <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This configuration constant defines the number of bytes transferred per
external bus beat.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliConfigExtBusBeatSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>($MaliConstantsBusWidthBits / 8)</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>MALI_CONFIG_EXT_BUS_BYTE_SIZE</code></pre>
</div>
</div></div>
</div>
</div>
<div class="lgc-group lgc-advanced-app">
<h3 id="g_staticconfiguration">Static Configuration <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h3>
<p>This constants group contains literal constants that define the static
configuration and performance characteristics of this product.</p>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_445">Main phase queue task size <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of pixels in each axis per main phase queue
task.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliMainQueueTaskSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>64</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>64</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>64</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65564">Tiler shader task thread count <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of threads per vertex shading task issued by
the tiler, to perform position shading or varying shading concurrently, for
multiple sequential vertices.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUGeomTaskSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65647">Tile size <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the size of a tile.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUTileSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>32</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>32</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>32</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65656">Tile storage/pixel <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of bits of color storage per pixel available
when using a <a href="#c_65647">32</a> x <a href="#c_65647">32</a> tile size.
If you use more storage than the available storage for multi-sampling, wide
color formats, or multiple render targets, the driver dynamically reduces the
tile size until sufficient storage is available.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUMaxPixelStorage</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>256</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>256</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>256</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65649">Warp size <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of threads in a single warp.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliGPUWarpSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_322">Varying slot count <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of varying unit slots.</p>
<p>The width of a slot is GPU-dependent.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliVarSlotPerCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>4</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>4</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65610">Texture samples/cycle <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the maximum number of texture samples that can be made
per cycle.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexSamplePerCy</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>8</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>8</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>8</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65611">Texture cycles/sample <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the minimum number of cycles needed to make a texture
sample.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliTexCyPerSample</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>0.125</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>0.125</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>0.125</code></pre>
</div>
</div></div>
</div>
<div class="lgc-series lgc-advanced-app">
<h4 id="c_65652">Internal bus beat size <span data-bs-toggle="tooltip" data-bs-delay="400" data-bs-placement="right" title="Copy to clipboard"><a class="lgc-link-copy link-secondary"><i class="fa-solid fa-link"></i></a></span></h4>
<p>This constant defines the number of bytes transferred per internal bus beat.</p>
<div class="lgc-equation-format-lgc">
libGPUCounters name: <code>MaliSCBusBeatSize</code>
</div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-lgc">
<p>libGPUCounters derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-sl">
<p>Streamline derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
<div><div class="lgc-equation">
<div class="lgc-equation-format-hw">
<p>Hardware derivation:</p>
<pre><code>16</code></pre>
</div>
</div></div>
</div>
</div>
</div>
      </div>
      <div class="lgc-footerpanel">
        <p>Copyright &copy; Arm 2025</p>
      </div>
    </div>
  </main>
  <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
    <div id="liveToast" class="toast hide" role="alert">
      <div class="toast-header">
        <strong class="me-auto">Note</strong>
        <button type="button" class="btn-close" data-bs-dismiss="toast"></button>
      </div>
      <div class="toast-body">
        <p>Your address selected an advanced counter, so advanced counters have
           been automatically enabled. They can be disabled in the side menu.</p>
      </div>
    </div>
  </div>
  <script src="./js/bootstrap-5.3.8.bundle.min.js"></script>
  <script src="./js/fontawesome-7.1.0.all.min.js"></script>
  <script src="./js/jquery-3.7.1.min.js"></script>
  <script src="./js/document.js"></script>
</body>
</html>
